{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>Via <a href=\"http://geoffreymoller.com/2007/05/15/when-javascript-libraries-attack/\">Geoffery Moller</a>, I came across <a href=\"http://mattsnider.com/javascript/prototype-vs-yui-round-1-oop-architecture/\">this article</a> on Matt Snider&rsquo;s blog.  I&rsquo;m surprised that no one noticed what (to me) was the most relevant difference in the libraries that he evaluated.</p>\n\n<p>The &ldquo;YUI method of class creation&rdquo; is not distinctively YUI&mdash;it&rsquo;s just what Javascript gives you for free.  You can use the &ldquo;Module Pattern&rdquo; alone on a page with no library at all!  You can call it Crockford&rsquo;s Module Pattern, but it seems to me that he discovered or popularized it more than &ldquo;invented&rdquo; it.</p>\n\n<p>This, to me, highlights the biggest difference in approach between YUI and every other library: YUI doesn&rsquo;t attempt to re-write the language, but rather to show off what the language can do and how those features can be effectively put to use.  My experience with Prototype and Dojo and Mochikit all made me feel a bit like the author must not have liked Javascript very much.  (Dojo actually goes a bit further&mdash;it rewrites HTML as well!)  It seems like the other libraries say, &ldquo;This Javascript language is too hard and confusing.  Let&rsquo;s make it into something else.&rdquo;  YUI says, &ldquo;This language is beautiful and powerful, but it would be handy if we had some conventions and a common approach to these rough edges.  Let&rsquo;s build those common pieces.&rdquo;  It&rsquo;s the difference between teaching someone to fish and giving them a fish, except instead of giving him a fish, you pass the fish through a slow and complex machine that spits out Java code.</p>\n\n<p>Of course, I&rsquo;m a bit biased.  I <a href=\"http://www.codinghorror.com/blog/archives/000921.html\">imprinted upon YUI</a> at a fairly early stage in my Javascript development.  I work <a href=\"http://yahoo.com\">here</a>, so I get to request features directly through our internal bugzilla instead of pleading in the public arenas.  But the approach is one that I&rsquo;ve always favored.  If you feel the need to rewrite the language, then just go use another language.  Javascript is the common tongue of the internet, and will remain so for the indefinite future.  Don&rsquo;t fight it. (<a href=\"http://www.codinghorror.com/blog/archives/000857.html\">Hat-tip</a> to Jeff Atwood.)</p>\n\n<p>Crockford&rsquo;s &ldquo;Module Pattern&rdquo; is a great way to create a singleton that has some private methods.  In fact, in my opinion, it&rsquo;s the best and only way that this task should be done.  (There are others, but they tend to be more obtuse, IMO.)  But that&rsquo;s not the only task of an object-oriented development.  Sometimes, you need to have a bunch of objects, and if they have shared functionality, then that should be handled with a class of sorts.  In Javascript, that means that they&rsquo;re stamped from the same Constructor and Prototype.  The Module Pattern does not address this in a very clear way, but it does highlight the principle of data-hiding through a closure that is the key to OOP in Javascript.</p>\n\n<p>To create a class, I usually do something like this, which takes the essence of the Module Pattern and uses it to create a reusable class.</p>\n\n<p><code class=\"block javascript\">(function () {<br/>\n\u00a0\u00a0// these are properly private static, not just private\n\u00a0\u00a0// but with scope correction, that's good enough for functions.<br/>\n\u00a0\u00a0// private function, called with privateFunction.call(this, a, b, c);\n\u00a0\u00a0var privateFunction = function (a, b) {\n\u00a0\u00a0\u00a0\u00a0this.a = a;\n\u00a0\u00a0\u00a0\u00a0this.b = b;\n\u00a0\u00a0};<br/>\n\u00a0\u00a0// private static data.  Shared between all instances!\n\u00a0\u00a0var privateStaticData = \"I'm private and static.  All instances share me.\";<br/>\n\u00a0\u00a0YAHOO.myProject.myClass = function (a, b, id) {\n\u00a0\u00a0\u00a0\u00a0// a and b are public, since they're set on this.\n\u00a0\u00a0\u00a0\u00a0this.a = a;\n\u00a0\u00a0\u00a0\u00a0this.b = b;\n\u00a0\u00a0\u00a0\u00a0YAHOO.myProject.myClass.instances[id] = this;\n\u00a0\u00a0};<br/>\n\u00a0\u00a0YAHOO.myProject.myClass.instances = {};<br/>\n\u00a0\u00a0YAHOO.myProject.myClass.prototype = {\n\u00a0\u00a0\u00a0\u00a0myPublicProperty : \"I'm accessible as <object reference>.myPublicProperty.\",\n\u00a0\u00a0\u00a0\u00a0myPublicMethod : function () {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var a = (new Date()).getTime();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var b = a + 10000;<br/>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// note the way that private functions are called.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0privateFunction.call(this, a, b);\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\n\u00a0\u00a0};<br/>\n})(); // close the closure and execute the code.<br/>\n// later on...\n(function () {\n\u00a0\u00a0var myInstance = new YAHOO.myProject.myClass(1,2,'blahblah');\n\u00a0\u00a0// now you can deal with it as \"myInstance\" within this closure,\n\u00a0\u00a0// or as YAHOO.myProject.myClass.instances.blahblah elsewhere.\n})();</object></code></p>\n\n<p>(When in doubt, wrap it in a closure.  <a href=\"http://yuiblog.com/blog/2006/06/01/global-domination/\">Global variables are evil.</a>)</p>\n\n<p>I&rsquo;d rather work with someone who is a bit green with Javascript but can learn, rather than someone who is an expert with Prototype or Dojo.  <em>The more time someone spends building applications with a library like Prototype, the further they get from Javascript, and the more dependent they become on the library.</em>  By contrast, time spent using YUI tends to breed developers who are experts in <em>Javascript</em>, and that skill is far more useful than being an expert in a particular library.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2007-08-13 17:47:36 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 146671880,
    "is_blocks_post_format": false,
    "note_count": 2,
    "post_url": "http://blog.izs.me/post/146671880/yuis-module-pattern-vs-prototypes-class",
    "reblog": {
        "comment": "<p>Via <a href=\"http://geoffreymoller.com/2007/05/15/when-javascript-libraries-attack/\">Geoffery Moller</a>, I came across <a href=\"http://mattsnider.com/javascript/prototype-vs-yui-round-1-oop-architecture/\">this article</a> on Matt Snider\u2019s blog.  I\u2019m surprised that no one noticed what (to me) was the most relevant difference in the libraries that he evaluated.</p>\n\n<p>The \u201cYUI method of class creation\u201d is not distinctively YUI\u2014it\u2019s just what Javascript gives you for free.  You can use the \u201cModule Pattern\u201d alone on a page with no library at all!  You can call it Crockford\u2019s Module Pattern, but it seems to me that he discovered or popularized it more than \u201cinvented\u201d it.</p>\n\n<p>This, to me, highlights the biggest difference in approach between YUI and every other library: YUI doesn\u2019t attempt to re-write the language, but rather to show off what the language can do and how those features can be effectively put to use.  My experience with Prototype and Dojo and Mochikit all made me feel a bit like the author must not have liked Javascript very much.  (Dojo actually goes a bit further\u2014it rewrites HTML as well!)  It seems like the other libraries say, \u201cThis Javascript language is too hard and confusing.  Let\u2019s make it into something else.\u201d  YUI says, \u201cThis language is beautiful and powerful, but it would be handy if we had some conventions and a common approach to these rough edges.  Let\u2019s build those common pieces.\u201d  It\u2019s the difference between teaching someone to fish and giving them a fish, except instead of giving him a fish, you pass the fish through a slow and complex machine that spits out Java code.</p>\n\n<p>Of course, I\u2019m a bit biased.  I <a href=\"http://www.codinghorror.com/blog/archives/000921.html\">imprinted upon YUI</a> at a fairly early stage in my Javascript development.  I work <a href=\"http://yahoo.com\">here</a>, so I get to request features directly through our internal bugzilla instead of pleading in the public arenas.  But the approach is one that I\u2019ve always favored.  If you feel the need to rewrite the language, then just go use another language.  Javascript is the common tongue of the internet, and will remain so for the indefinite future.  Don\u2019t fight it. (<a href=\"http://www.codinghorror.com/blog/archives/000857.html\">Hat-tip</a> to Jeff Atwood.)</p>\n\n<p>Crockford\u2019s \u201cModule Pattern\u201d is a great way to create a singleton that has some private methods.  In fact, in my opinion, it\u2019s the best and only way that this task should be done.  (There are others, but they tend to be more obtuse, IMO.)  But that\u2019s not the only task of an object-oriented development.  Sometimes, you need to have a bunch of objects, and if they have shared functionality, then that should be handled with a class of sorts.  In Javascript, that means that they\u2019re stamped from the same Constructor and Prototype.  The Module Pattern does not address this in a very clear way, but it does highlight the principle of data-hiding through a closure that is the key to OOP in Javascript.</p>\n\n<p>To create a class, I usually do something like this, which takes the essence of the Module Pattern and uses it to create a reusable class.</p>\n\n<p><code class=\"block javascript\">(function () {<br>\n\u00a0\u00a0// these are properly private static, not just private\n\u00a0\u00a0// but with scope correction, that's good enough for functions.<br>\n\u00a0\u00a0// private function, called with privateFunction.call(this, a, b, c);\n\u00a0\u00a0var privateFunction = function (a, b) {\n\u00a0\u00a0\u00a0\u00a0this.a = a;\n\u00a0\u00a0\u00a0\u00a0this.b = b;\n\u00a0\u00a0};<br>\n\u00a0\u00a0// private static data.  Shared between all instances!\n\u00a0\u00a0var privateStaticData = \"I'm private and static.  All instances share me.\";<br>\n\u00a0\u00a0YAHOO.myProject.myClass = function (a, b, id) {\n\u00a0\u00a0\u00a0\u00a0// a and b are public, since they're set on this.\n\u00a0\u00a0\u00a0\u00a0this.a = a;\n\u00a0\u00a0\u00a0\u00a0this.b = b;\n\u00a0\u00a0\u00a0\u00a0YAHOO.myProject.myClass.instances[id] = this;\n\u00a0\u00a0};<br>\n\u00a0\u00a0YAHOO.myProject.myClass.instances = {};<br>\n\u00a0\u00a0YAHOO.myProject.myClass.prototype = {\n\u00a0\u00a0\u00a0\u00a0myPublicProperty : \"I'm accessible as <object reference>.myPublicProperty.\",\n\u00a0\u00a0\u00a0\u00a0myPublicMethod : function () {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var a = (new Date()).getTime();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var b = a + 10000;<br>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// note the way that private functions are called.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0privateFunction.call(this, a, b);\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\n\u00a0\u00a0};<br>\n})(); // close the closure and execute the code.<br>\n// later on...\n(function () {\n\u00a0\u00a0var myInstance = new YAHOO.myProject.myClass(1,2,'blahblah');\n\u00a0\u00a0// now you can deal with it as \"myInstance\" within this closure,\n\u00a0\u00a0// or as YAHOO.myProject.myClass.instances.blahblah elsewhere.\n})();</object></code></p>\n\n<p>(When in doubt, wrap it in a closure.  <a href=\"http://yuiblog.com/blog/2006/06/01/global-domination/\">Global variables are evil.</a>)</p>\n\n<p>I\u2019d rather work with someone who is a bit green with Javascript but can learn, rather than someone who is an expert with Prototype or Dojo.  <em>The more time someone spends building applications with a library like Prototype, the further they get from Javascript, and the more dependent they become on the library.</em>  By contrast, time spent using YUI tends to breed developers who are experts in <em>Javascript</em>, and that skill is far more useful than being an expert in a particular library.</p>",
        "tree_html": ""
    },
    "reblog_key": "1FSKU3qw",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWy8lWa8",
    "slug": "yuis-module-pattern-vs-prototypes-class",
    "state": "published",
    "summary": "YUI's \"Module Pattern\" vs. Prototype's Class Function",
    "tags": [
        "Code Ecosystems",
        "Javascript"
    ],
    "timestamp": 1187027256,
    "title": "YUI's \"Module Pattern\" vs. Prototype's Class Function",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>Via <a href=\"http://geoffreymoller.com/2007/05/15/when-javascript-libraries-attack/\">Geoffery Moller</a>, I came across <a href=\"http://mattsnider.com/javascript/prototype-vs-yui-round-1-oop-architecture/\">this article</a> on Matt Snider&rsquo;s blog.  I&rsquo;m surprised that no one noticed what (to me) was the most relevant difference in the libraries that he evaluated.</p>\n\n<p>The &ldquo;YUI method of class creation&rdquo; is not distinctively YUI&mdash;it&rsquo;s just what Javascript gives you for free.  You can use the &ldquo;Module Pattern&rdquo; alone on a page with no library at all!  You can call it Crockford&rsquo;s Module Pattern, but it seems to me that he discovered or popularized it more than &ldquo;invented&rdquo; it.</p>\n\n<p>This, to me, highlights the biggest difference in approach between YUI and every other library: YUI doesn&rsquo;t attempt to re-write the language, but rather to show off what the language can do and how those features can be effectively put to use.  My experience with Prototype and Dojo and Mochikit all made me feel a bit like the author must not have liked Javascript very much.  (Dojo actually goes a bit further&mdash;it rewrites HTML as well!)  It seems like the other libraries say, &ldquo;This Javascript language is too hard and confusing.  Let&rsquo;s make it into something else.&rdquo;  YUI says, &ldquo;This language is beautiful and powerful, but it would be handy if we had some conventions and a common approach to these rough edges.  Let&rsquo;s build those common pieces.&rdquo;  It&rsquo;s the difference between teaching someone to fish and giving them a fish, except instead of giving him a fish, you pass the fish through a slow and complex machine that spits out Java code.</p>\n\n<p>Of course, I&rsquo;m a bit biased.  I <a href=\"http://www.codinghorror.com/blog/archives/000921.html\">imprinted upon YUI</a> at a fairly early stage in my Javascript development.  I work <a href=\"http://yahoo.com\">here</a>, so I get to request features directly through our internal bugzilla instead of pleading in the public arenas.  But the approach is one that I&rsquo;ve always favored.  If you feel the need to rewrite the language, then just go use another language.  Javascript is the common tongue of the internet, and will remain so for the indefinite future.  Don&rsquo;t fight it. (<a href=\"http://www.codinghorror.com/blog/archives/000857.html\">Hat-tip</a> to Jeff Atwood.)</p>\n\n<p>Crockford&rsquo;s &ldquo;Module Pattern&rdquo; is a great way to create a singleton that has some private methods.  In fact, in my opinion, it&rsquo;s the best and only way that this task should be done.  (There are others, but they tend to be more obtuse, IMO.)  But that&rsquo;s not the only task of an object-oriented development.  Sometimes, you need to have a bunch of objects, and if they have shared functionality, then that should be handled with a class of sorts.  In Javascript, that means that they&rsquo;re stamped from the same Constructor and Prototype.  The Module Pattern does not address this in a very clear way, but it does highlight the principle of data-hiding through a closure that is the key to OOP in Javascript.</p>\n\n<p>To create a class, I usually do something like this, which takes the essence of the Module Pattern and uses it to create a reusable class.</p>\n\n<p><code>(function () {<br />\n&nbsp;&nbsp;// these are properly private static, not just private\n&nbsp;&nbsp;// but with scope correction, that's good enough for functions.<br />\n&nbsp;&nbsp;// private function, called with privateFunction.call(this, a, b, c);\n&nbsp;&nbsp;var privateFunction = function (a, b) {\n&nbsp;&nbsp;&nbsp;&nbsp;this.a = a;\n&nbsp;&nbsp;&nbsp;&nbsp;this.b = b;\n&nbsp;&nbsp;};<br />\n&nbsp;&nbsp;// private static data.  Shared between all instances!\n&nbsp;&nbsp;var privateStaticData = \"I'm private and static.  All instances share me.\";<br />\n&nbsp;&nbsp;YAHOO.myProject.myClass = function (a, b, id) {\n&nbsp;&nbsp;&nbsp;&nbsp;// a and b are public, since they're set on this.\n&nbsp;&nbsp;&nbsp;&nbsp;this.a = a;\n&nbsp;&nbsp;&nbsp;&nbsp;this.b = b;\n&nbsp;&nbsp;&nbsp;&nbsp;YAHOO.myProject.myClass.instances[id] = this;\n&nbsp;&nbsp;};<br />\n&nbsp;&nbsp;YAHOO.myProject.myClass.instances = {};<br />\n&nbsp;&nbsp;YAHOO.myProject.myClass.prototype = {\n&nbsp;&nbsp;&nbsp;&nbsp;myPublicProperty : \"I'm accessible as <p><a href=\"#\"><img src=\"https://assets.tumblr.com/images/inline_placeholder.png\" width=\"18\" height=\"14\"/></a></p></code></p>\n\n<p>(When in doubt, wrap it in a closure.  <a href=\"http://yuiblog.com/blog/2006/06/01/global-domination/\">Global variables are evil.</a>)</p>\n\n<p>I&rsquo;d rather work with someone who is a bit green with Javascript but can learn, rather than someone who is an expert with Prototype or Dojo.  <em>The more time someone spends building applications with a library like Prototype, the further they get from Javascript, and the more dependent they become on the library.</em>  By contrast, time spent using YUI tends to breed developers who are experts in <em>Javascript</em>, and that skill is far more useful than being an expert in a particular library.</p>",
            "content_raw": "<p>Via <a href=\"http://geoffreymoller.com/2007/05/15/when-javascript-libraries-attack/\">Geoffery Moller</a>, I came across <a href=\"http://mattsnider.com/javascript/prototype-vs-yui-round-1-oop-architecture/\">this article</a> on Matt Snider\u2019s blog.  I\u2019m surprised that no one noticed what (to me) was the most relevant difference in the libraries that he evaluated.</p>\n\n<p>The \u201cYUI method of class creation\u201d is not distinctively YUI\u2014it\u2019s just what Javascript gives you for free.  You can use the \u201cModule Pattern\u201d alone on a page with no library at all!  You can call it Crockford\u2019s Module Pattern, but it seems to me that he discovered or popularized it more than \u201cinvented\u201d it.</p>\n\n<p>This, to me, highlights the biggest difference in approach between YUI and every other library: YUI doesn\u2019t attempt to re-write the language, but rather to show off what the language can do and how those features can be effectively put to use.  My experience with Prototype and Dojo and Mochikit all made me feel a bit like the author must not have liked Javascript very much.  (Dojo actually goes a bit further\u2014it rewrites HTML as well!)  It seems like the other libraries say, \u201cThis Javascript language is too hard and confusing.  Let\u2019s make it into something else.\u201d  YUI says, \u201cThis language is beautiful and powerful, but it would be handy if we had some conventions and a common approach to these rough edges.  Let\u2019s build those common pieces.\u201d  It\u2019s the difference between teaching someone to fish and giving them a fish, except instead of giving him a fish, you pass the fish through a slow and complex machine that spits out Java code.</p>\n\n<p>Of course, I\u2019m a bit biased.  I <a href=\"http://www.codinghorror.com/blog/archives/000921.html\">imprinted upon YUI</a> at a fairly early stage in my Javascript development.  I work <a href=\"http://yahoo.com\">here</a>, so I get to request features directly through our internal bugzilla instead of pleading in the public arenas.  But the approach is one that I\u2019ve always favored.  If you feel the need to rewrite the language, then just go use another language.  Javascript is the common tongue of the internet, and will remain so for the indefinite future.  Don\u2019t fight it. (<a href=\"http://www.codinghorror.com/blog/archives/000857.html\">Hat-tip</a> to Jeff Atwood.)</p>\n\n<p>Crockford\u2019s \u201cModule Pattern\u201d is a great way to create a singleton that has some private methods.  In fact, in my opinion, it\u2019s the best and only way that this task should be done.  (There are others, but they tend to be more obtuse, IMO.)  But that\u2019s not the only task of an object-oriented development.  Sometimes, you need to have a bunch of objects, and if they have shared functionality, then that should be handled with a class of sorts.  In Javascript, that means that they\u2019re stamped from the same Constructor and Prototype.  The Module Pattern does not address this in a very clear way, but it does highlight the principle of data-hiding through a closure that is the key to OOP in Javascript.</p>\n\n<p>To create a class, I usually do something like this, which takes the essence of the Module Pattern and uses it to create a reusable class.</p>\n\n<p><code class=\"block javascript\">(function () {<br>\n\u00a0\u00a0// these are properly private static, not just private\n\u00a0\u00a0// but with scope correction, that's good enough for functions.<br>\n\u00a0\u00a0// private function, called with privateFunction.call(this, a, b, c);\n\u00a0\u00a0var privateFunction = function (a, b) {\n\u00a0\u00a0\u00a0\u00a0this.a = a;\n\u00a0\u00a0\u00a0\u00a0this.b = b;\n\u00a0\u00a0};<br>\n\u00a0\u00a0// private static data.  Shared between all instances!\n\u00a0\u00a0var privateStaticData = \"I'm private and static.  All instances share me.\";<br>\n\u00a0\u00a0YAHOO.myProject.myClass = function (a, b, id) {\n\u00a0\u00a0\u00a0\u00a0// a and b are public, since they're set on this.\n\u00a0\u00a0\u00a0\u00a0this.a = a;\n\u00a0\u00a0\u00a0\u00a0this.b = b;\n\u00a0\u00a0\u00a0\u00a0YAHOO.myProject.myClass.instances[id] = this;\n\u00a0\u00a0};<br>\n\u00a0\u00a0YAHOO.myProject.myClass.instances = {};<br>\n\u00a0\u00a0YAHOO.myProject.myClass.prototype = {\n\u00a0\u00a0\u00a0\u00a0myPublicProperty : \"I'm accessible as <object reference>.myPublicProperty.\",\n\u00a0\u00a0\u00a0\u00a0myPublicMethod : function () {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var a = (new Date()).getTime();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var b = a + 10000;<br>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// note the way that private functions are called.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0privateFunction.call(this, a, b);\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\n\u00a0\u00a0};<br>\n})(); // close the closure and execute the code.<br>\n// later on...\n(function () {\n\u00a0\u00a0var myInstance = new YAHOO.myProject.myClass(1,2,'blahblah');\n\u00a0\u00a0// now you can deal with it as \"myInstance\" within this closure,\n\u00a0\u00a0// or as YAHOO.myProject.myClass.instances.blahblah elsewhere.\n})();</object></code></p>\n\n<p>(When in doubt, wrap it in a closure.  <a href=\"http://yuiblog.com/blog/2006/06/01/global-domination/\">Global variables are evil.</a>)</p>\n\n<p>I\u2019d rather work with someone who is a bit green with Javascript but can learn, rather than someone who is an expert with Prototype or Dojo.  <em>The more time someone spends building applications with a library like Prototype, the further they get from Javascript, and the more dependent they become on the library.</em>  By contrast, time spent using YUI tends to breed developers who are experts in <em>Javascript</em>, and that skill is far more useful than being an expert in a particular library.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "146671880"
            }
        }
    ],
    "type": "text"
}