{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>Having really hot paths in your code can be great, but it can also be a little dangerous.</p>\n\n<p>When v8&rsquo;s Crankshaft landed in the Node.js dev build, it immediately resulted in a significant drop in Node&rsquo;s &ldquo;hello world&rdquo; performance benchmark.</p>\n\n<p>This was alarming.  Crankshaft was supposed to be faster, and here it was causing slowdowns.</p>\n\n<p>The cause was tracked down Vyacheslav Egorov (known to many in the Node community as &ldquo;mraleph&rdquo;), and had to do with Node&rsquo;s use of the <code>arguments</code> object in the <code>EventEmitter.prototype.emit</code> function.</p>\n\n<p>Since this function is the hottest code in Node, even a slight decrease in performance is immediately felt.  Vyacheslav discussed <a href=\"https://github.com/joyent/node/commit/91f1b250ecb4fb8151cd17423dd4460652d0ce97\">the commit</a> in <a href=\"https://plus.google.com/111090511249453178320/posts/ikjTyY6UKcE\">a google plus post</a>.</p>\n\n<p>This got me thinking about the best ways to convert the <code>arguments</code> object, or part of it, to a standard JavaScript <code>Array</code>.  I pulled out <a href=\"https://raw.github.com/isaacs/node-bench\">the node benchmarking thing I wrote</a>, and wrote up <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify.js\">two</a> <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify-offset.js\">tests</a></p>\n\n<h2>Disclaimers</h2>\n\n<p>This advice is only relevant in the latest v8.  By the time you read it, it&rsquo;s already out of date and incorrect.  Just stop now, run your own tests, and make your own choices.</p>\n\n<p>If node.js is still using v8 version 3.4.12.1, then it <em>might</em> be just a <em>little</em> valid for your node programs, but otherwise, no.  Stop.  Don&rsquo;t even continue reading.</p>\n\n<h2>Results</h2>\n\n<p>First, if your function takes a variable number of arguments, and you don&rsquo;t know how many it will be called with <strong>do not define any named parameters</strong>.  It makes things more complicated, and dramatically slows down the process.</p>\n\n<p>Want to just put all the <code>arguments</code> in an array?  Do this:</p>\n\n<pre><code>function varArgsList () {\n  var args = arguments.length === 1\n           ? [arguments[0]] : Array.apply(null, arguments)\n</code></pre>\n\n<p>It&rsquo;s an order of magnitude faster than <code>Array.prototype.slice.call</code> or <code>[].slice.call</code>.</p>\n\n<p>Want to get all the arguments in a particular slice?  (Like, say, everything after the first, or the second until the second-to-last, etc.)  Well, that&rsquo;s a bit more complicated.  There, as with the patch from Mr. Aleph, you&rsquo;ve gotta walk the list yourself.</p>\n\n<p>For example, to do the equivalent of <code>Array.prototype.slice.call(arguments, 1)</code>, pulling off every argument after the first, the fastest method seems to be this:</p>\n\n<pre><code>function manualMap () {\n  var l = arguments.length\n  var arr = new Array(l - 1)\n  for (var i = 1; i &lt; l; i ++) arr[i - 1] = arguments[i]\n</code></pre>\n\n<p>The fastest, if you know exactly which arguments are which, is to refer to them as <code>arguments[i]</code>, and only array-ify if and when it&rsquo;s absolutely necessary.  So, not surprisingly, I was unable to out-perform Mr. Aleph in a v8 benchmark-off.  My goal in this was simply to figure out <em>how much</em> of a difference it makes, and write a script to check it later, in case I find myself in a similar situation again.</p>\n\n<p>Of course, <code>[].slice.call(arguments, 1, 2)</code> is far fewer bytes, and easier to know what&rsquo;s going on.  For most programs, the slight difference is not going to affect your overall program.  But sometimes hot code is hot enough to slow your benchmarks down by 20% because of what seems like a trivial change.</p>\n\n<p>It&rsquo;s only over-optimizing if it doesn&rsquo;t make a significant difference.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2011-07-18 02:29:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 7746314700,
    "is_blocks_post_format": false,
    "note_count": 17,
    "post_url": "http://blog.izs.me/post/7746314700/benchmark-array-ification-of-arguments",
    "reblog": {
        "comment": "<p>Having really hot paths in your code can be great, but it can also be a little dangerous.</p>\n\n<p>When v8\u2019s Crankshaft landed in the Node.js dev build, it immediately resulted in a significant drop in Node\u2019s \u201chello world\u201d performance benchmark.</p>\n\n<p>This was alarming.  Crankshaft was supposed to be faster, and here it was causing slowdowns.</p>\n\n<p>The cause was tracked down Vyacheslav Egorov (known to many in the Node community as \u201cmraleph\u201d), and had to do with Node\u2019s use of the <code>arguments</code> object in the <code>EventEmitter.prototype.emit</code> function.</p>\n\n<p>Since this function is the hottest code in Node, even a slight decrease in performance is immediately felt.  Vyacheslav discussed <a href=\"https://github.com/joyent/node/commit/91f1b250ecb4fb8151cd17423dd4460652d0ce97\">the commit</a> in <a href=\"https://plus.google.com/111090511249453178320/posts/ikjTyY6UKcE\">a google plus post</a>.</p>\n\n<p>This got me thinking about the best ways to convert the <code>arguments</code> object, or part of it, to a standard JavaScript <code>Array</code>.  I pulled out <a href=\"https://raw.github.com/isaacs/node-bench\">the node benchmarking thing I wrote</a>, and wrote up <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify.js\">two</a> <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify-offset.js\">tests</a></p>\n\n<h2>Disclaimers</h2>\n\n<p>This advice is only relevant in the latest v8.  By the time you read it, it\u2019s already out of date and incorrect.  Just stop now, run your own tests, and make your own choices.</p>\n\n<p>If node.js is still using v8 version 3.4.12.1, then it <em>might</em> be just a <em>little</em> valid for your node programs, but otherwise, no.  Stop.  Don\u2019t even continue reading.</p>\n\n<h2>Results</h2>\n\n<p>First, if your function takes a variable number of arguments, and you don\u2019t know how many it will be called with <strong>do not define any named parameters</strong>.  It makes things more complicated, and dramatically slows down the process.</p>\n\n<p>Want to just put all the <code>arguments</code> in an array?  Do this:</p>\n\n<pre><code>function varArgsList () {\n  var args = arguments.length === 1\n           ? [arguments[0]] : Array.apply(null, arguments)\n</code></pre>\n\n<p>It\u2019s an order of magnitude faster than <code>Array.prototype.slice.call</code> or <code>[].slice.call</code>.</p>\n\n<p>Want to get all the arguments in a particular slice?  (Like, say, everything after the first, or the second until the second-to-last, etc.)  Well, that\u2019s a bit more complicated.  There, as with the patch from Mr. Aleph, you\u2019ve gotta walk the list yourself.</p>\n\n<p>For example, to do the equivalent of <code>Array.prototype.slice.call(arguments, 1)</code>, pulling off every argument after the first, the fastest method seems to be this:</p>\n\n<pre><code>function manualMap () {\n  var l = arguments.length\n  var arr = new Array(l - 1)\n  for (var i = 1; i &lt; l; i ++) arr[i - 1] = arguments[i]\n</code></pre>\n\n<p>The fastest, if you know exactly which arguments are which, is to refer to them as <code>arguments[i]</code>, and only array-ify if and when it\u2019s absolutely necessary.  So, not surprisingly, I was unable to out-perform Mr. Aleph in a v8 benchmark-off.  My goal in this was simply to figure out <em>how much</em> of a difference it makes, and write a script to check it later, in case I find myself in a similar situation again.</p>\n\n<p>Of course, <code>[].slice.call(arguments, 1, 2)</code> is far fewer bytes, and easier to know what\u2019s going on.  For most programs, the slight difference is not going to affect your overall program.  But sometimes hot code is hot enough to slow your benchmarks down by 20% because of what seems like a trivial change.</p>\n\n<p>It\u2019s only over-optimizing if it doesn\u2019t make a significant difference.</p>",
        "tree_html": ""
    },
    "reblog_key": "UmTJnw7F",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWy7Djs7C",
    "slug": "benchmark-array-ification-of-arguments",
    "state": "published",
    "summary": "Benchmark: Array-ification of arguments",
    "tags": [],
    "timestamp": 1310956140,
    "title": "Benchmark: Array-ification of arguments",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>Having really hot paths in your code can be great, but it can also be a little dangerous.</p>\n\n<p>When v8&rsquo;s Crankshaft landed in the Node.js dev build, it immediately resulted in a significant drop in Node&rsquo;s &ldquo;hello world&rdquo; performance benchmark.</p>\n\n<p>This was alarming.  Crankshaft was supposed to be faster, and here it was causing slowdowns.</p>\n\n<p>The cause was tracked down Vyacheslav Egorov (known to many in the Node community as &ldquo;mraleph&rdquo;), and had to do with Node&rsquo;s use of the <code>arguments</code> object in the <code>EventEmitter.prototype.emit</code> function.</p>\n\n<p>Since this function is the hottest code in Node, even a slight decrease in performance is immediately felt.  Vyacheslav discussed <a href=\"https://github.com/joyent/node/commit/91f1b250ecb4fb8151cd17423dd4460652d0ce97\">the commit</a> in <a href=\"https://plus.google.com/111090511249453178320/posts/ikjTyY6UKcE\">a google plus post</a>.</p>\n\n<p>This got me thinking about the best ways to convert the <code>arguments</code> object, or part of it, to a standard JavaScript <code>Array</code>.  I pulled out <a href=\"https://raw.github.com/isaacs/node-bench\">the node benchmarking thing I wrote</a>, and wrote up <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify.js\">two</a> <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify-offset.js\">tests</a></p>\n\n<h2>Disclaimers</h2>\n\n<p>This advice is only relevant in the latest v8.  By the time you read it, it&rsquo;s already out of date and incorrect.  Just stop now, run your own tests, and make your own choices.</p>\n\n<p>If node.js is still using v8 version 3.4.12.1, then it <em>might</em> be just a <em>little</em> valid for your node programs, but otherwise, no.  Stop.  Don&rsquo;t even continue reading.</p>\n\n<h2>Results</h2>\n\n<p>First, if your function takes a variable number of arguments, and you don&rsquo;t know how many it will be called with <strong>do not define any named parameters</strong>.  It makes things more complicated, and dramatically slows down the process.</p>\n\n<p>Want to just put all the <code>arguments</code> in an array?  Do this:</p>\n\n<pre><code>function varArgsList () {\n  var args = arguments.length === 1\n           ? [arguments[0]] : Array.apply(null, arguments)\n</code></pre>\n\n<p>It&rsquo;s an order of magnitude faster than <code>Array.prototype.slice.call</code> or <code>[].slice.call</code>.</p>\n\n<p>Want to get all the arguments in a particular slice?  (Like, say, everything after the first, or the second until the second-to-last, etc.)  Well, that&rsquo;s a bit more complicated.  There, as with the patch from Mr. Aleph, you&rsquo;ve gotta walk the list yourself.</p>\n\n<p>For example, to do the equivalent of <code>Array.prototype.slice.call(arguments, 1)</code>, pulling off every argument after the first, the fastest method seems to be this:</p>\n\n<pre><code>function manualMap () {\n  var l = arguments.length\n  var arr = new Array(l - 1)\n  for (var i = 1; i &lt; l; i ++) arr[i - 1] = arguments[i]\n</code></pre>\n\n<p>The fastest, if you know exactly which arguments are which, is to refer to them as <code>arguments[i]</code>, and only array-ify if and when it&rsquo;s absolutely necessary.  So, not surprisingly, I was unable to out-perform Mr. Aleph in a v8 benchmark-off.  My goal in this was simply to figure out <em>how much</em> of a difference it makes, and write a script to check it later, in case I find myself in a similar situation again.</p>\n\n<p>Of course, <code>[].slice.call(arguments, 1, 2)</code> is far fewer bytes, and easier to know what&rsquo;s going on.  For most programs, the slight difference is not going to affect your overall program.  But sometimes hot code is hot enough to slow your benchmarks down by 20% because of what seems like a trivial change.</p>\n\n<p>It&rsquo;s only over-optimizing if it doesn&rsquo;t make a significant difference.</p>",
            "content_raw": "<p>Having really hot paths in your code can be great, but it can also be a little dangerous.</p>\n\n<p>When v8\u2019s Crankshaft landed in the Node.js dev build, it immediately resulted in a significant drop in Node\u2019s \u201chello world\u201d performance benchmark.</p>\n\n<p>This was alarming.  Crankshaft was supposed to be faster, and here it was causing slowdowns.</p>\n\n<p>The cause was tracked down Vyacheslav Egorov (known to many in the Node community as \u201cmraleph\u201d), and had to do with Node\u2019s use of the <code>arguments</code> object in the <code>EventEmitter.prototype.emit</code> function.</p>\n\n<p>Since this function is the hottest code in Node, even a slight decrease in performance is immediately felt.  Vyacheslav discussed <a href=\"https://github.com/joyent/node/commit/91f1b250ecb4fb8151cd17423dd4460652d0ce97\">the commit</a> in <a href=\"https://plus.google.com/111090511249453178320/posts/ikjTyY6UKcE\">a google plus post</a>.</p>\n\n<p>This got me thinking about the best ways to convert the <code>arguments</code> object, or part of it, to a standard JavaScript <code>Array</code>.  I pulled out <a href=\"https://raw.github.com/isaacs/node-bench\">the node benchmarking thing I wrote</a>, and wrote up <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify.js\">two</a> <a href=\"https://raw.github.com/isaacs/node-bench/master/examples/array-ify-offset.js\">tests</a></p>\n\n<h2>Disclaimers</h2>\n\n<p>This advice is only relevant in the latest v8.  By the time you read it, it\u2019s already out of date and incorrect.  Just stop now, run your own tests, and make your own choices.</p>\n\n<p>If node.js is still using v8 version 3.4.12.1, then it <em>might</em> be just a <em>little</em> valid for your node programs, but otherwise, no.  Stop.  Don\u2019t even continue reading.</p>\n\n<h2>Results</h2>\n\n<p>First, if your function takes a variable number of arguments, and you don\u2019t know how many it will be called with <strong>do not define any named parameters</strong>.  It makes things more complicated, and dramatically slows down the process.</p>\n\n<p>Want to just put all the <code>arguments</code> in an array?  Do this:</p>\n\n<pre><code>function varArgsList () {\n  var args = arguments.length === 1\n           ? [arguments[0]] : Array.apply(null, arguments)\n</code></pre>\n\n<p>It\u2019s an order of magnitude faster than <code>Array.prototype.slice.call</code> or <code>[].slice.call</code>.</p>\n\n<p>Want to get all the arguments in a particular slice?  (Like, say, everything after the first, or the second until the second-to-last, etc.)  Well, that\u2019s a bit more complicated.  There, as with the patch from Mr. Aleph, you\u2019ve gotta walk the list yourself.</p>\n\n<p>For example, to do the equivalent of <code>Array.prototype.slice.call(arguments, 1)</code>, pulling off every argument after the first, the fastest method seems to be this:</p>\n\n<pre><code>function manualMap () {\n  var l = arguments.length\n  var arr = new Array(l - 1)\n  for (var i = 1; i &lt; l; i ++) arr[i - 1] = arguments[i]\n</code></pre>\n\n<p>The fastest, if you know exactly which arguments are which, is to refer to them as <code>arguments[i]</code>, and only array-ify if and when it\u2019s absolutely necessary.  So, not surprisingly, I was unable to out-perform Mr. Aleph in a v8 benchmark-off.  My goal in this was simply to figure out <em>how much</em> of a difference it makes, and write a script to check it later, in case I find myself in a similar situation again.</p>\n\n<p>Of course, <code>[].slice.call(arguments, 1, 2)</code> is far fewer bytes, and easier to know what\u2019s going on.  For most programs, the slight difference is not going to affect your overall program.  But sometimes hot code is hot enough to slow your benchmarks down by 20% because of what seems like a trivial change.</p>\n\n<p>It\u2019s only over-optimizing if it doesn\u2019t make a significant difference.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "7746314700"
            }
        }
    ],
    "type": "text"
}