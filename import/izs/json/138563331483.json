{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>A few times on Twitter, I&rsquo;ve\n<a href=\"https://twitter.com/izs/status/694321665430261760\">complained</a> that\nPromises are a poor conceptual stand-in for Eventual Values.</p>\n\n<p>A colleague of mine pointed out that I tweet this or something like it\nevery few months.  He&rsquo;s correct, I do.</p>\n\n<p>The responses usually flow in saying something to the effect of &ldquo;Well,\nif you&rsquo;re not sure if a thing is a Promise or not, just use\n<code>Promise.resolve(thing)</code> and now you&rsquo;re guaranteed to get either the\nPromise, or a Promise that resolves to the thing.&rdquo;</p>\n\n<p>And it&rsquo;s true, that is &ldquo;a&rdquo; solution of sorts.  It solves the &ldquo;I don&rsquo;t\nknow if this is a Promise or not&rdquo; problem by ensuring that you\ndefinitely do have a Promise, and not a normal value.</p>\n\n<p>My problem, though, is that I&rsquo;d really like to write code that\ninteracts with values, and not Promises, and leave the machinery to\nthe computer to work out.</p>\n\n<h2 id=\"eventual-values\">Eventual Values</h2>\n\n<p>An Eventual Value is a value that is not yet resolved.  However, by\ndesign, it is mostly indistinguishable from a &ldquo;normal&rdquo; value.  Here&rsquo;s\nan example:</p>\n\n<pre><code class=\"lang-javascript\">// promise code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction add5Promise (x) {\n  return Promise.resolve(x).then(function (x) {\n    return add5(x)\n  })\n}\n\nfunction someNumberLater () {\n  return new Promise(function (resolve) {\n    databaseConnector.get('numeric value').then(function (x) {\n      resolve(x)\n    })\n  })\n}\n\nadd5Promise(someNumberLater()).then(function (xplus5) {\n  console.log('the number plus 5 is %d', xplus5)\n})\n</code></pre>\n\n<p>With Eventual Values, this would look like the following:</p>\n\n<pre><code class=\"lang-javascript\">// eventual value code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction someNumberLater () {\n  databaseConnector.get('numeric value'))\n}\n\nconsole.log('the number plus 5 is %d', add5(someNumberLater()))\n</code></pre>\n\n<p>If you imagine getting a few numbers, any of which might be as yet\nunresolved, it&rsquo;s even more annoying:</p>\n\n<pre><code class=\"lang-javascript\">// promise code\nfunction addThreeNumbers (x, y, z) {\n  return Promise.all([x, y, z]).then(function (numbers) {\n    return Promise.resolve(numbers[0] + numbers[1] + numbers[3])\n  })\n}\n\n// eventual code\nfunction addThreeNumbers (x, y, z) {\n  return x + y + z\n}\n</code></pre>\n\n<h3 id=\"criteria\">Criteria</h3>\n\n<ul><li>Eventual Values can be interacted with like normal values.</li>\n<li>If an Eventual Value is part of a simple value operation, then that\nexpression resolves to a new Eventual Value which resolves when all\nits Eventual Values are resolved.</li>\n</ul><p>That&rsquo;s it.  You interact with Eventual Values as if they&rsquo;re normal\nsynchronous values, and the machine takes care of waiting where it&rsquo;s\nnecessary and appropriate.</p>\n\n<h2 id=\"but-zalgo-\">But Zalgo!</h2>\n\n<p>Indeed, this is\n<a href=\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\">Zalgo</a>&rsquo;s\npurest form.  But let&rsquo;s clarify exactly what&rsquo;s wrong with the\nmaybe-sync anti-pattern.</p>\n\n<p>The problem with Zalgo APIs is that they&rsquo;re hard to reason about.\nGiven code like this:</p>\n\n<pre><code class=\"lang-javascript\">someApi(function () {\n  console.log('foo')\n})\nconsole.log('bar')\n</code></pre>\n\n<p>In a sync callback API, you know that this will always print out\n<code>foo\\nbar</code>.  In an async callback API, you know that this will always\nprint out <code>bar\\nfoo</code>.  This predictability is important for human\nbrains.</p>\n\n<p>This is why the built-in dezalgo of Promises A+ is so important.</p>\n\n<pre><code class=\"lang-javascript\">new Promise(function (resolve) {\n  console.log('foo')\n  resolve()\n})\nconsole.log('bar')\n</code></pre>\n\n<p>This code must either (a) always print <code>foo\\nbar</code>, or (b) always print\n<code>bar\\nfoo</code>.  Since Promise resolution <em>can</em> be async, it <em>must</em> be\nasync all the time, or else this predictability constraint is\nviolated.</p>\n\n<p>With Eventual Values, Zalgo is not a problem, because whether things\nhappen synchronously or asynchronously, they always happen in the same\npredictable order.</p>\n\n<pre><code class=\"lang-javascript\">function getFoo () {\n  return new Eventual(function (resolve) {\n    setTimeout(function () {\n      resolve('foo')\n    })\n  })\n}\n\nfunction getBar () {\n  return new Eventual(function (resolve) { resolve('foo') })\n}\n\nconsole.log(getFoo())\nconsole.log(getBar())\n</code></pre>\n\n<p>In this case, it will always print <code>foo\\nbar</code>, even though <code>foo</code> is\nresolved later, and <code>bar</code> is resolved immediately.  Eventual Values\nbehave like synchronous values.</p>\n\n<h2 id=\"introspection-operators-etc-\">Introspection, Operators, Etc.</h2>\n\n<p>It&rsquo;d be nice to have some magic <code>isEventual</code> operator that could tell\nyou if a thing was already resolved or not.</p>\n\n<p>Or even a <code>wasEventual</code> operator to tell you whether this thing you\nhave was ever waited upon.</p>\n\n<p>But mostly, while it&rsquo;s great to be able to introspect programs, it&rsquo;s\neven better not to have to <em>need</em> to introspect programs.  We don&rsquo;t\nhave memory address introspection in JavaScript, and no one seems to\nmind.  Inspecting Eventual Values should be akin to peering into the\ndark machinery of the VM; something that&rsquo;s useful once in a while, and\ncertainly interesting from an academic point of view, but not in the\nnormal day to day activities of the typical JavaScript programmer.</p>\n\n<p>Language design is hard.  It may be that there&rsquo;s some really good\nreason for at least having a special operator or something to say\n&ldquo;Yes, I would like any Eventual Values to be resolved before calling\nthis function.&rdquo;  Maybe use <code>functionE</code> instead of <code>function</code>, I don&rsquo;t\nknow.  I don&rsquo;t care.  I just want to stop having to stick my nose in\nthe machinery.  Ideally, we&rsquo;d almost never have to care, because it\nonly matters at the very edges of a program, when data is sent to the\nDOM, or written to a file or socket or terminal.</p>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>This cannot be implemented in userland, nor should they be.  Eventual\nValues are a language feature.  Promises are an API, and easy to\nimplement in userland.</p>\n\n<p>Promises will never grow into Eventuals, because they are\nfundamentally different things, even though they implement a similar\npattern.</p>\n\n<h2 id=\"looking-async\">Looking Async</h2>\n\n<p>I&rsquo;ve argued in the past, quite forcefully, that synchronous code\nshould look synchronous, and async code should look async.  But again,\nlike Zalgo, let&rsquo;s not conflate &ldquo;a good rule of thumb for API design&rdquo;\nwith &ldquo;a language feature that would make our lives better&rdquo;.</p>\n\n<p>If you dig one layer deeper, you find that the only reason\nasynchronous code needs to look asynchronous is that we continually\nrely upon our human brains to deal with the timing and synchronicity\nof our programs.</p>\n\n<p>In cases where we are relying on a meat brain to analyze a program, it\nis extremely important for it to look like what it is.  There will\nlikely always be some API surfaces that are asynchronous, and even in\na world with Eventual Values, there is a place for APIs that are\ncreatively asynchronous, and they should look and behave like what\nthey are.</p>\n\n<h2 id=\"anti-promises\">Anti-Promises</h2>\n\n<p>Promises are neat.  They&rsquo;re a terse and expressive way to chain\ntogether a series of potentially asynchronous actions in a way that&rsquo;s\nrelatively easy for a meat brain to make sense of.</p>\n\n<p>Also, it&rsquo;s quite nice how they invert control differently than\ncallbacks.  With a callback, the caller creates and passes a token to\nthe API, with the contract that the API provider will use that token\nto indicate done-ness.  With Promises, the API provider creates and\npasses a token to the caller, with the contract that the API provider\nwill use that token to indicate done-ness.</p>\n\n<p>It&rsquo;s a subtle difference, but one that many people find easier to\nreason about.  That&rsquo;s fine.</p>\n\n<p>However, if you have a function that takes a list of arguments, any of\nwhich may potentially be promises, and then needs to only act once all\nof those promises are resolved, it gets tedious quite fast.  Promises\ntend to expose quite a lot of boilerplate to the user in these types\nof situations.  And, since the only straightforward solution is to\neither turn all things into Promises, or manually check each for\nPromise-ness, one potentially ends up introducing a lot of\n<code>nextTick()</code> delays unnecessarily.</p>\n\n<p>I don&rsquo;t dislike Promises.  But I do long for Eventual Values, and\nPromises are not those.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2016-02-02 21:26:01 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 138563331483,
    "is_blocks_post_format": false,
    "note_count": 9,
    "post_url": "http://blog.izs.me/post/138563331483/promises-vs-eventual-values",
    "reblog": {
        "comment": "<p>A few times on Twitter, I\u2019ve\n<a href=\"https://twitter.com/izs/status/694321665430261760\">complained</a> that\nPromises are a poor conceptual stand-in for Eventual Values.</p>\n\n<p>A colleague of mine pointed out that I tweet this or something like it\nevery few months.  He\u2019s correct, I do.</p>\n\n<p>The responses usually flow in saying something to the effect of \u201cWell,\nif you\u2019re not sure if a thing is a Promise or not, just use\n<code>Promise.resolve(thing)</code> and now you\u2019re guaranteed to get either the\nPromise, or a Promise that resolves to the thing.\u201d</p>\n\n<p>And it\u2019s true, that is \u201ca\u201d solution of sorts.  It solves the \u201cI don\u2019t\nknow if this is a Promise or not\u201d problem by ensuring that you\ndefinitely do have a Promise, and not a normal value.</p>\n\n<p>My problem, though, is that I\u2019d really like to write code that\ninteracts with values, and not Promises, and leave the machinery to\nthe computer to work out.</p>\n\n<h2 id=\"eventual-values\">Eventual Values</h2>\n\n<p>An Eventual Value is a value that is not yet resolved.  However, by\ndesign, it is mostly indistinguishable from a \u201cnormal\u201d value.  Here\u2019s\nan example:</p>\n\n<pre><code class=\"lang-javascript\">// promise code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction add5Promise (x) {\n  return Promise.resolve(x).then(function (x) {\n    return add5(x)\n  })\n}\n\nfunction someNumberLater () {\n  return new Promise(function (resolve) {\n    databaseConnector.get('numeric value').then(function (x) {\n      resolve(x)\n    })\n  })\n}\n\nadd5Promise(someNumberLater()).then(function (xplus5) {\n  console.log('the number plus 5 is %d', xplus5)\n})\n</code></pre>\n\n<p>With Eventual Values, this would look like the following:</p>\n\n<pre><code class=\"lang-javascript\">// eventual value code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction someNumberLater () {\n  databaseConnector.get('numeric value'))\n}\n\nconsole.log('the number plus 5 is %d', add5(someNumberLater()))\n</code></pre>\n\n<p>If you imagine getting a few numbers, any of which might be as yet\nunresolved, it\u2019s even more annoying:</p>\n\n<pre><code class=\"lang-javascript\">// promise code\nfunction addThreeNumbers (x, y, z) {\n  return Promise.all([x, y, z]).then(function (numbers) {\n    return Promise.resolve(numbers[0] + numbers[1] + numbers[3])\n  })\n}\n\n// eventual code\nfunction addThreeNumbers (x, y, z) {\n  return x + y + z\n}\n</code></pre>\n\n<h3 id=\"criteria\">Criteria</h3>\n\n<ul><li>Eventual Values can be interacted with like normal values.</li>\n<li>If an Eventual Value is part of a simple value operation, then that\nexpression resolves to a new Eventual Value which resolves when all\nits Eventual Values are resolved.</li>\n</ul><p>That\u2019s it.  You interact with Eventual Values as if they\u2019re normal\nsynchronous values, and the machine takes care of waiting where it\u2019s\nnecessary and appropriate.</p>\n\n<h2 id=\"but-zalgo-\">But Zalgo!</h2>\n\n<p>Indeed, this is\n<a href=\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\">Zalgo</a>\u2019s\npurest form.  But let\u2019s clarify exactly what\u2019s wrong with the\nmaybe-sync anti-pattern.</p>\n\n<p>The problem with Zalgo APIs is that they\u2019re hard to reason about.\nGiven code like this:</p>\n\n<pre><code class=\"lang-javascript\">someApi(function () {\n  console.log('foo')\n})\nconsole.log('bar')\n</code></pre>\n\n<p>In a sync callback API, you know that this will always print out\n<code>foo\\nbar</code>.  In an async callback API, you know that this will always\nprint out <code>bar\\nfoo</code>.  This predictability is important for human\nbrains.</p>\n\n<p>This is why the built-in dezalgo of Promises A+ is so important.</p>\n\n<pre><code class=\"lang-javascript\">new Promise(function (resolve) {\n  console.log('foo')\n  resolve()\n})\nconsole.log('bar')\n</code></pre>\n\n<p>This code must either (a) always print <code>foo\\nbar</code>, or (b) always print\n<code>bar\\nfoo</code>.  Since Promise resolution <em>can</em> be async, it <em>must</em> be\nasync all the time, or else this predictability constraint is\nviolated.</p>\n\n<p>With Eventual Values, Zalgo is not a problem, because whether things\nhappen synchronously or asynchronously, they always happen in the same\npredictable order.</p>\n\n<pre><code class=\"lang-javascript\">function getFoo () {\n  return new Eventual(function (resolve) {\n    setTimeout(function () {\n      resolve('foo')\n    })\n  })\n}\n\nfunction getBar () {\n  return new Eventual(function (resolve) { resolve('foo') })\n}\n\nconsole.log(getFoo())\nconsole.log(getBar())\n</code></pre>\n\n<p>In this case, it will always print <code>foo\\nbar</code>, even though <code>foo</code> is\nresolved later, and <code>bar</code> is resolved immediately.  Eventual Values\nbehave like synchronous values.</p>\n\n<h2 id=\"introspection-operators-etc-\">Introspection, Operators, Etc.</h2>\n\n<p>It\u2019d be nice to have some magic <code>isEventual</code> operator that could tell\nyou if a thing was already resolved or not.</p>\n\n<p>Or even a <code>wasEventual</code> operator to tell you whether this thing you\nhave was ever waited upon.</p>\n\n<p>But mostly, while it\u2019s great to be able to introspect programs, it\u2019s\neven better not to have to <em>need</em> to introspect programs.  We don\u2019t\nhave memory address introspection in JavaScript, and no one seems to\nmind.  Inspecting Eventual Values should be akin to peering into the\ndark machinery of the VM; something that\u2019s useful once in a while, and\ncertainly interesting from an academic point of view, but not in the\nnormal day to day activities of the typical JavaScript programmer.</p>\n\n<p>Language design is hard.  It may be that there\u2019s some really good\nreason for at least having a special operator or something to say\n\u201cYes, I would like any Eventual Values to be resolved before calling\nthis function.\u201d  Maybe use <code>functionE</code> instead of <code>function</code>, I don\u2019t\nknow.  I don\u2019t care.  I just want to stop having to stick my nose in\nthe machinery.  Ideally, we\u2019d almost never have to care, because it\nonly matters at the very edges of a program, when data is sent to the\nDOM, or written to a file or socket or terminal.</p>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>This cannot be implemented in userland, nor should they be.  Eventual\nValues are a language feature.  Promises are an API, and easy to\nimplement in userland.</p>\n\n<p>Promises will never grow into Eventuals, because they are\nfundamentally different things, even though they implement a similar\npattern.</p>\n\n<h2 id=\"looking-async\">Looking Async</h2>\n\n<p>I\u2019ve argued in the past, quite forcefully, that synchronous code\nshould look synchronous, and async code should look async.  But again,\nlike Zalgo, let\u2019s not conflate \u201ca good rule of thumb for API design\u201d\nwith \u201ca language feature that would make our lives better\u201d.</p>\n\n<p>If you dig one layer deeper, you find that the only reason\nasynchronous code needs to look asynchronous is that we continually\nrely upon our human brains to deal with the timing and synchronicity\nof our programs.</p>\n\n<p>In cases where we are relying on a meat brain to analyze a program, it\nis extremely important for it to look like what it is.  There will\nlikely always be some API surfaces that are asynchronous, and even in\na world with Eventual Values, there is a place for APIs that are\ncreatively asynchronous, and they should look and behave like what\nthey are.</p>\n\n<h2 id=\"anti-promises\">Anti-Promises</h2>\n\n<p>Promises are neat.  They\u2019re a terse and expressive way to chain\ntogether a series of potentially asynchronous actions in a way that\u2019s\nrelatively easy for a meat brain to make sense of.</p>\n\n<p>Also, it\u2019s quite nice how they invert control differently than\ncallbacks.  With a callback, the caller creates and passes a token to\nthe API, with the contract that the API provider will use that token\nto indicate done-ness.  With Promises, the API provider creates and\npasses a token to the caller, with the contract that the API provider\nwill use that token to indicate done-ness.</p>\n\n<p>It\u2019s a subtle difference, but one that many people find easier to\nreason about.  That\u2019s fine.</p>\n\n<p>However, if you have a function that takes a list of arguments, any of\nwhich may potentially be promises, and then needs to only act once all\nof those promises are resolved, it gets tedious quite fast.  Promises\ntend to expose quite a lot of boilerplate to the user in these types\nof situations.  And, since the only straightforward solution is to\neither turn all things into Promises, or manually check each for\nPromise-ness, one potentially ends up introducing a lot of\n<code>nextTick()</code> delays unnecessarily.</p>\n\n<p>I don\u2019t dislike Promises.  But I do long for Eventual Values, and\nPromises are not those.</p>",
        "tree_html": ""
    },
    "reblog_key": "sz6wcSHw",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWy2131AMR",
    "slug": "promises-vs-eventual-values",
    "state": "published",
    "summary": "Promises vs Eventual Values",
    "tags": [],
    "timestamp": 1454448361,
    "title": "Promises vs Eventual Values",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>A few times on Twitter, I&rsquo;ve\n<a href=\"https://twitter.com/izs/status/694321665430261760\">complained</a> that\nPromises are a poor conceptual stand-in for Eventual Values.</p>\n\n<p>A colleague of mine pointed out that I tweet this or something like it\nevery few months.  He&rsquo;s correct, I do.</p>\n\n<p>The responses usually flow in saying something to the effect of &ldquo;Well,\nif you&rsquo;re not sure if a thing is a Promise or not, just use\n<code>Promise.resolve(thing)</code> and now you&rsquo;re guaranteed to get either the\nPromise, or a Promise that resolves to the thing.&rdquo;</p>\n\n<p>And it&rsquo;s true, that is &ldquo;a&rdquo; solution of sorts.  It solves the &ldquo;I don&rsquo;t\nknow if this is a Promise or not&rdquo; problem by ensuring that you\ndefinitely do have a Promise, and not a normal value.</p>\n\n<p>My problem, though, is that I&rsquo;d really like to write code that\ninteracts with values, and not Promises, and leave the machinery to\nthe computer to work out.</p>\n\n<h2>Eventual Values</h2>\n\n<p>An Eventual Value is a value that is not yet resolved.  However, by\ndesign, it is mostly indistinguishable from a &ldquo;normal&rdquo; value.  Here&rsquo;s\nan example:</p>\n\n<pre><code>// promise code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction add5Promise (x) {\n  return Promise.resolve(x).then(function (x) {\n    return add5(x)\n  })\n}\n\nfunction someNumberLater () {\n  return new Promise(function (resolve) {\n    databaseConnector.get('numeric value').then(function (x) {\n      resolve(x)\n    })\n  })\n}\n\nadd5Promise(someNumberLater()).then(function (xplus5) {\n  console.log('the number plus 5 is %d', xplus5)\n})\n</code></pre>\n\n<p>With Eventual Values, this would look like the following:</p>\n\n<pre><code>// eventual value code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction someNumberLater () {\n  databaseConnector.get('numeric value'))\n}\n\nconsole.log('the number plus 5 is %d', add5(someNumberLater()))\n</code></pre>\n\n<p>If you imagine getting a few numbers, any of which might be as yet\nunresolved, it&rsquo;s even more annoying:</p>\n\n<pre><code>// promise code\nfunction addThreeNumbers (x, y, z) {\n  return Promise.all([x, y, z]).then(function (numbers) {\n    return Promise.resolve(numbers[0] + numbers[1] + numbers[3])\n  })\n}\n\n// eventual code\nfunction addThreeNumbers (x, y, z) {\n  return x + y + z\n}\n</code></pre>\n\n<h3>Criteria</h3>\n\n<ul><li>Eventual Values can be interacted with like normal values.</li>\n<li>If an Eventual Value is part of a simple value operation, then that\nexpression resolves to a new Eventual Value which resolves when all\nits Eventual Values are resolved.</li>\n</ul><p>That&rsquo;s it.  You interact with Eventual Values as if they&rsquo;re normal\nsynchronous values, and the machine takes care of waiting where it&rsquo;s\nnecessary and appropriate.</p>\n\n<h2>But Zalgo!</h2>\n\n<p>Indeed, this is\n<a href=\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\">Zalgo</a>&rsquo;s\npurest form.  But let&rsquo;s clarify exactly what&rsquo;s wrong with the\nmaybe-sync anti-pattern.</p>\n\n<p>The problem with Zalgo APIs is that they&rsquo;re hard to reason about.\nGiven code like this:</p>\n\n<pre><code>someApi(function () {\n  console.log('foo')\n})\nconsole.log('bar')\n</code></pre>\n\n<p>In a sync callback API, you know that this will always print out\n<code>foo\\nbar</code>.  In an async callback API, you know that this will always\nprint out <code>bar\\nfoo</code>.  This predictability is important for human\nbrains.</p>\n\n<p>This is why the built-in dezalgo of Promises A+ is so important.</p>\n\n<pre><code>new Promise(function (resolve) {\n  console.log('foo')\n  resolve()\n})\nconsole.log('bar')\n</code></pre>\n\n<p>This code must either (a) always print <code>foo\\nbar</code>, or (b) always print\n<code>bar\\nfoo</code>.  Since Promise resolution <em>can</em> be async, it <em>must</em> be\nasync all the time, or else this predictability constraint is\nviolated.</p>\n\n<p>With Eventual Values, Zalgo is not a problem, because whether things\nhappen synchronously or asynchronously, they always happen in the same\npredictable order.</p>\n\n<pre><code>function getFoo () {\n  return new Eventual(function (resolve) {\n    setTimeout(function () {\n      resolve('foo')\n    })\n  })\n}\n\nfunction getBar () {\n  return new Eventual(function (resolve) { resolve('foo') })\n}\n\nconsole.log(getFoo())\nconsole.log(getBar())\n</code></pre>\n\n<p>In this case, it will always print <code>foo\\nbar</code>, even though <code>foo</code> is\nresolved later, and <code>bar</code> is resolved immediately.  Eventual Values\nbehave like synchronous values.</p>\n\n<h2>Introspection, Operators, Etc.</h2>\n\n<p>It&rsquo;d be nice to have some magic <code>isEventual</code> operator that could tell\nyou if a thing was already resolved or not.</p>\n\n<p>Or even a <code>wasEventual</code> operator to tell you whether this thing you\nhave was ever waited upon.</p>\n\n<p>But mostly, while it&rsquo;s great to be able to introspect programs, it&rsquo;s\neven better not to have to <em>need</em> to introspect programs.  We don&rsquo;t\nhave memory address introspection in JavaScript, and no one seems to\nmind.  Inspecting Eventual Values should be akin to peering into the\ndark machinery of the VM; something that&rsquo;s useful once in a while, and\ncertainly interesting from an academic point of view, but not in the\nnormal day to day activities of the typical JavaScript programmer.</p>\n\n<p>Language design is hard.  It may be that there&rsquo;s some really good\nreason for at least having a special operator or something to say\n&ldquo;Yes, I would like any Eventual Values to be resolved before calling\nthis function.&rdquo;  Maybe use <code>functionE</code> instead of <code>function</code>, I don&rsquo;t\nknow.  I don&rsquo;t care.  I just want to stop having to stick my nose in\nthe machinery.  Ideally, we&rsquo;d almost never have to care, because it\nonly matters at the very edges of a program, when data is sent to the\nDOM, or written to a file or socket or terminal.</p>\n\n<h2>Implementation</h2>\n\n<p>This cannot be implemented in userland, nor should they be.  Eventual\nValues are a language feature.  Promises are an API, and easy to\nimplement in userland.</p>\n\n<p>Promises will never grow into Eventuals, because they are\nfundamentally different things, even though they implement a similar\npattern.</p>\n\n<h2>Looking Async</h2>\n\n<p>I&rsquo;ve argued in the past, quite forcefully, that synchronous code\nshould look synchronous, and async code should look async.  But again,\nlike Zalgo, let&rsquo;s not conflate &ldquo;a good rule of thumb for API design&rdquo;\nwith &ldquo;a language feature that would make our lives better&rdquo;.</p>\n\n<p>If you dig one layer deeper, you find that the only reason\nasynchronous code needs to look asynchronous is that we continually\nrely upon our human brains to deal with the timing and synchronicity\nof our programs.</p>\n\n<p>In cases where we are relying on a meat brain to analyze a program, it\nis extremely important for it to look like what it is.  There will\nlikely always be some API surfaces that are asynchronous, and even in\na world with Eventual Values, there is a place for APIs that are\ncreatively asynchronous, and they should look and behave like what\nthey are.</p>\n\n<h2>Anti-Promises</h2>\n\n<p>Promises are neat.  They&rsquo;re a terse and expressive way to chain\ntogether a series of potentially asynchronous actions in a way that&rsquo;s\nrelatively easy for a meat brain to make sense of.</p>\n\n<p>Also, it&rsquo;s quite nice how they invert control differently than\ncallbacks.  With a callback, the caller creates and passes a token to\nthe API, with the contract that the API provider will use that token\nto indicate done-ness.  With Promises, the API provider creates and\npasses a token to the caller, with the contract that the API provider\nwill use that token to indicate done-ness.</p>\n\n<p>It&rsquo;s a subtle difference, but one that many people find easier to\nreason about.  That&rsquo;s fine.</p>\n\n<p>However, if you have a function that takes a list of arguments, any of\nwhich may potentially be promises, and then needs to only act once all\nof those promises are resolved, it gets tedious quite fast.  Promises\ntend to expose quite a lot of boilerplate to the user in these types\nof situations.  And, since the only straightforward solution is to\neither turn all things into Promises, or manually check each for\nPromise-ness, one potentially ends up introducing a lot of\n<code>nextTick()</code> delays unnecessarily.</p>\n\n<p>I don&rsquo;t dislike Promises.  But I do long for Eventual Values, and\nPromises are not those.</p>",
            "content_raw": "<p>A few times on Twitter, I\u2019ve\n<a href=\"https://twitter.com/izs/status/694321665430261760\">complained</a> that\nPromises are a poor conceptual stand-in for Eventual Values.</p>\n\n<p>A colleague of mine pointed out that I tweet this or something like it\nevery few months.  He\u2019s correct, I do.</p>\n\n<p>The responses usually flow in saying something to the effect of \u201cWell,\nif you\u2019re not sure if a thing is a Promise or not, just use\n<code>Promise.resolve(thing)</code> and now you\u2019re guaranteed to get either the\nPromise, or a Promise that resolves to the thing.\u201d</p>\n\n<p>And it\u2019s true, that is \u201ca\u201d solution of sorts.  It solves the \u201cI don\u2019t\nknow if this is a Promise or not\u201d problem by ensuring that you\ndefinitely do have a Promise, and not a normal value.</p>\n\n<p>My problem, though, is that I\u2019d really like to write code that\ninteracts with values, and not Promises, and leave the machinery to\nthe computer to work out.</p>\n\n<h2 id=\"eventual-values\">Eventual Values</h2>\n\n<p>An Eventual Value is a value that is not yet resolved.  However, by\ndesign, it is mostly indistinguishable from a \u201cnormal\u201d value.  Here\u2019s\nan example:</p>\n\n<pre><code class=\"lang-javascript\">// promise code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction add5Promise (x) {\n  return Promise.resolve(x).then(function (x) {\n    return add5(x)\n  })\n}\n\nfunction someNumberLater () {\n  return new Promise(function (resolve) {\n    databaseConnector.get('numeric value').then(function (x) {\n      resolve(x)\n    })\n  })\n}\n\nadd5Promise(someNumberLater()).then(function (xplus5) {\n  console.log('the number plus 5 is %d', xplus5)\n})\n</code></pre>\n\n<p>With Eventual Values, this would look like the following:</p>\n\n<pre><code class=\"lang-javascript\">// eventual value code\nfunction add5 (x) {\n  return x + 5\n}\n\nfunction someNumberLater () {\n  databaseConnector.get('numeric value'))\n}\n\nconsole.log('the number plus 5 is %d', add5(someNumberLater()))\n</code></pre>\n\n<p>If you imagine getting a few numbers, any of which might be as yet\nunresolved, it\u2019s even more annoying:</p>\n\n<pre><code class=\"lang-javascript\">// promise code\nfunction addThreeNumbers (x, y, z) {\n  return Promise.all([x, y, z]).then(function (numbers) {\n    return Promise.resolve(numbers[0] + numbers[1] + numbers[3])\n  })\n}\n\n// eventual code\nfunction addThreeNumbers (x, y, z) {\n  return x + y + z\n}\n</code></pre>\n\n<h3 id=\"criteria\">Criteria</h3>\n\n<ul><li>Eventual Values can be interacted with like normal values.</li>\n<li>If an Eventual Value is part of a simple value operation, then that\nexpression resolves to a new Eventual Value which resolves when all\nits Eventual Values are resolved.</li>\n</ul><p>That\u2019s it.  You interact with Eventual Values as if they\u2019re normal\nsynchronous values, and the machine takes care of waiting where it\u2019s\nnecessary and appropriate.</p>\n\n<h2 id=\"but-zalgo-\">But Zalgo!</h2>\n\n<p>Indeed, this is\n<a href=\"http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony\">Zalgo</a>\u2019s\npurest form.  But let\u2019s clarify exactly what\u2019s wrong with the\nmaybe-sync anti-pattern.</p>\n\n<p>The problem with Zalgo APIs is that they\u2019re hard to reason about.\nGiven code like this:</p>\n\n<pre><code class=\"lang-javascript\">someApi(function () {\n  console.log('foo')\n})\nconsole.log('bar')\n</code></pre>\n\n<p>In a sync callback API, you know that this will always print out\n<code>foo\\nbar</code>.  In an async callback API, you know that this will always\nprint out <code>bar\\nfoo</code>.  This predictability is important for human\nbrains.</p>\n\n<p>This is why the built-in dezalgo of Promises A+ is so important.</p>\n\n<pre><code class=\"lang-javascript\">new Promise(function (resolve) {\n  console.log('foo')\n  resolve()\n})\nconsole.log('bar')\n</code></pre>\n\n<p>This code must either (a) always print <code>foo\\nbar</code>, or (b) always print\n<code>bar\\nfoo</code>.  Since Promise resolution <em>can</em> be async, it <em>must</em> be\nasync all the time, or else this predictability constraint is\nviolated.</p>\n\n<p>With Eventual Values, Zalgo is not a problem, because whether things\nhappen synchronously or asynchronously, they always happen in the same\npredictable order.</p>\n\n<pre><code class=\"lang-javascript\">function getFoo () {\n  return new Eventual(function (resolve) {\n    setTimeout(function () {\n      resolve('foo')\n    })\n  })\n}\n\nfunction getBar () {\n  return new Eventual(function (resolve) { resolve('foo') })\n}\n\nconsole.log(getFoo())\nconsole.log(getBar())\n</code></pre>\n\n<p>In this case, it will always print <code>foo\\nbar</code>, even though <code>foo</code> is\nresolved later, and <code>bar</code> is resolved immediately.  Eventual Values\nbehave like synchronous values.</p>\n\n<h2 id=\"introspection-operators-etc-\">Introspection, Operators, Etc.</h2>\n\n<p>It\u2019d be nice to have some magic <code>isEventual</code> operator that could tell\nyou if a thing was already resolved or not.</p>\n\n<p>Or even a <code>wasEventual</code> operator to tell you whether this thing you\nhave was ever waited upon.</p>\n\n<p>But mostly, while it\u2019s great to be able to introspect programs, it\u2019s\neven better not to have to <em>need</em> to introspect programs.  We don\u2019t\nhave memory address introspection in JavaScript, and no one seems to\nmind.  Inspecting Eventual Values should be akin to peering into the\ndark machinery of the VM; something that\u2019s useful once in a while, and\ncertainly interesting from an academic point of view, but not in the\nnormal day to day activities of the typical JavaScript programmer.</p>\n\n<p>Language design is hard.  It may be that there\u2019s some really good\nreason for at least having a special operator or something to say\n\u201cYes, I would like any Eventual Values to be resolved before calling\nthis function.\u201d  Maybe use <code>functionE</code> instead of <code>function</code>, I don\u2019t\nknow.  I don\u2019t care.  I just want to stop having to stick my nose in\nthe machinery.  Ideally, we\u2019d almost never have to care, because it\nonly matters at the very edges of a program, when data is sent to the\nDOM, or written to a file or socket or terminal.</p>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>This cannot be implemented in userland, nor should they be.  Eventual\nValues are a language feature.  Promises are an API, and easy to\nimplement in userland.</p>\n\n<p>Promises will never grow into Eventuals, because they are\nfundamentally different things, even though they implement a similar\npattern.</p>\n\n<h2 id=\"looking-async\">Looking Async</h2>\n\n<p>I\u2019ve argued in the past, quite forcefully, that synchronous code\nshould look synchronous, and async code should look async.  But again,\nlike Zalgo, let\u2019s not conflate \u201ca good rule of thumb for API design\u201d\nwith \u201ca language feature that would make our lives better\u201d.</p>\n\n<p>If you dig one layer deeper, you find that the only reason\nasynchronous code needs to look asynchronous is that we continually\nrely upon our human brains to deal with the timing and synchronicity\nof our programs.</p>\n\n<p>In cases where we are relying on a meat brain to analyze a program, it\nis extremely important for it to look like what it is.  There will\nlikely always be some API surfaces that are asynchronous, and even in\na world with Eventual Values, there is a place for APIs that are\ncreatively asynchronous, and they should look and behave like what\nthey are.</p>\n\n<h2 id=\"anti-promises\">Anti-Promises</h2>\n\n<p>Promises are neat.  They\u2019re a terse and expressive way to chain\ntogether a series of potentially asynchronous actions in a way that\u2019s\nrelatively easy for a meat brain to make sense of.</p>\n\n<p>Also, it\u2019s quite nice how they invert control differently than\ncallbacks.  With a callback, the caller creates and passes a token to\nthe API, with the contract that the API provider will use that token\nto indicate done-ness.  With Promises, the API provider creates and\npasses a token to the caller, with the contract that the API provider\nwill use that token to indicate done-ness.</p>\n\n<p>It\u2019s a subtle difference, but one that many people find easier to\nreason about.  That\u2019s fine.</p>\n\n<p>However, if you have a function that takes a list of arguments, any of\nwhich may potentially be promises, and then needs to only act once all\nof those promises are resolved, it gets tedious quite fast.  Promises\ntend to expose quite a lot of boilerplate to the user in these types\nof situations.  And, since the only straightforward solution is to\neither turn all things into Promises, or manually check each for\nPromise-ness, one potentially ends up introducing a lot of\n<code>nextTick()</code> delays unnecessarily.</p>\n\n<p>I don\u2019t dislike Promises.  But I do long for Eventual Values, and\nPromises are not those.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "138563331483"
            }
        }
    ],
    "type": "text"
}