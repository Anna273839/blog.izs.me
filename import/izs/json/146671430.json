{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p><cite>I originally posted this <a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/\">at isaacschlueter.com on Monday, October 23rd, 2006</a>.</cite></p>\n\n<p>Memory Leaks.</p>\n\n<p>What are they?  How do they happen?  What can be done about them?</p>\n\n<p>This is a great question, and a topic that has a lot of mysticism surrounding it.  Like most Javascript issues, there&rsquo;s been a lot of very bad &ldquo;authoritative&rdquo; suggestions.</p>\n\n<p>If you are a webdev interviewing at Yahoo!, and I&rsquo;m in the room, I can guarantee that you will be asked about this topic.  In my opinion, memory leaks are one of the most tricky ways in which a user&rsquo;s web experience can be needlessly degraded.  A web developer&rsquo;s attitude towards memory leaks is, in my opinion, one of the best indicators of their worth in this field.</p>\n\n<p>Either you understand what a memory leak is and how it happens, or you don&rsquo;t.  If you don&rsquo;t, that&rsquo;s fine, but it&rsquo;s time to find out once you hear some buzz about it.  Once you understand it, you can either care about it, or not.  Anyone who doesn&rsquo;t fall into the &ldquo;find out/care about it&rdquo; category would be better off flipping burgers than writing Javascript.</p>\n\n<!--more-->\n\n<h3>What Are Memory Leaks?</h3>\n\n<p>In general, a &ldquo;memory leak&rdquo; is the failure to release memory that has been allocated to a program.  Over time, a memory leak will result in progressively less memory being available to perform valid functions.</p>\n\n<p>In the browser/Javascript world, a memory leak occurs when the native garbage collection routines don&rsquo;t properly reclaim the memory that was allocated for an object.  Each time you create an object in Javascript, a bit of memory is allocated.  Memory is also allocated for DOM nodes, COM objects, images, etc.  When an object can no longer be accessed, it is flagged as &ldquo;ready for removal.&rdquo;  Then the garbage collection routine sweeps up the flagged objects, and releases the memory back to the system.  In Microsoft Internet Explorer 6, there is a bug in the garbage collection routine that can lead to memory leaks in certain conditions.</p>\n\n<p>A good discussion on memory leaks and why and how they happen can be found <a href=\"http://www.crockford.com/javascript/memory/leak.html\">on Crockford&rsquo;s site</a>.  The claim that closures (functions inside of other functions) cause memory leaks is, as Crockford says, &ldquo;deeply wrong.&rdquo;  Closures are fine, and are not the source of the problem.  (However, of course, closures can make circular links trickier to spot.)</p>\n\n<p>The problem happens when you have a Javascript object and DOM node (or any COM object) that refer to one another in a cycle.  IE 6 can&rsquo;t figure out when it should reclaim the memory, so it doesn&rsquo;t ever do it.</p>\n\n<p>For example, this will cause a leak:</p>\n\n<p><code class=\"block\">(function(){\nvar obj={b:document.body};\ndocument.body.o=obj; // \u2190 circular link is created.  document.body.o.b === document.body\n})();</code></p>\n\n<p>If you set either obj.doc.body or body.o to NULL, then you&rsquo;ll break the circular chain, and IE 6 will reclaim the memory.</p>\n\n<p>The cycle doesn&rsquo;t have to be so small.  Even a chain of many steps can cause a leak if it is not broken.  This will cause a leak, too:</p>\n\n<p><code class=\"block\">(function(){\nvar d={b:document.body}\nvar obj={doc:d}; // \u2190 obj.doc.b === document.body\ndocument.body.o=obj; // \u2190 Circular loop: document.body.o.doc.b === document.body\n})();</code></p>\n\n<p>Sometimes the references aren&rsquo;t explicit, but are created by a scope closure.  (This may be part of the thinking behind the assertion that closures cause memory leaks.)  For example, this will also leak:</p>\n\n<p><code class=\"block\">(function(){\nvar b=document.body; // \u2190 create a reference to document.body inside of the outer scope.\nb.onclick=function() { // \u2190 b.onclick refers to a function.\n\u00a0\u00a0// this function can access \"b\" due to closure\n\u00a0\u00a0// do something...\n};\n})();</code></p>\n\n<p>The anonymous function is assigned to <code>document.body.onclick</code>.  Due to the scope closure, there is a reference (<code>b</code>) created inside of the anonymous function that points back at document.body.  This creates a circular condition that confounds and befuddles the MSIE garbage collector just like the other examples above.</p>\n\n<h3>How To Avoid Memory Leaks</h3>\n\n<p>The simplest way to ensure that you will never have a memory leak is to simply never have circular reference chains that cross between Javascript and DOM space.  Make sure that you always have Javascript objects refer to DOM objects, and never the other way round, or vice versa.</p>\n\n<p>However, it&rsquo;s sometimes extremely convenient to have circular link.  Consider this example:</p>\n\n<p><code class=\"block\">(function(){\nvar doSomething=function(e) {\n\u00a0\u00a0this.innerHTML='did something!';\n\u00a0\u00a0this.object.doSomethingElse(this.customPropertyOfSomeKind);\n};\nmyDomNode.object=new myObject();\nmyDomNode.customPropertyOfSomeKind={some:'data object'};\nYAHOO.util.Event.addListener(myDomNode,'click',doSomething);\n})();</code></p>\n\n<p>Now, if myObject has any reference to myDomNode (even if it refers to something that refers to something else &hellip; that refers to myDomNode), you&rsquo;ll leak memory.</p>\n\n<h3>How to Fix MSIE&rsquo;s Javascript Memory Leaks</h3>\n\n<p>So, how to fix this?</p>\n\n<p>First, be aware when you&rsquo;re doing things that may cause a leak.  If it&rsquo;s not a very big gain in code simplicity, then figure out another way around.  If you&rsquo;re hanging a lot of Javascript objects onto DOM objects, there&rsquo;s a big chance of a leak creeping in.  Personally, I try to make sure that all my references go from JS\u2192DOM and not the other way around.  If the references are always one-way, then there&rsquo;s no chance of a leak.  (Closures can only create JS\u2192DOM references.)  Also, we&rsquo;ve seen performance issues with hanging too much stuff on DOM nodes if the page is big and complicated (that&rsquo;s anecdotal, and I don&rsquo;t have any hard numbers, so take it for what it&rsquo;s worth.)\nIf you understand how they work and why they happen, you can save yourself a lot of time later on tracking them down.</p>\n\n<p>Second, test your code with <a href=\"http://outofhanwell.com/ieleak/index.php?title=Main_Page\">Drip</a>.  Test early, test often, and <strong>always</strong> test before you release to production.</p>\n\n<p>I can&rsquo;t possibly stress how important this is.  Even if you&rsquo;ve done everything right, it&rsquo;s easy to overlook circular references if the code gets sufficiently complex.  Even small memory leaks can add up over the course of a session, or in a browser that stays open for days on end.  (It happens quite a bit.  I don&rsquo;t know when I last closed the browser on my home computer, and a lot of users are the same way.)</p>\n\n<p>Third, if you must cause circular references in your code, be responsible about it.  Save a reference to each afflicted DOM node, and break the cycles on window unload.  I often do something like this:</p>\n\n<p><code class=\"block\">(function(){\nvar unLoaders=[];\nmyDomNode.object=new myObject(); // \u2190 let's say that this creates a leak somewhere\nunLoaders.push(myDomNode); // \u2190 save it for later\n// create an \"unload\" function\nvar unload=function(){\n\u00a0\u00a0for(var i=unLoaders.length-1;i&gt;-1;i--){\n\u00a0\u00a0\u00a0\u00a0unLoaders[i].object=null; // \u2190 break the cycle\n\u00a0\u00a0}\n};\n// run the unload function on window.unload\nYAHOO.util.Event.addListener(window,'unload',unload);\n})();</code></p>\n\n<h3>Memory Leaks and <acronym title=\"Asynchronous Javascript And Xml\">Ajax</acronym>/<acronym title=\"XmlHttpRequest\">XHR</acronym></h3>\n\n<p>Ajax is a huge source of memory leaks, and unfortunately in this day and age of fast-prototyping and marketing pushing, a lot of these errors slip out into the world.  If you don&rsquo;t use a polling mechanism of some kind, AJAX applications will leak memory like a bucket with no bottom.  Use the <a href=\"http://developer.yahoo.com/yui/connection/\">YUI connection library for Ajax</a>, and never look back.  It&rsquo;s brilliant, and very easy to use.</p>\n\n<p>So, why do AJAX apps leak memory so badly if you don&rsquo;t use a polling mechanism?  Consider the &ldquo;typical&rdquo; XHR code pattern:</p>\n\n<p><code class=\"block\">(function(){\nvar x=getXHRobject();\nx.onreadystatechange=function() { // \u2190 create link from x (COM object) to anonymous function\n\u00a0\u00a0if(x.readystate==4){ // \u2190 reference to x exists inside function scope, creating circular link.\n\u00a0\u00a0\u00a0\u00a0// do something.\n\u00a0\u00a0}\n};\n})();</code></p>\n\n<p>The XmlHttpRequest object is treated in Javascript much like a DOM node.  (More precisely, this problem affects all COM objects, including DOM nodes.)  If you attach an onreadystatechange handler to it, you&rsquo;ve created a circular loop.  The standard means of breaking these chains won&rsquo;t work.  The YUI connection lib polls the object&rsquo;s readystate until it is done, and then calls your success function.  (If it times out or gets an error, it calls your failure function.)  Since there&rsquo;s no onreadystatechange listener, there&rsquo;s no circular reference, and thus, no memory leak.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2007-06-11 17:00:16 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 146671430,
    "is_blocks_post_format": false,
    "note_count": 0,
    "post_url": "http://blog.izs.me/post/146671430/memory-leaks-in-microsoft-internet-explorer",
    "reblog": {
        "comment": "<p><cite>I originally posted this <a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/\">at isaacschlueter.com on Monday, October 23rd, 2006</a>.</cite></p>\n\n<p>Memory Leaks.</p>\n\n<p>What are they?  How do they happen?  What can be done about them?</p>\n\n<p>This is a great question, and a topic that has a lot of mysticism surrounding it.  Like most Javascript issues, there\u2019s been a lot of very bad \u201cauthoritative\u201d suggestions.</p>\n\n<p>If you are a webdev interviewing at Yahoo!, and I\u2019m in the room, I can guarantee that you will be asked about this topic.  In my opinion, memory leaks are one of the most tricky ways in which a user\u2019s web experience can be needlessly degraded.  A web developer\u2019s attitude towards memory leaks is, in my opinion, one of the best indicators of their worth in this field.</p>\n\n<p>Either you understand what a memory leak is and how it happens, or you don\u2019t.  If you don\u2019t, that\u2019s fine, but it\u2019s time to find out once you hear some buzz about it.  Once you understand it, you can either care about it, or not.  Anyone who doesn\u2019t fall into the \u201cfind out/care about it\u201d category would be better off flipping burgers than writing Javascript.</p>\n\n<!--more-->\n\n<h3>What Are Memory Leaks?</h3>\n\n<p>In general, a \u201cmemory leak\u201d is the failure to release memory that has been allocated to a program.  Over time, a memory leak will result in progressively less memory being available to perform valid functions.</p>\n\n<p>In the browser/Javascript world, a memory leak occurs when the native garbage collection routines don\u2019t properly reclaim the memory that was allocated for an object.  Each time you create an object in Javascript, a bit of memory is allocated.  Memory is also allocated for DOM nodes, COM objects, images, etc.  When an object can no longer be accessed, it is flagged as \u201cready for removal.\u201d  Then the garbage collection routine sweeps up the flagged objects, and releases the memory back to the system.  In Microsoft Internet Explorer 6, there is a bug in the garbage collection routine that can lead to memory leaks in certain conditions.</p>\n\n<p>A good discussion on memory leaks and why and how they happen can be found <a href=\"http://www.crockford.com/javascript/memory/leak.html\">on Crockford\u2019s site</a>.  The claim that closures (functions inside of other functions) cause memory leaks is, as Crockford says, \u201cdeeply wrong.\u201d  Closures are fine, and are not the source of the problem.  (However, of course, closures can make circular links trickier to spot.)</p>\n\n<p>The problem happens when you have a Javascript object and DOM node (or any COM object) that refer to one another in a cycle.  IE 6 can\u2019t figure out when it should reclaim the memory, so it doesn\u2019t ever do it.</p>\n\n<p>For example, this will cause a leak:</p>\n\n<p><code class=\"block\">(function(){\nvar obj={b:document.body};\ndocument.body.o=obj; // \u2190 circular link is created.  document.body.o.b === document.body\n})();</code></p>\n\n<p>If you set either obj.doc.body or body.o to NULL, then you\u2019ll break the circular chain, and IE 6 will reclaim the memory.</p>\n\n<p>The cycle doesn\u2019t have to be so small.  Even a chain of many steps can cause a leak if it is not broken.  This will cause a leak, too:</p>\n\n<p><code class=\"block\">(function(){\nvar d={b:document.body}\nvar obj={doc:d}; // \u2190 obj.doc.b === document.body\ndocument.body.o=obj; // \u2190 Circular loop: document.body.o.doc.b === document.body\n})();</code></p>\n\n<p>Sometimes the references aren\u2019t explicit, but are created by a scope closure.  (This may be part of the thinking behind the assertion that closures cause memory leaks.)  For example, this will also leak:</p>\n\n<p><code class=\"block\">(function(){\nvar b=document.body; // \u2190 create a reference to document.body inside of the outer scope.\nb.onclick=function() { // \u2190 b.onclick refers to a function.\n\u00a0\u00a0// this function can access \"b\" due to closure\n\u00a0\u00a0// do something...\n};\n})();</code></p>\n\n<p>The anonymous function is assigned to <code>document.body.onclick</code>.  Due to the scope closure, there is a reference (<code>b</code>) created inside of the anonymous function that points back at document.body.  This creates a circular condition that confounds and befuddles the MSIE garbage collector just like the other examples above.</p>\n\n<h3>How To Avoid Memory Leaks</h3>\n\n<p>The simplest way to ensure that you will never have a memory leak is to simply never have circular reference chains that cross between Javascript and DOM space.  Make sure that you always have Javascript objects refer to DOM objects, and never the other way round, or vice versa.</p>\n\n<p>However, it\u2019s sometimes extremely convenient to have circular link.  Consider this example:</p>\n\n<p><code class=\"block\">(function(){\nvar doSomething=function(e) {\n\u00a0\u00a0this.innerHTML='did something!';\n\u00a0\u00a0this.object.doSomethingElse(this.customPropertyOfSomeKind);\n};\nmyDomNode.object=new myObject();\nmyDomNode.customPropertyOfSomeKind={some:'data object'};\nYAHOO.util.Event.addListener(myDomNode,'click',doSomething);\n})();</code></p>\n\n<p>Now, if myObject has any reference to myDomNode (even if it refers to something that refers to something else \u2026 that refers to myDomNode), you\u2019ll leak memory.</p>\n\n<h3>How to Fix MSIE\u2019s Javascript Memory Leaks</h3>\n\n<p>So, how to fix this?</p>\n\n<p>First, be aware when you\u2019re doing things that may cause a leak.  If it\u2019s not a very big gain in code simplicity, then figure out another way around.  If you\u2019re hanging a lot of Javascript objects onto DOM objects, there\u2019s a big chance of a leak creeping in.  Personally, I try to make sure that all my references go from JS\u2192DOM and not the other way around.  If the references are always one-way, then there\u2019s no chance of a leak.  (Closures can only create JS\u2192DOM references.)  Also, we\u2019ve seen performance issues with hanging too much stuff on DOM nodes if the page is big and complicated (that\u2019s anecdotal, and I don\u2019t have any hard numbers, so take it for what it\u2019s worth.)\nIf you understand how they work and why they happen, you can save yourself a lot of time later on tracking them down.</p>\n\n<p>Second, test your code with <a href=\"http://outofhanwell.com/ieleak/index.php?title=Main_Page\">Drip</a>.  Test early, test often, and <strong>always</strong> test before you release to production.</p>\n\n<p>I can\u2019t possibly stress how important this is.  Even if you\u2019ve done everything right, it\u2019s easy to overlook circular references if the code gets sufficiently complex.  Even small memory leaks can add up over the course of a session, or in a browser that stays open for days on end.  (It happens quite a bit.  I don\u2019t know when I last closed the browser on my home computer, and a lot of users are the same way.)</p>\n\n<p>Third, if you must cause circular references in your code, be responsible about it.  Save a reference to each afflicted DOM node, and break the cycles on window unload.  I often do something like this:</p>\n\n<p><code class=\"block\">(function(){\nvar unLoaders=[];\nmyDomNode.object=new myObject(); // \u2190 let's say that this creates a leak somewhere\nunLoaders.push(myDomNode); // \u2190 save it for later\n// create an \"unload\" function\nvar unload=function(){\n\u00a0\u00a0for(var i=unLoaders.length-1;i&gt;-1;i--){\n\u00a0\u00a0\u00a0\u00a0unLoaders[i].object=null; // \u2190 break the cycle\n\u00a0\u00a0}\n};\n// run the unload function on window.unload\nYAHOO.util.Event.addListener(window,'unload',unload);\n})();</code></p>\n\n<h3>Memory Leaks and <acronym title=\"Asynchronous Javascript And Xml\">Ajax</acronym>/<acronym title=\"XmlHttpRequest\">XHR</acronym></h3>\n\n<p>Ajax is a huge source of memory leaks, and unfortunately in this day and age of fast-prototyping and marketing pushing, a lot of these errors slip out into the world.  If you don\u2019t use a polling mechanism of some kind, AJAX applications will leak memory like a bucket with no bottom.  Use the <a href=\"http://developer.yahoo.com/yui/connection/\">YUI connection library for Ajax</a>, and never look back.  It\u2019s brilliant, and very easy to use.</p>\n\n<p>So, why do AJAX apps leak memory so badly if you don\u2019t use a polling mechanism?  Consider the \u201ctypical\u201d XHR code pattern:</p>\n\n<p><code class=\"block\">(function(){\nvar x=getXHRobject();\nx.onreadystatechange=function() { // \u2190 create link from x (COM object) to anonymous function\n\u00a0\u00a0if(x.readystate==4){ // \u2190 reference to x exists inside function scope, creating circular link.\n\u00a0\u00a0\u00a0\u00a0// do something.\n\u00a0\u00a0}\n};\n})();</code></p>\n\n<p>The XmlHttpRequest object is treated in Javascript much like a DOM node.  (More precisely, this problem affects all COM objects, including DOM nodes.)  If you attach an onreadystatechange handler to it, you\u2019ve created a circular loop.  The standard means of breaking these chains won\u2019t work.  The YUI connection lib polls the object\u2019s readystate until it is done, and then calls your success function.  (If it times out or gets an error, it calls your failure function.)  Since there\u2019s no onreadystatechange listener, there\u2019s no circular reference, and thus, no memory leak.</p>",
        "tree_html": ""
    },
    "reblog_key": "sDTRz3Uk",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWy8lWT6",
    "slug": "memory-leaks-in-microsoft-internet-explorer",
    "state": "published",
    "summary": "Memory Leaks in Microsoft Internet Explorer",
    "tags": [
        "Internet Exploder",
        "Javascript"
    ],
    "timestamp": 1181581216,
    "title": "Memory Leaks in Microsoft Internet Explorer",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>I originally posted this <a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/\">at isaacschlueter.com on Monday, October 23rd, 2006</a>.</p>\n\n<p>Memory Leaks.</p>\n\n<p>What are they?  How do they happen?  What can be done about them?</p>\n\n<p>This is a great question, and a topic that has a lot of mysticism surrounding it.  Like most Javascript issues, there&rsquo;s been a lot of very bad &ldquo;authoritative&rdquo; suggestions.</p>\n\n<p>If you are a webdev interviewing at Yahoo!, and I&rsquo;m in the room, I can guarantee that you will be asked about this topic.  In my opinion, memory leaks are one of the most tricky ways in which a user&rsquo;s web experience can be needlessly degraded.  A web developer&rsquo;s attitude towards memory leaks is, in my opinion, one of the best indicators of their worth in this field.</p>\n\n<p>Either you understand what a memory leak is and how it happens, or you don&rsquo;t.  If you don&rsquo;t, that&rsquo;s fine, but it&rsquo;s time to find out once you hear some buzz about it.  Once you understand it, you can either care about it, or not.  Anyone who doesn&rsquo;t fall into the &ldquo;find out/care about it&rdquo; category would be better off flipping burgers than writing Javascript.</p>\n\n\n\n<h3>What Are Memory Leaks?</h3>\n\n<p>In general, a &ldquo;memory leak&rdquo; is the failure to release memory that has been allocated to a program.  Over time, a memory leak will result in progressively less memory being available to perform valid functions.</p>\n\n<p>In the browser/Javascript world, a memory leak occurs when the native garbage collection routines don&rsquo;t properly reclaim the memory that was allocated for an object.  Each time you create an object in Javascript, a bit of memory is allocated.  Memory is also allocated for DOM nodes, COM objects, images, etc.  When an object can no longer be accessed, it is flagged as &ldquo;ready for removal.&rdquo;  Then the garbage collection routine sweeps up the flagged objects, and releases the memory back to the system.  In Microsoft Internet Explorer 6, there is a bug in the garbage collection routine that can lead to memory leaks in certain conditions.</p>\n\n<p>A good discussion on memory leaks and why and how they happen can be found <a href=\"http://www.crockford.com/javascript/memory/leak.html\">on Crockford&rsquo;s site</a>.  The claim that closures (functions inside of other functions) cause memory leaks is, as Crockford says, &ldquo;deeply wrong.&rdquo;  Closures are fine, and are not the source of the problem.  (However, of course, closures can make circular links trickier to spot.)</p>\n\n<p>The problem happens when you have a Javascript object and DOM node (or any COM object) that refer to one another in a cycle.  IE 6 can&rsquo;t figure out when it should reclaim the memory, so it doesn&rsquo;t ever do it.</p>\n\n<p>For example, this will cause a leak:</p>\n\n<p><code>(function(){\nvar obj={b:document.body};\ndocument.body.o=obj; // &larr; circular link is created.  document.body.o.b === document.body\n})();</code></p>\n\n<p>If you set either obj.doc.body or body.o to NULL, then you&rsquo;ll break the circular chain, and IE 6 will reclaim the memory.</p>\n\n<p>The cycle doesn&rsquo;t have to be so small.  Even a chain of many steps can cause a leak if it is not broken.  This will cause a leak, too:</p>\n\n<p><code>(function(){\nvar d={b:document.body}\nvar obj={doc:d}; // &larr; obj.doc.b === document.body\ndocument.body.o=obj; // &larr; Circular loop: document.body.o.doc.b === document.body\n})();</code></p>\n\n<p>Sometimes the references aren&rsquo;t explicit, but are created by a scope closure.  (This may be part of the thinking behind the assertion that closures cause memory leaks.)  For example, this will also leak:</p>\n\n<p><code>(function(){\nvar b=document.body; // &larr; create a reference to document.body inside of the outer scope.\nb.onclick=function() { // &larr; b.onclick refers to a function.\n&nbsp;&nbsp;// this function can access \"b\" due to closure\n&nbsp;&nbsp;// do something...\n};\n})();</code></p>\n\n<p>The anonymous function is assigned to <code>document.body.onclick</code>.  Due to the scope closure, there is a reference (<code>b</code>) created inside of the anonymous function that points back at document.body.  This creates a circular condition that confounds and befuddles the MSIE garbage collector just like the other examples above.</p>\n\n<h3>How To Avoid Memory Leaks</h3>\n\n<p>The simplest way to ensure that you will never have a memory leak is to simply never have circular reference chains that cross between Javascript and DOM space.  Make sure that you always have Javascript objects refer to DOM objects, and never the other way round, or vice versa.</p>\n\n<p>However, it&rsquo;s sometimes extremely convenient to have circular link.  Consider this example:</p>\n\n<p><code>(function(){\nvar doSomething=function(e) {\n&nbsp;&nbsp;this.innerHTML='did something!';\n&nbsp;&nbsp;this.object.doSomethingElse(this.customPropertyOfSomeKind);\n};\nmyDomNode.object=new myObject();\nmyDomNode.customPropertyOfSomeKind={some:'data object'};\nYAHOO.util.Event.addListener(myDomNode,'click',doSomething);\n})();</code></p>\n\n<p>Now, if myObject has any reference to myDomNode (even if it refers to something that refers to something else &hellip; that refers to myDomNode), you&rsquo;ll leak memory.</p>\n\n<h3>How to Fix MSIE&rsquo;s Javascript Memory Leaks</h3>\n\n<p>So, how to fix this?</p>\n\n<p>First, be aware when you&rsquo;re doing things that may cause a leak.  If it&rsquo;s not a very big gain in code simplicity, then figure out another way around.  If you&rsquo;re hanging a lot of Javascript objects onto DOM objects, there&rsquo;s a big chance of a leak creeping in.  Personally, I try to make sure that all my references go from JS&rarr;DOM and not the other way around.  If the references are always one-way, then there&rsquo;s no chance of a leak.  (Closures can only create JS&rarr;DOM references.)  Also, we&rsquo;ve seen performance issues with hanging too much stuff on DOM nodes if the page is big and complicated (that&rsquo;s anecdotal, and I don&rsquo;t have any hard numbers, so take it for what it&rsquo;s worth.)\nIf you understand how they work and why they happen, you can save yourself a lot of time later on tracking them down.</p>\n\n<p>Second, test your code with <a href=\"http://outofhanwell.com/ieleak/index.php?title=Main_Page\">Drip</a>.  Test early, test often, and <strong>always</strong> test before you release to production.</p>\n\n<p>I can&rsquo;t possibly stress how important this is.  Even if you&rsquo;ve done everything right, it&rsquo;s easy to overlook circular references if the code gets sufficiently complex.  Even small memory leaks can add up over the course of a session, or in a browser that stays open for days on end.  (It happens quite a bit.  I don&rsquo;t know when I last closed the browser on my home computer, and a lot of users are the same way.)</p>\n\n<p>Third, if you must cause circular references in your code, be responsible about it.  Save a reference to each afflicted DOM node, and break the cycles on window unload.  I often do something like this:</p>\n\n<p><code>(function(){\nvar unLoaders=[];\nmyDomNode.object=new myObject(); // &larr; let's say that this creates a leak somewhere\nunLoaders.push(myDomNode); // &larr; save it for later\n// create an \"unload\" function\nvar unload=function(){\n&nbsp;&nbsp;for(var i=unLoaders.length-1;i&gt;-1;i--){\n&nbsp;&nbsp;&nbsp;&nbsp;unLoaders[i].object=null; // &larr; break the cycle\n&nbsp;&nbsp;}\n};\n// run the unload function on window.unload\nYAHOO.util.Event.addListener(window,'unload',unload);\n})();</code></p>\n\n<h3>Memory Leaks and Ajax/XHR</h3>\n\n<p>Ajax is a huge source of memory leaks, and unfortunately in this day and age of fast-prototyping and marketing pushing, a lot of these errors slip out into the world.  If you don&rsquo;t use a polling mechanism of some kind, AJAX applications will leak memory like a bucket with no bottom.  Use the <a href=\"http://developer.yahoo.com/yui/connection/\">YUI connection library for Ajax</a>, and never look back.  It&rsquo;s brilliant, and very easy to use.</p>\n\n<p>So, why do AJAX apps leak memory so badly if you don&rsquo;t use a polling mechanism?  Consider the &ldquo;typical&rdquo; XHR code pattern:</p>\n\n<p><code>(function(){\nvar x=getXHRobject();\nx.onreadystatechange=function() { // &larr; create link from x (COM object) to anonymous function\n&nbsp;&nbsp;if(x.readystate==4){ // &larr; reference to x exists inside function scope, creating circular link.\n&nbsp;&nbsp;&nbsp;&nbsp;// do something.\n&nbsp;&nbsp;}\n};\n})();</code></p>\n\n<p>The XmlHttpRequest object is treated in Javascript much like a DOM node.  (More precisely, this problem affects all COM objects, including DOM nodes.)  If you attach an onreadystatechange handler to it, you&rsquo;ve created a circular loop.  The standard means of breaking these chains won&rsquo;t work.  The YUI connection lib polls the object&rsquo;s readystate until it is done, and then calls your success function.  (If it times out or gets an error, it calls your failure function.)  Since there&rsquo;s no onreadystatechange listener, there&rsquo;s no circular reference, and thus, no memory leak.</p>",
            "content_raw": "<p><cite>I originally posted this <a href=\"http://isaacschlueter.com/2006/10/msie-memory-leaks/\">at isaacschlueter.com on Monday, October 23rd, 2006</a>.</cite></p>\n\n<p>Memory Leaks.</p>\n\n<p>What are they?  How do they happen?  What can be done about them?</p>\n\n<p>This is a great question, and a topic that has a lot of mysticism surrounding it.  Like most Javascript issues, there\u2019s been a lot of very bad \u201cauthoritative\u201d suggestions.</p>\n\n<p>If you are a webdev interviewing at Yahoo!, and I\u2019m in the room, I can guarantee that you will be asked about this topic.  In my opinion, memory leaks are one of the most tricky ways in which a user\u2019s web experience can be needlessly degraded.  A web developer\u2019s attitude towards memory leaks is, in my opinion, one of the best indicators of their worth in this field.</p>\n\n<p>Either you understand what a memory leak is and how it happens, or you don\u2019t.  If you don\u2019t, that\u2019s fine, but it\u2019s time to find out once you hear some buzz about it.  Once you understand it, you can either care about it, or not.  Anyone who doesn\u2019t fall into the \u201cfind out/care about it\u201d category would be better off flipping burgers than writing Javascript.</p>\n\n<!--more-->\n\n<h3>What Are Memory Leaks?</h3>\n\n<p>In general, a \u201cmemory leak\u201d is the failure to release memory that has been allocated to a program.  Over time, a memory leak will result in progressively less memory being available to perform valid functions.</p>\n\n<p>In the browser/Javascript world, a memory leak occurs when the native garbage collection routines don\u2019t properly reclaim the memory that was allocated for an object.  Each time you create an object in Javascript, a bit of memory is allocated.  Memory is also allocated for DOM nodes, COM objects, images, etc.  When an object can no longer be accessed, it is flagged as \u201cready for removal.\u201d  Then the garbage collection routine sweeps up the flagged objects, and releases the memory back to the system.  In Microsoft Internet Explorer 6, there is a bug in the garbage collection routine that can lead to memory leaks in certain conditions.</p>\n\n<p>A good discussion on memory leaks and why and how they happen can be found <a href=\"http://www.crockford.com/javascript/memory/leak.html\">on Crockford\u2019s site</a>.  The claim that closures (functions inside of other functions) cause memory leaks is, as Crockford says, \u201cdeeply wrong.\u201d  Closures are fine, and are not the source of the problem.  (However, of course, closures can make circular links trickier to spot.)</p>\n\n<p>The problem happens when you have a Javascript object and DOM node (or any COM object) that refer to one another in a cycle.  IE 6 can\u2019t figure out when it should reclaim the memory, so it doesn\u2019t ever do it.</p>\n\n<p>For example, this will cause a leak:</p>\n\n<p><code class=\"block\">(function(){\nvar obj={b:document.body};\ndocument.body.o=obj; // \u2190 circular link is created.  document.body.o.b === document.body\n})();</code></p>\n\n<p>If you set either obj.doc.body or body.o to NULL, then you\u2019ll break the circular chain, and IE 6 will reclaim the memory.</p>\n\n<p>The cycle doesn\u2019t have to be so small.  Even a chain of many steps can cause a leak if it is not broken.  This will cause a leak, too:</p>\n\n<p><code class=\"block\">(function(){\nvar d={b:document.body}\nvar obj={doc:d}; // \u2190 obj.doc.b === document.body\ndocument.body.o=obj; // \u2190 Circular loop: document.body.o.doc.b === document.body\n})();</code></p>\n\n<p>Sometimes the references aren\u2019t explicit, but are created by a scope closure.  (This may be part of the thinking behind the assertion that closures cause memory leaks.)  For example, this will also leak:</p>\n\n<p><code class=\"block\">(function(){\nvar b=document.body; // \u2190 create a reference to document.body inside of the outer scope.\nb.onclick=function() { // \u2190 b.onclick refers to a function.\n\u00a0\u00a0// this function can access \"b\" due to closure\n\u00a0\u00a0// do something...\n};\n})();</code></p>\n\n<p>The anonymous function is assigned to <code>document.body.onclick</code>.  Due to the scope closure, there is a reference (<code>b</code>) created inside of the anonymous function that points back at document.body.  This creates a circular condition that confounds and befuddles the MSIE garbage collector just like the other examples above.</p>\n\n<h3>How To Avoid Memory Leaks</h3>\n\n<p>The simplest way to ensure that you will never have a memory leak is to simply never have circular reference chains that cross between Javascript and DOM space.  Make sure that you always have Javascript objects refer to DOM objects, and never the other way round, or vice versa.</p>\n\n<p>However, it\u2019s sometimes extremely convenient to have circular link.  Consider this example:</p>\n\n<p><code class=\"block\">(function(){\nvar doSomething=function(e) {\n\u00a0\u00a0this.innerHTML='did something!';\n\u00a0\u00a0this.object.doSomethingElse(this.customPropertyOfSomeKind);\n};\nmyDomNode.object=new myObject();\nmyDomNode.customPropertyOfSomeKind={some:'data object'};\nYAHOO.util.Event.addListener(myDomNode,'click',doSomething);\n})();</code></p>\n\n<p>Now, if myObject has any reference to myDomNode (even if it refers to something that refers to something else \u2026 that refers to myDomNode), you\u2019ll leak memory.</p>\n\n<h3>How to Fix MSIE\u2019s Javascript Memory Leaks</h3>\n\n<p>So, how to fix this?</p>\n\n<p>First, be aware when you\u2019re doing things that may cause a leak.  If it\u2019s not a very big gain in code simplicity, then figure out another way around.  If you\u2019re hanging a lot of Javascript objects onto DOM objects, there\u2019s a big chance of a leak creeping in.  Personally, I try to make sure that all my references go from JS\u2192DOM and not the other way around.  If the references are always one-way, then there\u2019s no chance of a leak.  (Closures can only create JS\u2192DOM references.)  Also, we\u2019ve seen performance issues with hanging too much stuff on DOM nodes if the page is big and complicated (that\u2019s anecdotal, and I don\u2019t have any hard numbers, so take it for what it\u2019s worth.)\nIf you understand how they work and why they happen, you can save yourself a lot of time later on tracking them down.</p>\n\n<p>Second, test your code with <a href=\"http://outofhanwell.com/ieleak/index.php?title=Main_Page\">Drip</a>.  Test early, test often, and <strong>always</strong> test before you release to production.</p>\n\n<p>I can\u2019t possibly stress how important this is.  Even if you\u2019ve done everything right, it\u2019s easy to overlook circular references if the code gets sufficiently complex.  Even small memory leaks can add up over the course of a session, or in a browser that stays open for days on end.  (It happens quite a bit.  I don\u2019t know when I last closed the browser on my home computer, and a lot of users are the same way.)</p>\n\n<p>Third, if you must cause circular references in your code, be responsible about it.  Save a reference to each afflicted DOM node, and break the cycles on window unload.  I often do something like this:</p>\n\n<p><code class=\"block\">(function(){\nvar unLoaders=[];\nmyDomNode.object=new myObject(); // \u2190 let's say that this creates a leak somewhere\nunLoaders.push(myDomNode); // \u2190 save it for later\n// create an \"unload\" function\nvar unload=function(){\n\u00a0\u00a0for(var i=unLoaders.length-1;i&gt;-1;i--){\n\u00a0\u00a0\u00a0\u00a0unLoaders[i].object=null; // \u2190 break the cycle\n\u00a0\u00a0}\n};\n// run the unload function on window.unload\nYAHOO.util.Event.addListener(window,'unload',unload);\n})();</code></p>\n\n<h3>Memory Leaks and <acronym title=\"Asynchronous Javascript And Xml\">Ajax</acronym>/<acronym title=\"XmlHttpRequest\">XHR</acronym></h3>\n\n<p>Ajax is a huge source of memory leaks, and unfortunately in this day and age of fast-prototyping and marketing pushing, a lot of these errors slip out into the world.  If you don\u2019t use a polling mechanism of some kind, AJAX applications will leak memory like a bucket with no bottom.  Use the <a href=\"http://developer.yahoo.com/yui/connection/\">YUI connection library for Ajax</a>, and never look back.  It\u2019s brilliant, and very easy to use.</p>\n\n<p>So, why do AJAX apps leak memory so badly if you don\u2019t use a polling mechanism?  Consider the \u201ctypical\u201d XHR code pattern:</p>\n\n<p><code class=\"block\">(function(){\nvar x=getXHRobject();\nx.onreadystatechange=function() { // \u2190 create link from x (COM object) to anonymous function\n\u00a0\u00a0if(x.readystate==4){ // \u2190 reference to x exists inside function scope, creating circular link.\n\u00a0\u00a0\u00a0\u00a0// do something.\n\u00a0\u00a0}\n};\n})();</code></p>\n\n<p>The XmlHttpRequest object is treated in Javascript much like a DOM node.  (More precisely, this problem affects all COM objects, including DOM nodes.)  If you attach an onreadystatechange handler to it, you\u2019ve created a circular loop.  The standard means of breaking these chains won\u2019t work.  The YUI connection lib polls the object\u2019s readystate until it is done, and then calls your success function.  (If it times out or gets an error, it calls your failure function.)  Since there\u2019s no onreadystatechange listener, there\u2019s no circular reference, and thus, no memory leak.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "146671430"
            }
        }
    ],
    "type": "text"
}