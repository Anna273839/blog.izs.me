{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>This question comes up in Node occasionally:</p>\n\n<blockquote>\n  <p>Node peoples&hellip; is there any way to specify a root directory for my\n  npm package so that I don&rsquo;t need require(&ldquo;mypackage/lib/foo&rdquo;)?</p>\n</blockquote>\n\n<p><i>\u2014 <a href=\"https://twitter.com/wycats/status/306570718102048768\">wycats</a></i></p>\n\n<p>In other words, you have a package directory structure like this:</p>\n\n<pre><code>./package.json\n./README.md\n./test/some-tests.js\n./lib/main.js  &lt;-- this is the package.json \"main\"\n./lib/some-other-module.js\n./lib/util/a-utility-module.js\n./lib/etc....\n</code></pre>\n\n<p>Now, let&rsquo;s say that this package&rsquo;s name is <code>foo</code>.  You want to be able\nto use foo&rsquo;s <code>some-other-module.js</code> file, outside of foo.</p>\n\n<p>The way to do this in node is do write:</p>\n\n<pre><code>var blah = require('foo/lib/some-other-module.js');\n</code></pre>\n\n<p>What <abbr title=\"and everyone else who requests this, of course\">Yehuda</abbr>\nwould like to see is:</p>\n\n<pre><code>var blah = require('foo/some-other-module.js');\n</code></pre>\n\n<p>The &ldquo;how&rdquo; here is simple: If you want a module in the root of your\npackage namespace, put the file in the root of your package folder.\nIt&rsquo;s a 1:1 mapping, so it&rsquo;s not hard to figure out how to get that\nresult.</p>\n\n<h3>But I don&rsquo;t want to have so many files in the root of my package folder</h3>\n\n<p>Ok.  <a href=\"http://howfuckedismydatabase.com/nosql/\" title=\"I believe I did, Bob\">So don&rsquo;t have so many files in\nthe root of your package folder.</a></p>\n\n<p>If you must export multiple modules from a single package, then you\nhave a choice:</p>\n\n<ol><li>Use an extra 4 characters in your <code>require()</code> statements, or</li>\n<li>Just don&rsquo;t have so many exports.</li>\n</ol><p>Many of us would suggest that <strong>in general</strong> you may want to consider\nif those things actually are a part of the &ldquo;foo&rdquo; package, or if they\nbelong in a dependency, with their own tests, name, version, etc.</p>\n\n<p>I am not personally so die-hard about &ldquo;one package = one file&rdquo;.\nOccasionally there are internal things, and it&rsquo;s not so bad.  But, <strong>in\ngeneral</strong>, I <strong>tend</strong> to be of the opinion that if a module requires\nits own individual unit tests, it probably should be its own package,\nif only so that I can think of it as a separate thing and give it the\nattention it clearly deserves.  If I&rsquo;m intending it to be used outside\nof the main package, then it <strong>most likely</strong> needs its own tests, and\nI&rsquo;ll package it up and make it a dep.</p>\n\n<p>Note all the weasel words in the above paragraph!  There are lots of\nexceptions to this rule.  But they don&rsquo;t fit on twitter, and in fact,\neven the weasel words put my response way over 140 characters, and\nso with the qualifications stripped out, it looks like a capricious\nreligion, unbound to factual realities of the imperfect world in which\nreal software development happens.</p>\n\n<p>The world being imperfect as it is, you may well find yourself in a\nstate where you have multiple exports, and you don&rsquo;t have the time or\ninclination to split them up into separate packages.  Sometimes the\nInappropriate Intimacy smell is less bad than the alternatives, it&rsquo;s\ntrue.  Sometimes it&rsquo;s just a simple business decision; sometimes it&rsquo;s\nless important to make it work right, than to make it work right now.</p>\n\n<p>In that case, put <code>\"lib/\"</code> in your <code>require()</code> statement.  It&rsquo;s not\nthat hard, really.</p>\n\n<h3>But <abbr title=\"see what i did there?\">WHY, cats</abbr>?</h3>\n\n<p>The argument to <code>require()</code> maps directly to a file path.  If it\ndoesn&rsquo;t start with <code>./</code> or <code>../</code> and isn&rsquo;t absolute (ie, starts with a\n<code>/</code> on unix, or any of a half dozen weird things on windows), then\nnode finds the closest <code>node_modules</code> folder with a thing by that\nname, and that&rsquo;s the prefix.  But everything after the prefix is just\na direct filename.</p>\n\n<p><i>(Aside: For historical reasons we do make the filename extension\noptional, which is a deeply regrettable accident of history that I\nwould not repeat, given the chance.)</i></p>\n\n<p>Let&rsquo;s look at the benefits, and the costs.</p>\n\n<h4>Aesthetics</h4>\n\n<p>The first benefit is removing 4 extra chars in some of the lines at\nthe top of some files.  This is rather small.  Even if you have 100\nrequires at the top of a module (which is very very many), and every\nsingle one of them is diving into some other package&rsquo;s guts, you&rsquo;re\nstill talking about pushing the average line <em>length</em> out by 4 chars.\nIt&rsquo;s not adding extra lines; it&rsquo;s not pushing the line length out that\nmuch.</p>\n\n<p>If you cannot accept that, then put the files in the root of your\npackage.  If <strong>that</strong> is too ugly, well, then weigh the ugliness of\nfile clutter against the ugliness of lines that are 4 whole characters\nlonger.</p>\n\n<p>The fact that this seems ugly is actually great, in my opinion.  <strong>You\nusually shouldn&rsquo;t be writing programs like this.</strong>  Packages should be\nexporting an interface that is designed for a purpose, and you should\nbe using them for that purpose.  This is basic software design.</p>\n\n<p>Doing an ugly thing should look ugly.  There may be reasons to do the\nugly thing, of course, and no one is saying that you&rsquo;re a bad person\nfor doing it, but the ugliness of the code should be a thing that you\nnotice, so that you can avoid ignoring the ugliness of the design.\nThere is a reason we evolved to find plump brightly colored fruit more\nappealing than wrinkled moldy fruit.  There is a reason we evolved to\nbe more able to ignore pleasure than pain.</p>\n\n<p>In other words, your aesthetics are trying to help you.  Saying &ldquo;it&rsquo;s\nugly&rdquo; is an argument <em>against</em> adding this feature, not for it.</p>\n\n<h4>(Alleged) Portability</h4>\n\n<p>Let&rsquo;s say that you want to have something like this:</p>\n\n<pre><code>./lib/node/module.js\n./lib/browser/module.js\n./lib/ringo/module.js\n./lib/narwhal/module.js\n</code></pre>\n\n<p>Then, I want to say &ldquo;Node should use <code>lib/node</code>, Ringo should use\n<code>lib/ringo</code>, and the browser should use <code>lib/browser</code>, so when I do\n<code>require('foo/module.js')</code>, I get the right one for my environment.</p>\n\n<p>First of all, that&rsquo;s very trivial to do without making the mapping of\nrequire arguments to filenames any more complicated.  Create a file\nlike this:</p>\n\n<pre><code>// module.js\nswitch(getPlatform()) {\n  case 'node':\n    module.exports = require('./node/module.js');\n    break;\n  case 'ringo':\n    module.exports = require('./ringo/module.js');\n    break;\n  case 'narwhal':\n    module.exports = require('./narwhal/module.js');\n    break;\n  default:\n    module.exports = require('./browser/module.js');\n    break;\n}\n\n// This can of course be simplified.\n// Usually something like this is sufficient:\n// if (typeof window === 'object')\n//   return module.exports = require('./browser.js');\n</code></pre>\n\n<p>If you find yourself doing this a lot, maybe ask yourself if you&rsquo;re\nusing the best abstractions, or maybe trying to make something\nportable that is fundamentally platform-specific.  Maybe try\nsupporting fewer platforms.</p>\n\n<p>Or, maybe, just do the ugly thing, and let it be ugly, and accept that\nit&rsquo;s a net benefit in your case.  But if your request is &quot;Make\nplatform-specific module behavior forking less ugly&rdquo;, then we&rsquo;re back\nto aesthetics, and my answer is, &ldquo;Ew.  No.  That&rsquo;s gross, and it\nshould look gross.&rdquo;</p>\n\n<h3>Priorities</h3>\n\n<p>The cost of adding this feature is that the mapping from your\n<code>require()</code> statements to the actual file with the code in it, is more\ncomplicated.</p>\n\n<p>Yes, it&rsquo;s &ldquo;only one extra file to look in&rdquo;.  But &ldquo;looking in files&rdquo;\nisn&rsquo;t the hard part.  The hard part is remembering which packages\nmapped in which ways, and thus knowing where to follow the train of\nlogic, when you&rsquo;re juggling a bunch of other peoples&rsquo; code in your\nhead for the first time, while trying to debug a problem as fast as\npossible because it&rsquo;s preventing actual human beings from doing what\nthey are trying to do, and they give exactly zero fucks about the\nugliness of your <code>require()</code> statements.</p>\n\n<p>Adding &ldquo;one extra file to look in&rdquo; doubles the number of files to look\nin, and much more than doubles the cognitive overhead of debugging\nproblems in code you didn&rsquo;t write.</p>\n\n<p>Debugging problems in code you <em>did</em> write is pretty easy.  That&rsquo;s not\nwhat I&rsquo;m talking about.  I&rsquo;m talking about the case where <strong>I&rsquo;m</strong>\ndebugging <strong>your</strong> code, because I&rsquo;m using your module in my website,\nand my website is misbehaving.</p>\n\n<p>If this seems like a trivial complaint, then you have either never\nbeen in this situation, or you are smarter than I am.  Either way,\nconsider yourself blessed, because it&rsquo;s a shitty situation, and I&rsquo;ve\nbeen in it, and I&rsquo;m not smart enough for it to be trivially solved,\nand I wrote most of the code that did all this shit.</p>\n\n<p>Few remember, because the node community was about 1/100th the size at\nthe time, but npm used to support this feature (and also the &ldquo;modules&rdquo;\nhash, which allowed arbitrary mapping of module names to files, and\nwas significantly worse.)  Even fewer people were actually running\nproduction sites at the time in Node, and of those that were, most\njust wrote everything from scratch, because there was much less of an\necosystem to draw on.</p>\n\n<p>Ryan and I were among the people building things in Node at Joyent,\nand trying to actually Do The Right Thing, and use npm and the\ncommunity module ecosystem in the way it was intended.  The first time\nwe had to debug something like this, where <abbr title=\"I don't  remember which ones, sorry\">a few modules</abbr> actually used\n<code>directories.lib</code>, we both were convinced that it was a terrible idea,\nand had to go.</p>\n\n<p>Around that time, we started conceiving the module system for Node\nv0.4, which is what we have now.  We moved the <code>node_modules</code> lookup\nstuff into node core, and stripped out the module hash and\ndirectories.lib features from npm.  Moving <code>node_modules</code> lookup into\ncore meant that npm could stop using symlinks and shims all over the\nplace to implement isolated deps.</p>\n\n<p>Again, if you think that this cost is not relevant, then I have\nnothing but respect and blessings for you.  Either you&rsquo;re much better\nat this stuff than I am, or you&rsquo;ve suffered less of the hell of other\npeoples&rsquo; bugs.  Either way, mad props.</p>\n\n<p>Making the node module system any more complicated than it is will\nmake my life noticeably worse, and I don&rsquo;t think I am alone in this.\nAs I am in a position to prevent that reduction in Node quality of\nlife, and as that is my job, I will prevent it.</p>\n\n<p>The Node module system is\n<a href=\"http://nodejs.org/api/documentation.html#documentation_stability_index\">frozen</a>\nfor a reason.  It will not change to add new features, ever.  It&rsquo;s\ndone, and not open for discussion.</p>\n\n<h3>Addendum:</h3>\n\n<blockquote>\n  <p>@izs Would like to hear more about why omitting the filename\n  extension in require statements was a mistake.</p>\n</blockquote>\n\n<p><i>\u2014 <a href=\"https://twitter.com/jimmycuadra/status/306835283700224000\">jimmycuadra</a></i></p>\n\n<p>Answer:</p>\n\n<p>It quadruples the number of <code>stat(2)</code> calls, makes the 1:1 mapping\nmore vague, and complicates implementation. Slower, greater\ncomplexity, etc.</p>\n\n<p>However, the cost of removing this feature is nowhere near the benefit\nof not having it, so it stays for backwards compatibility.  C'est la vie.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2013-02-27 17:41:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 44149270867,
    "is_blocks_post_format": false,
    "note_count": 8,
    "post_url": "http://blog.izs.me/post/44149270867/why-no-directorieslib-in-node-the-less-snarky",
    "reblog": {
        "comment": "<p>This question comes up in Node occasionally:</p>\n\n<blockquote>\n  <p>Node peoples\u2026 is there any way to specify a root directory for my\n  npm package so that I don\u2019t need require(\u201cmypackage/lib/foo\u201d)?</p>\n</blockquote>\n\n<p><i>\u2014 <a href=\"https://twitter.com/wycats/status/306570718102048768\">wycats</a></i></p>\n\n<p>In other words, you have a package directory structure like this:</p>\n\n<pre><code>./package.json\n./README.md\n./test/some-tests.js\n./lib/main.js  &lt;-- this is the package.json \"main\"\n./lib/some-other-module.js\n./lib/util/a-utility-module.js\n./lib/etc....\n</code></pre>\n\n<p>Now, let\u2019s say that this package\u2019s name is <code>foo</code>.  You want to be able\nto use foo\u2019s <code>some-other-module.js</code> file, outside of foo.</p>\n\n<p>The way to do this in node is do write:</p>\n\n<pre><code>var blah = require('foo/lib/some-other-module.js');\n</code></pre>\n\n<p>What <abbr title=\"and everyone else who requests this, of course\">Yehuda</abbr>\nwould like to see is:</p>\n\n<pre><code>var blah = require('foo/some-other-module.js');\n</code></pre>\n\n<p>The \u201chow\u201d here is simple: If you want a module in the root of your\npackage namespace, put the file in the root of your package folder.\nIt\u2019s a 1:1 mapping, so it\u2019s not hard to figure out how to get that\nresult.</p>\n\n<h3>But I don\u2019t want to have so many files in the root of my package folder</h3>\n\n<p>Ok.  <a href=\"http://howfuckedismydatabase.com/nosql/\" title=\"I believe I did, Bob\">So don\u2019t have so many files in\nthe root of your package folder.</a></p>\n\n<p>If you must export multiple modules from a single package, then you\nhave a choice:</p>\n\n<ol><li>Use an extra 4 characters in your <code>require()</code> statements, or</li>\n<li>Just don\u2019t have so many exports.</li>\n</ol><p>Many of us would suggest that <strong>in general</strong> you may want to consider\nif those things actually are a part of the \u201cfoo\u201d package, or if they\nbelong in a dependency, with their own tests, name, version, etc.</p>\n\n<p>I am not personally so die-hard about \u201cone package = one file\u201d.\nOccasionally there are internal things, and it\u2019s not so bad.  But, <strong>in\ngeneral</strong>, I <strong>tend</strong> to be of the opinion that if a module requires\nits own individual unit tests, it probably should be its own package,\nif only so that I can think of it as a separate thing and give it the\nattention it clearly deserves.  If I\u2019m intending it to be used outside\nof the main package, then it <strong>most likely</strong> needs its own tests, and\nI\u2019ll package it up and make it a dep.</p>\n\n<p>Note all the weasel words in the above paragraph!  There are lots of\nexceptions to this rule.  But they don\u2019t fit on twitter, and in fact,\neven the weasel words put my response way over 140 characters, and\nso with the qualifications stripped out, it looks like a capricious\nreligion, unbound to factual realities of the imperfect world in which\nreal software development happens.</p>\n\n<p>The world being imperfect as it is, you may well find yourself in a\nstate where you have multiple exports, and you don\u2019t have the time or\ninclination to split them up into separate packages.  Sometimes the\nInappropriate Intimacy smell is less bad than the alternatives, it\u2019s\ntrue.  Sometimes it\u2019s just a simple business decision; sometimes it\u2019s\nless important to make it work right, than to make it work right now.</p>\n\n<p>In that case, put <code>\"lib/\"</code> in your <code>require()</code> statement.  It\u2019s not\nthat hard, really.</p>\n\n<h3>But <abbr title=\"see what i did there?\">WHY, cats</abbr>?</h3>\n\n<p>The argument to <code>require()</code> maps directly to a file path.  If it\ndoesn\u2019t start with <code>./</code> or <code>../</code> and isn\u2019t absolute (ie, starts with a\n<code>/</code> on unix, or any of a half dozen weird things on windows), then\nnode finds the closest <code>node_modules</code> folder with a thing by that\nname, and that\u2019s the prefix.  But everything after the prefix is just\na direct filename.</p>\n\n<p><i>(Aside: For historical reasons we do make the filename extension\noptional, which is a deeply regrettable accident of history that I\nwould not repeat, given the chance.)</i></p>\n\n<p>Let\u2019s look at the benefits, and the costs.</p>\n\n<h4>Aesthetics</h4>\n\n<p>The first benefit is removing 4 extra chars in some of the lines at\nthe top of some files.  This is rather small.  Even if you have 100\nrequires at the top of a module (which is very very many), and every\nsingle one of them is diving into some other package\u2019s guts, you\u2019re\nstill talking about pushing the average line <em>length</em> out by 4 chars.\nIt\u2019s not adding extra lines; it\u2019s not pushing the line length out that\nmuch.</p>\n\n<p>If you cannot accept that, then put the files in the root of your\npackage.  If <strong>that</strong> is too ugly, well, then weigh the ugliness of\nfile clutter against the ugliness of lines that are 4 whole characters\nlonger.</p>\n\n<p>The fact that this seems ugly is actually great, in my opinion.  <strong>You\nusually shouldn\u2019t be writing programs like this.</strong>  Packages should be\nexporting an interface that is designed for a purpose, and you should\nbe using them for that purpose.  This is basic software design.</p>\n\n<p>Doing an ugly thing should look ugly.  There may be reasons to do the\nugly thing, of course, and no one is saying that you\u2019re a bad person\nfor doing it, but the ugliness of the code should be a thing that you\nnotice, so that you can avoid ignoring the ugliness of the design.\nThere is a reason we evolved to find plump brightly colored fruit more\nappealing than wrinkled moldy fruit.  There is a reason we evolved to\nbe more able to ignore pleasure than pain.</p>\n\n<p>In other words, your aesthetics are trying to help you.  Saying \u201cit\u2019s\nugly\u201d is an argument <em>against</em> adding this feature, not for it.</p>\n\n<h4>(Alleged) Portability</h4>\n\n<p>Let\u2019s say that you want to have something like this:</p>\n\n<pre><code>./lib/node/module.js\n./lib/browser/module.js\n./lib/ringo/module.js\n./lib/narwhal/module.js\n</code></pre>\n\n<p>Then, I want to say \u201cNode should use <code>lib/node</code>, Ringo should use\n<code>lib/ringo</code>, and the browser should use <code>lib/browser</code>, so when I do\n<code>require('foo/module.js')</code>, I get the right one for my environment.</p>\n\n<p>First of all, that\u2019s very trivial to do without making the mapping of\nrequire arguments to filenames any more complicated.  Create a file\nlike this:</p>\n\n<pre><code>// module.js\nswitch(getPlatform()) {\n  case 'node':\n    module.exports = require('./node/module.js');\n    break;\n  case 'ringo':\n    module.exports = require('./ringo/module.js');\n    break;\n  case 'narwhal':\n    module.exports = require('./narwhal/module.js');\n    break;\n  default:\n    module.exports = require('./browser/module.js');\n    break;\n}\n\n// This can of course be simplified.\n// Usually something like this is sufficient:\n// if (typeof window === 'object')\n//   return module.exports = require('./browser.js');\n</code></pre>\n\n<p>If you find yourself doing this a lot, maybe ask yourself if you\u2019re\nusing the best abstractions, or maybe trying to make something\nportable that is fundamentally platform-specific.  Maybe try\nsupporting fewer platforms.</p>\n\n<p>Or, maybe, just do the ugly thing, and let it be ugly, and accept that\nit\u2019s a net benefit in your case.  But if your request is \"Make\nplatform-specific module behavior forking less ugly\u201d, then we\u2019re back\nto aesthetics, and my answer is, \u201cEw.  No.  That\u2019s gross, and it\nshould look gross.\u201d</p>\n\n<h3>Priorities</h3>\n\n<p>The cost of adding this feature is that the mapping from your\n<code>require()</code> statements to the actual file with the code in it, is more\ncomplicated.</p>\n\n<p>Yes, it\u2019s \u201conly one extra file to look in\u201d.  But \u201clooking in files\u201d\nisn\u2019t the hard part.  The hard part is remembering which packages\nmapped in which ways, and thus knowing where to follow the train of\nlogic, when you\u2019re juggling a bunch of other peoples\u2019 code in your\nhead for the first time, while trying to debug a problem as fast as\npossible because it\u2019s preventing actual human beings from doing what\nthey are trying to do, and they give exactly zero fucks about the\nugliness of your <code>require()</code> statements.</p>\n\n<p>Adding \u201cone extra file to look in\u201d doubles the number of files to look\nin, and much more than doubles the cognitive overhead of debugging\nproblems in code you didn\u2019t write.</p>\n\n<p>Debugging problems in code you <em>did</em> write is pretty easy.  That\u2019s not\nwhat I\u2019m talking about.  I\u2019m talking about the case where <strong>I\u2019m</strong>\ndebugging <strong>your</strong> code, because I\u2019m using your module in my website,\nand my website is misbehaving.</p>\n\n<p>If this seems like a trivial complaint, then you have either never\nbeen in this situation, or you are smarter than I am.  Either way,\nconsider yourself blessed, because it\u2019s a shitty situation, and I\u2019ve\nbeen in it, and I\u2019m not smart enough for it to be trivially solved,\nand I wrote most of the code that did all this shit.</p>\n\n<p>Few remember, because the node community was about 1/100th the size at\nthe time, but npm used to support this feature (and also the \u201cmodules\u201d\nhash, which allowed arbitrary mapping of module names to files, and\nwas significantly worse.)  Even fewer people were actually running\nproduction sites at the time in Node, and of those that were, most\njust wrote everything from scratch, because there was much less of an\necosystem to draw on.</p>\n\n<p>Ryan and I were among the people building things in Node at Joyent,\nand trying to actually Do The Right Thing, and use npm and the\ncommunity module ecosystem in the way it was intended.  The first time\nwe had to debug something like this, where <abbr title=\"I don't  remember which ones, sorry\">a few modules</abbr> actually used\n<code>directories.lib</code>, we both were convinced that it was a terrible idea,\nand had to go.</p>\n\n<p>Around that time, we started conceiving the module system for Node\nv0.4, which is what we have now.  We moved the <code>node_modules</code> lookup\nstuff into node core, and stripped out the module hash and\ndirectories.lib features from npm.  Moving <code>node_modules</code> lookup into\ncore meant that npm could stop using symlinks and shims all over the\nplace to implement isolated deps.</p>\n\n<p>Again, if you think that this cost is not relevant, then I have\nnothing but respect and blessings for you.  Either you\u2019re much better\nat this stuff than I am, or you\u2019ve suffered less of the hell of other\npeoples\u2019 bugs.  Either way, mad props.</p>\n\n<p>Making the node module system any more complicated than it is will\nmake my life noticeably worse, and I don\u2019t think I am alone in this.\nAs I am in a position to prevent that reduction in Node quality of\nlife, and as that is my job, I will prevent it.</p>\n\n<p>The Node module system is\n<a href=\"http://nodejs.org/api/documentation.html#documentation_stability_index\">frozen</a>\nfor a reason.  It will not change to add new features, ever.  It\u2019s\ndone, and not open for discussion.</p>\n\n<h3>Addendum:</h3>\n\n<blockquote>\n  <p>@izs Would like to hear more about why omitting the filename\n  extension in require statements was a mistake.</p>\n</blockquote>\n\n<p><i>\u2014 <a href=\"https://twitter.com/jimmycuadra/status/306835283700224000\">jimmycuadra</a></i></p>\n\n<p>Answer:</p>\n\n<p>It quadruples the number of <code>stat(2)</code> calls, makes the 1:1 mapping\nmore vague, and complicates implementation. Slower, greater\ncomplexity, etc.</p>\n\n<p>However, the cost of removing this feature is nowhere near the benefit\nof not having it, so it stays for backwards compatibility.  C'est la vie.</p>",
        "tree_html": ""
    },
    "reblog_key": "fLMgA9T2",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWyf7W6bJ",
    "slug": "why-no-directorieslib-in-node-the-less-snarky",
    "state": "published",
    "summary": "Why No directories.lib in Node (the less snarky, too-long-for-twitter version)",
    "tags": [],
    "timestamp": 1361986860,
    "title": "Why No directories.lib in Node (the less snarky, too-long-for-twitter version)",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>This question comes up in Node occasionally:</p>\n\n<blockquote>\n  <p>Node peoples&hellip; is there any way to specify a root directory for my\n  npm package so that I don&rsquo;t need require(&ldquo;mypackage/lib/foo&rdquo;)?</p>\n</blockquote>\n\n<p><i>&mdash; <a href=\"https://twitter.com/wycats/status/306570718102048768\">wycats</a></i></p>\n\n<p>In other words, you have a package directory structure like this:</p>\n\n<pre><code>./package.json\n./README.md\n./test/some-tests.js\n./lib/main.js  &lt;-- this is the package.json \"main\"\n./lib/some-other-module.js\n./lib/util/a-utility-module.js\n./lib/etc....\n</code></pre>\n\n<p>Now, let&rsquo;s say that this package&rsquo;s name is <code>foo</code>.  You want to be able\nto use foo&rsquo;s <code>some-other-module.js</code> file, outside of foo.</p>\n\n<p>The way to do this in node is do write:</p>\n\n<pre><code>var blah = require('foo/lib/some-other-module.js');\n</code></pre>\n\n<p>What Yehuda\nwould like to see is:</p>\n\n<pre><code>var blah = require('foo/some-other-module.js');\n</code></pre>\n\n<p>The &ldquo;how&rdquo; here is simple: If you want a module in the root of your\npackage namespace, put the file in the root of your package folder.\nIt&rsquo;s a 1:1 mapping, so it&rsquo;s not hard to figure out how to get that\nresult.</p>\n\n<h3>But I don&rsquo;t want to have so many files in the root of my package folder</h3>\n\n<p>Ok.  <a href=\"http://howfuckedismydatabase.com/nosql/\" title=\"I believe I did, Bob\">So don&rsquo;t have so many files in\nthe root of your package folder.</a></p>\n\n<p>If you must export multiple modules from a single package, then you\nhave a choice:</p>\n\n<ol><li>Use an extra 4 characters in your <code>require()</code> statements, or</li>\n<li>Just don&rsquo;t have so many exports.</li>\n</ol><p>Many of us would suggest that <strong>in general</strong> you may want to consider\nif those things actually are a part of the &ldquo;foo&rdquo; package, or if they\nbelong in a dependency, with their own tests, name, version, etc.</p>\n\n<p>I am not personally so die-hard about &ldquo;one package = one file&rdquo;.\nOccasionally there are internal things, and it&rsquo;s not so bad.  But, <strong>in\ngeneral</strong>, I <strong>tend</strong> to be of the opinion that if a module requires\nits own individual unit tests, it probably should be its own package,\nif only so that I can think of it as a separate thing and give it the\nattention it clearly deserves.  If I&rsquo;m intending it to be used outside\nof the main package, then it <strong>most likely</strong> needs its own tests, and\nI&rsquo;ll package it up and make it a dep.</p>\n\n<p>Note all the weasel words in the above paragraph!  There are lots of\nexceptions to this rule.  But they don&rsquo;t fit on twitter, and in fact,\neven the weasel words put my response way over 140 characters, and\nso with the qualifications stripped out, it looks like a capricious\nreligion, unbound to factual realities of the imperfect world in which\nreal software development happens.</p>\n\n<p>The world being imperfect as it is, you may well find yourself in a\nstate where you have multiple exports, and you don&rsquo;t have the time or\ninclination to split them up into separate packages.  Sometimes the\nInappropriate Intimacy smell is less bad than the alternatives, it&rsquo;s\ntrue.  Sometimes it&rsquo;s just a simple business decision; sometimes it&rsquo;s\nless important to make it work right, than to make it work right now.</p>\n\n<p>In that case, put <code>\"lib/\"</code> in your <code>require()</code> statement.  It&rsquo;s not\nthat hard, really.</p>\n\n<h3>But WHY, cats?</h3>\n\n<p>The argument to <code>require()</code> maps directly to a file path.  If it\ndoesn&rsquo;t start with <code>./</code> or <code>../</code> and isn&rsquo;t absolute (ie, starts with a\n<code>/</code> on unix, or any of a half dozen weird things on windows), then\nnode finds the closest <code>node_modules</code> folder with a thing by that\nname, and that&rsquo;s the prefix.  But everything after the prefix is just\na direct filename.</p>\n\n<p><i>(Aside: For historical reasons we do make the filename extension\noptional, which is a deeply regrettable accident of history that I\nwould not repeat, given the chance.)</i></p>\n\n<p>Let&rsquo;s look at the benefits, and the costs.</p>\n\n<h4>Aesthetics</h4>\n\n<p>The first benefit is removing 4 extra chars in some of the lines at\nthe top of some files.  This is rather small.  Even if you have 100\nrequires at the top of a module (which is very very many), and every\nsingle one of them is diving into some other package&rsquo;s guts, you&rsquo;re\nstill talking about pushing the average line <em>length</em> out by 4 chars.\nIt&rsquo;s not adding extra lines; it&rsquo;s not pushing the line length out that\nmuch.</p>\n\n<p>If you cannot accept that, then put the files in the root of your\npackage.  If <strong>that</strong> is too ugly, well, then weigh the ugliness of\nfile clutter against the ugliness of lines that are 4 whole characters\nlonger.</p>\n\n<p>The fact that this seems ugly is actually great, in my opinion.  <strong>You\nusually shouldn&rsquo;t be writing programs like this.</strong>  Packages should be\nexporting an interface that is designed for a purpose, and you should\nbe using them for that purpose.  This is basic software design.</p>\n\n<p>Doing an ugly thing should look ugly.  There may be reasons to do the\nugly thing, of course, and no one is saying that you&rsquo;re a bad person\nfor doing it, but the ugliness of the code should be a thing that you\nnotice, so that you can avoid ignoring the ugliness of the design.\nThere is a reason we evolved to find plump brightly colored fruit more\nappealing than wrinkled moldy fruit.  There is a reason we evolved to\nbe more able to ignore pleasure than pain.</p>\n\n<p>In other words, your aesthetics are trying to help you.  Saying &ldquo;it&rsquo;s\nugly&rdquo; is an argument <em>against</em> adding this feature, not for it.</p>\n\n<h4>(Alleged) Portability</h4>\n\n<p>Let&rsquo;s say that you want to have something like this:</p>\n\n<pre><code>./lib/node/module.js\n./lib/browser/module.js\n./lib/ringo/module.js\n./lib/narwhal/module.js\n</code></pre>\n\n<p>Then, I want to say &ldquo;Node should use <code>lib/node</code>, Ringo should use\n<code>lib/ringo</code>, and the browser should use <code>lib/browser</code>, so when I do\n<code>require('foo/module.js')</code>, I get the right one for my environment.</p>\n\n<p>First of all, that&rsquo;s very trivial to do without making the mapping of\nrequire arguments to filenames any more complicated.  Create a file\nlike this:</p>\n\n<pre><code>// module.js\nswitch(getPlatform()) {\n  case 'node':\n    module.exports = require('./node/module.js');\n    break;\n  case 'ringo':\n    module.exports = require('./ringo/module.js');\n    break;\n  case 'narwhal':\n    module.exports = require('./narwhal/module.js');\n    break;\n  default:\n    module.exports = require('./browser/module.js');\n    break;\n}\n\n// This can of course be simplified.\n// Usually something like this is sufficient:\n// if (typeof window === 'object')\n//   return module.exports = require('./browser.js');\n</code></pre>\n\n<p>If you find yourself doing this a lot, maybe ask yourself if you&rsquo;re\nusing the best abstractions, or maybe trying to make something\nportable that is fundamentally platform-specific.  Maybe try\nsupporting fewer platforms.</p>\n\n<p>Or, maybe, just do the ugly thing, and let it be ugly, and accept that\nit&rsquo;s a net benefit in your case.  But if your request is \"Make\nplatform-specific module behavior forking less ugly&rdquo;, then we&rsquo;re back\nto aesthetics, and my answer is, &ldquo;Ew.  No.  That&rsquo;s gross, and it\nshould look gross.&rdquo;</p>\n\n<h3>Priorities</h3>\n\n<p>The cost of adding this feature is that the mapping from your\n<code>require()</code> statements to the actual file with the code in it, is more\ncomplicated.</p>\n\n<p>Yes, it&rsquo;s &ldquo;only one extra file to look in&rdquo;.  But &ldquo;looking in files&rdquo;\nisn&rsquo;t the hard part.  The hard part is remembering which packages\nmapped in which ways, and thus knowing where to follow the train of\nlogic, when you&rsquo;re juggling a bunch of other peoples&rsquo; code in your\nhead for the first time, while trying to debug a problem as fast as\npossible because it&rsquo;s preventing actual human beings from doing what\nthey are trying to do, and they give exactly zero fucks about the\nugliness of your <code>require()</code> statements.</p>\n\n<p>Adding &ldquo;one extra file to look in&rdquo; doubles the number of files to look\nin, and much more than doubles the cognitive overhead of debugging\nproblems in code you didn&rsquo;t write.</p>\n\n<p>Debugging problems in code you <em>did</em> write is pretty easy.  That&rsquo;s not\nwhat I&rsquo;m talking about.  I&rsquo;m talking about the case where <strong>I&rsquo;m</strong>\ndebugging <strong>your</strong> code, because I&rsquo;m using your module in my website,\nand my website is misbehaving.</p>\n\n<p>If this seems like a trivial complaint, then you have either never\nbeen in this situation, or you are smarter than I am.  Either way,\nconsider yourself blessed, because it&rsquo;s a shitty situation, and I&rsquo;ve\nbeen in it, and I&rsquo;m not smart enough for it to be trivially solved,\nand I wrote most of the code that did all this shit.</p>\n\n<p>Few remember, because the node community was about 1/100th the size at\nthe time, but npm used to support this feature (and also the &ldquo;modules&rdquo;\nhash, which allowed arbitrary mapping of module names to files, and\nwas significantly worse.)  Even fewer people were actually running\nproduction sites at the time in Node, and of those that were, most\njust wrote everything from scratch, because there was much less of an\necosystem to draw on.</p>\n\n<p>Ryan and I were among the people building things in Node at Joyent,\nand trying to actually Do The Right Thing, and use npm and the\ncommunity module ecosystem in the way it was intended.  The first time\nwe had to debug something like this, where a few modules actually used\n<code>directories.lib</code>, we both were convinced that it was a terrible idea,\nand had to go.</p>\n\n<p>Around that time, we started conceiving the module system for Node\nv0.4, which is what we have now.  We moved the <code>node_modules</code> lookup\nstuff into node core, and stripped out the module hash and\ndirectories.lib features from npm.  Moving <code>node_modules</code> lookup into\ncore meant that npm could stop using symlinks and shims all over the\nplace to implement isolated deps.</p>\n\n<p>Again, if you think that this cost is not relevant, then I have\nnothing but respect and blessings for you.  Either you&rsquo;re much better\nat this stuff than I am, or you&rsquo;ve suffered less of the hell of other\npeoples&rsquo; bugs.  Either way, mad props.</p>\n\n<p>Making the node module system any more complicated than it is will\nmake my life noticeably worse, and I don&rsquo;t think I am alone in this.\nAs I am in a position to prevent that reduction in Node quality of\nlife, and as that is my job, I will prevent it.</p>\n\n<p>The Node module system is\n<a href=\"http://nodejs.org/api/documentation.html#documentation_stability_index\">frozen</a>\nfor a reason.  It will not change to add new features, ever.  It&rsquo;s\ndone, and not open for discussion.</p>\n\n<h3>Addendum:</h3>\n\n<blockquote>\n  <p>@izs Would like to hear more about why omitting the filename\n  extension in require statements was a mistake.</p>\n</blockquote>\n\n<p><i>&mdash; <a href=\"https://twitter.com/jimmycuadra/status/306835283700224000\">jimmycuadra</a></i></p>\n\n<p>Answer:</p>\n\n<p>It quadruples the number of <code>stat(2)</code> calls, makes the 1:1 mapping\nmore vague, and complicates implementation. Slower, greater\ncomplexity, etc.</p>\n\n<p>However, the cost of removing this feature is nowhere near the benefit\nof not having it, so it stays for backwards compatibility.  C'est la vie.</p>",
            "content_raw": "<p>This question comes up in Node occasionally:</p>\n\n<blockquote>\n  <p>Node peoples\u2026 is there any way to specify a root directory for my\n  npm package so that I don\u2019t need require(\u201cmypackage/lib/foo\u201d)?</p>\n</blockquote>\n\n<p><i>\u2014 <a href=\"https://twitter.com/wycats/status/306570718102048768\">wycats</a></i></p>\n\n<p>In other words, you have a package directory structure like this:</p>\n\n<pre><code>./package.json\n./README.md\n./test/some-tests.js\n./lib/main.js  &lt;-- this is the package.json \"main\"\n./lib/some-other-module.js\n./lib/util/a-utility-module.js\n./lib/etc....\n</code></pre>\n\n<p>Now, let\u2019s say that this package\u2019s name is <code>foo</code>.  You want to be able\nto use foo\u2019s <code>some-other-module.js</code> file, outside of foo.</p>\n\n<p>The way to do this in node is do write:</p>\n\n<pre><code>var blah = require('foo/lib/some-other-module.js');\n</code></pre>\n\n<p>What <abbr title=\"and everyone else who requests this, of course\">Yehuda</abbr>\nwould like to see is:</p>\n\n<pre><code>var blah = require('foo/some-other-module.js');\n</code></pre>\n\n<p>The \u201chow\u201d here is simple: If you want a module in the root of your\npackage namespace, put the file in the root of your package folder.\nIt\u2019s a 1:1 mapping, so it\u2019s not hard to figure out how to get that\nresult.</p>\n\n<h3>But I don\u2019t want to have so many files in the root of my package folder</h3>\n\n<p>Ok.  <a href=\"http://howfuckedismydatabase.com/nosql/\" title=\"I believe I did, Bob\">So don\u2019t have so many files in\nthe root of your package folder.</a></p>\n\n<p>If you must export multiple modules from a single package, then you\nhave a choice:</p>\n\n<ol><li>Use an extra 4 characters in your <code>require()</code> statements, or</li>\n<li>Just don\u2019t have so many exports.</li>\n</ol><p>Many of us would suggest that <strong>in general</strong> you may want to consider\nif those things actually are a part of the \u201cfoo\u201d package, or if they\nbelong in a dependency, with their own tests, name, version, etc.</p>\n\n<p>I am not personally so die-hard about \u201cone package = one file\u201d.\nOccasionally there are internal things, and it\u2019s not so bad.  But, <strong>in\ngeneral</strong>, I <strong>tend</strong> to be of the opinion that if a module requires\nits own individual unit tests, it probably should be its own package,\nif only so that I can think of it as a separate thing and give it the\nattention it clearly deserves.  If I\u2019m intending it to be used outside\nof the main package, then it <strong>most likely</strong> needs its own tests, and\nI\u2019ll package it up and make it a dep.</p>\n\n<p>Note all the weasel words in the above paragraph!  There are lots of\nexceptions to this rule.  But they don\u2019t fit on twitter, and in fact,\neven the weasel words put my response way over 140 characters, and\nso with the qualifications stripped out, it looks like a capricious\nreligion, unbound to factual realities of the imperfect world in which\nreal software development happens.</p>\n\n<p>The world being imperfect as it is, you may well find yourself in a\nstate where you have multiple exports, and you don\u2019t have the time or\ninclination to split them up into separate packages.  Sometimes the\nInappropriate Intimacy smell is less bad than the alternatives, it\u2019s\ntrue.  Sometimes it\u2019s just a simple business decision; sometimes it\u2019s\nless important to make it work right, than to make it work right now.</p>\n\n<p>In that case, put <code>\"lib/\"</code> in your <code>require()</code> statement.  It\u2019s not\nthat hard, really.</p>\n\n<h3>But <abbr title=\"see what i did there?\">WHY, cats</abbr>?</h3>\n\n<p>The argument to <code>require()</code> maps directly to a file path.  If it\ndoesn\u2019t start with <code>./</code> or <code>../</code> and isn\u2019t absolute (ie, starts with a\n<code>/</code> on unix, or any of a half dozen weird things on windows), then\nnode finds the closest <code>node_modules</code> folder with a thing by that\nname, and that\u2019s the prefix.  But everything after the prefix is just\na direct filename.</p>\n\n<p><i>(Aside: For historical reasons we do make the filename extension\noptional, which is a deeply regrettable accident of history that I\nwould not repeat, given the chance.)</i></p>\n\n<p>Let\u2019s look at the benefits, and the costs.</p>\n\n<h4>Aesthetics</h4>\n\n<p>The first benefit is removing 4 extra chars in some of the lines at\nthe top of some files.  This is rather small.  Even if you have 100\nrequires at the top of a module (which is very very many), and every\nsingle one of them is diving into some other package\u2019s guts, you\u2019re\nstill talking about pushing the average line <em>length</em> out by 4 chars.\nIt\u2019s not adding extra lines; it\u2019s not pushing the line length out that\nmuch.</p>\n\n<p>If you cannot accept that, then put the files in the root of your\npackage.  If <strong>that</strong> is too ugly, well, then weigh the ugliness of\nfile clutter against the ugliness of lines that are 4 whole characters\nlonger.</p>\n\n<p>The fact that this seems ugly is actually great, in my opinion.  <strong>You\nusually shouldn\u2019t be writing programs like this.</strong>  Packages should be\nexporting an interface that is designed for a purpose, and you should\nbe using them for that purpose.  This is basic software design.</p>\n\n<p>Doing an ugly thing should look ugly.  There may be reasons to do the\nugly thing, of course, and no one is saying that you\u2019re a bad person\nfor doing it, but the ugliness of the code should be a thing that you\nnotice, so that you can avoid ignoring the ugliness of the design.\nThere is a reason we evolved to find plump brightly colored fruit more\nappealing than wrinkled moldy fruit.  There is a reason we evolved to\nbe more able to ignore pleasure than pain.</p>\n\n<p>In other words, your aesthetics are trying to help you.  Saying \u201cit\u2019s\nugly\u201d is an argument <em>against</em> adding this feature, not for it.</p>\n\n<h4>(Alleged) Portability</h4>\n\n<p>Let\u2019s say that you want to have something like this:</p>\n\n<pre><code>./lib/node/module.js\n./lib/browser/module.js\n./lib/ringo/module.js\n./lib/narwhal/module.js\n</code></pre>\n\n<p>Then, I want to say \u201cNode should use <code>lib/node</code>, Ringo should use\n<code>lib/ringo</code>, and the browser should use <code>lib/browser</code>, so when I do\n<code>require('foo/module.js')</code>, I get the right one for my environment.</p>\n\n<p>First of all, that\u2019s very trivial to do without making the mapping of\nrequire arguments to filenames any more complicated.  Create a file\nlike this:</p>\n\n<pre><code>// module.js\nswitch(getPlatform()) {\n  case 'node':\n    module.exports = require('./node/module.js');\n    break;\n  case 'ringo':\n    module.exports = require('./ringo/module.js');\n    break;\n  case 'narwhal':\n    module.exports = require('./narwhal/module.js');\n    break;\n  default:\n    module.exports = require('./browser/module.js');\n    break;\n}\n\n// This can of course be simplified.\n// Usually something like this is sufficient:\n// if (typeof window === 'object')\n//   return module.exports = require('./browser.js');\n</code></pre>\n\n<p>If you find yourself doing this a lot, maybe ask yourself if you\u2019re\nusing the best abstractions, or maybe trying to make something\nportable that is fundamentally platform-specific.  Maybe try\nsupporting fewer platforms.</p>\n\n<p>Or, maybe, just do the ugly thing, and let it be ugly, and accept that\nit\u2019s a net benefit in your case.  But if your request is \"Make\nplatform-specific module behavior forking less ugly\u201d, then we\u2019re back\nto aesthetics, and my answer is, \u201cEw.  No.  That\u2019s gross, and it\nshould look gross.\u201d</p>\n\n<h3>Priorities</h3>\n\n<p>The cost of adding this feature is that the mapping from your\n<code>require()</code> statements to the actual file with the code in it, is more\ncomplicated.</p>\n\n<p>Yes, it\u2019s \u201conly one extra file to look in\u201d.  But \u201clooking in files\u201d\nisn\u2019t the hard part.  The hard part is remembering which packages\nmapped in which ways, and thus knowing where to follow the train of\nlogic, when you\u2019re juggling a bunch of other peoples\u2019 code in your\nhead for the first time, while trying to debug a problem as fast as\npossible because it\u2019s preventing actual human beings from doing what\nthey are trying to do, and they give exactly zero fucks about the\nugliness of your <code>require()</code> statements.</p>\n\n<p>Adding \u201cone extra file to look in\u201d doubles the number of files to look\nin, and much more than doubles the cognitive overhead of debugging\nproblems in code you didn\u2019t write.</p>\n\n<p>Debugging problems in code you <em>did</em> write is pretty easy.  That\u2019s not\nwhat I\u2019m talking about.  I\u2019m talking about the case where <strong>I\u2019m</strong>\ndebugging <strong>your</strong> code, because I\u2019m using your module in my website,\nand my website is misbehaving.</p>\n\n<p>If this seems like a trivial complaint, then you have either never\nbeen in this situation, or you are smarter than I am.  Either way,\nconsider yourself blessed, because it\u2019s a shitty situation, and I\u2019ve\nbeen in it, and I\u2019m not smart enough for it to be trivially solved,\nand I wrote most of the code that did all this shit.</p>\n\n<p>Few remember, because the node community was about 1/100th the size at\nthe time, but npm used to support this feature (and also the \u201cmodules\u201d\nhash, which allowed arbitrary mapping of module names to files, and\nwas significantly worse.)  Even fewer people were actually running\nproduction sites at the time in Node, and of those that were, most\njust wrote everything from scratch, because there was much less of an\necosystem to draw on.</p>\n\n<p>Ryan and I were among the people building things in Node at Joyent,\nand trying to actually Do The Right Thing, and use npm and the\ncommunity module ecosystem in the way it was intended.  The first time\nwe had to debug something like this, where <abbr title=\"I don't  remember which ones, sorry\">a few modules</abbr> actually used\n<code>directories.lib</code>, we both were convinced that it was a terrible idea,\nand had to go.</p>\n\n<p>Around that time, we started conceiving the module system for Node\nv0.4, which is what we have now.  We moved the <code>node_modules</code> lookup\nstuff into node core, and stripped out the module hash and\ndirectories.lib features from npm.  Moving <code>node_modules</code> lookup into\ncore meant that npm could stop using symlinks and shims all over the\nplace to implement isolated deps.</p>\n\n<p>Again, if you think that this cost is not relevant, then I have\nnothing but respect and blessings for you.  Either you\u2019re much better\nat this stuff than I am, or you\u2019ve suffered less of the hell of other\npeoples\u2019 bugs.  Either way, mad props.</p>\n\n<p>Making the node module system any more complicated than it is will\nmake my life noticeably worse, and I don\u2019t think I am alone in this.\nAs I am in a position to prevent that reduction in Node quality of\nlife, and as that is my job, I will prevent it.</p>\n\n<p>The Node module system is\n<a href=\"http://nodejs.org/api/documentation.html#documentation_stability_index\">frozen</a>\nfor a reason.  It will not change to add new features, ever.  It\u2019s\ndone, and not open for discussion.</p>\n\n<h3>Addendum:</h3>\n\n<blockquote>\n  <p>@izs Would like to hear more about why omitting the filename\n  extension in require statements was a mistake.</p>\n</blockquote>\n\n<p><i>\u2014 <a href=\"https://twitter.com/jimmycuadra/status/306835283700224000\">jimmycuadra</a></i></p>\n\n<p>Answer:</p>\n\n<p>It quadruples the number of <code>stat(2)</code> calls, makes the 1:1 mapping\nmore vague, and complicates implementation. Slower, greater\ncomplexity, etc.</p>\n\n<p>However, the cost of removing this feature is nowhere near the benefit\nof not having it, so it stays for backwards compatibility.  C'est la vie.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "44149270867"
            }
        }
    ],
    "type": "text"
}