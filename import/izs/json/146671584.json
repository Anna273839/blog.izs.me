{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>For the last several years, there&rsquo;s been a lot of talk about why web standards are generally a good thing.  And I agree with the vast majority of it.  Writing clean code that sticks to a widely accepted standard is a very good way to help the future programmers who will invariably be touching your stuff once you&rsquo;re gone (or yourself fixing a bug next month or year later.)  In this sense, web standards are a sort of &ldquo;kindness in coding.&rdquo;</p>\n\n<p>However, as with the <abbr title=\"object oriented programming\">OOP</abbr> zealotry that started 20 years ago and is still going strong today, this set of very useful guidelines has turned into a movement.  It has gained enough followers and momentum, and in many cases, seems to have become and End In Itself.</p>\n\n<p>Movements are like organisms.  They survive because the cells that make them up all continually and unthinkingly chant the mantras and make the arguments.  Ideas can be good.  Critically examining them is good.  Being passionate about a good idea is good.  But movements, more often than not, become problematic.</p>\n\n<p>Software is the most complicated thing that humans build, and we haven&rsquo;t really figured it out.  You could even make the argument that we probably never will fully figure out how to create software in a way that doesn&rsquo;t suck to some degree.  That&rsquo;s not to say we don&rsquo;t create some great software, great websites, great programs, etc.  But there are <em>always</em> bugs, and delays, and general chaos along the way, and I believe that there always will be.  The process involves an unknown number of unknowns.  Software is more complicated than the human brain can handle, and that&rsquo;s the only kind of brain that we have.</p>\n\n<p>So, how do you solve a problem when you don&rsquo;t know all the factors, and only have a vague idea of what success looks like?  It&rsquo;s like climbing a mountain when you can&rsquo;t see the top.  You can still see the slope, and can occasionally get glimpses of where you&rsquo;re going, or at least, you know that it&rsquo;s higher up.  If we are to approach quality software, then we must treat this exceedingly complicated problem in a manner that at least <em>approaches</em> quality heuristically, perhaps organically.</p>\n\n<p>Software is a process of making decisions, and then codifying and saving those decisions.  Bad decisions must be pruned ruthlessly, and good ones must be recognized and reused.  In a general sense, this is the heuristic that leads to quality software (or quality <em>anything</em> for that matter.)  The question of what makes a decision &ldquo;good&rdquo; or &ldquo;bad&rdquo; is itself a decision that needs continual evaluation.  And <em>that&rsquo;s</em> where movements get into trouble.</p>\n\n<p>It&rsquo;s easy to say, <q>If it conforms with the w3c&rsquo;s (or Microsoft&rsquo;s or whoever&rsquo;s) standards, then it&rsquo;s good.</q>  I think that this might be a good start, but it&rsquo;s basically an <a href=\"http://en.wikipedia.org/wiki/Appeal_to_authority\">argument from authority</a>.  The w3c is a group of humans.  So is Microsoft.  Humans make mistakes, and have plenty of limitations; that&rsquo;s why we need a heuristic in the first place.</p>\n\n<p>It&rsquo;s also easy to say, <q>If it loads fast and looks right, then it&rsquo;s good.</q>  Sure, but how easy is it to debug it when it doesn&rsquo;t work as expected?  Can new developers add to it easily?  Is it expensive to maintain or re-purpose?</p>\n\n<p>Or, even worse, <q>This was written in (Rails, VB, Django, PHP, C#, valid CSS) so it&rsquo;s good.</q>  I think that a lot of the worst examples of Microsoft horrors were the result of a fanatical attachment to Visual Basic.  I&rsquo;ve seen (ok, &ldquo;written&rdquo;) some terrible CSS that was, nonetheless, technically &ldquo;valid&rdquo; according to the W3C&rsquo;s validator.</p>\n\n<p>Sadly, most developers judge decisions based on their feelings rather than any kind of objective analysis.  <q>I wrote this, and it&rsquo;s clever, and it makes me happy, so it&rsquo;s good.</q>  There is no surer way to end up with a pile of garbage than this approach.  It&rsquo;s hard to let go of something that you worked on, and coders are certainly not the only culprits.  I&rsquo;ve seen execs spend countless hours on a deal that never yielded any value for the company, and designers fight tooth and nail for a visual approach that just didn&rsquo;t work.  Hell, we all have a relative or two with a recipe for something that they love, but which everyone knows is terribly bland.</p>\n\n<p>It&rsquo;s really <em>really</em> hard to let go of this emotional attachment to work.  The reason we feel good when we succeed is that our emotions are attached to our work.  It&rsquo;s why I get up in the morning.  But it&rsquo;s better to attach your feelings to how harsh you are on your code.  Understand that we all write terrible code, but that the difference between bad and good is that good coders recognize this fact and deal with it.</p>\n\n<p>Because of the incredible complexity in software development of any kind, there simply is no room for mindless zealotry or attachment to a movement.  Every project, every site, every module is a little different, and has a slightly different standard of quality.  (Even the rule &ldquo;always head upwards&rdquo; doesn&rsquo;t work for climbing all kinds of mountains.)  Keep the goal in mind, and think about the best way to get there.  Sometimes it&rsquo;ll be the accepted standards, hell most of the time it probably will be, but sometimes it might not.  It&rsquo;s our job to know the difference.</p>\n\n<p>Every once in a while, take a moment to re-evaluate your methods for evaluating the quality of your code.  You may have to let go of something comfortable, and it may sting, but in the end, you&rsquo;ll be better at what you do.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2007-07-16 17:34:31 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 146671584,
    "is_blocks_post_format": false,
    "note_count": 0,
    "post_url": "http://blog.izs.me/post/146671584/theres-no-room-for-ego-or-zealotry-in-software",
    "reblog": {
        "comment": "<p>For the last several years, there\u2019s been a lot of talk about why web standards are generally a good thing.  And I agree with the vast majority of it.  Writing clean code that sticks to a widely accepted standard is a very good way to help the future programmers who will invariably be touching your stuff once you\u2019re gone (or yourself fixing a bug next month or year later.)  In this sense, web standards are a sort of \u201ckindness in coding.\u201d</p>\n\n<p>However, as with the <abbr title=\"object oriented programming\">OOP</abbr> zealotry that started 20 years ago and is still going strong today, this set of very useful guidelines has turned into a movement.  It has gained enough followers and momentum, and in many cases, seems to have become and End In Itself.</p>\n\n<p>Movements are like organisms.  They survive because the cells that make them up all continually and unthinkingly chant the mantras and make the arguments.  Ideas can be good.  Critically examining them is good.  Being passionate about a good idea is good.  But movements, more often than not, become problematic.</p>\n\n<p>Software is the most complicated thing that humans build, and we haven\u2019t really figured it out.  You could even make the argument that we probably never will fully figure out how to create software in a way that doesn\u2019t suck to some degree.  That\u2019s not to say we don\u2019t create some great software, great websites, great programs, etc.  But there are <em>always</em> bugs, and delays, and general chaos along the way, and I believe that there always will be.  The process involves an unknown number of unknowns.  Software is more complicated than the human brain can handle, and that\u2019s the only kind of brain that we have.</p>\n\n<p>So, how do you solve a problem when you don\u2019t know all the factors, and only have a vague idea of what success looks like?  It\u2019s like climbing a mountain when you can\u2019t see the top.  You can still see the slope, and can occasionally get glimpses of where you\u2019re going, or at least, you know that it\u2019s higher up.  If we are to approach quality software, then we must treat this exceedingly complicated problem in a manner that at least <em>approaches</em> quality heuristically, perhaps organically.</p>\n\n<p>Software is a process of making decisions, and then codifying and saving those decisions.  Bad decisions must be pruned ruthlessly, and good ones must be recognized and reused.  In a general sense, this is the heuristic that leads to quality software (or quality <em>anything</em> for that matter.)  The question of what makes a decision \u201cgood\u201d or \u201cbad\u201d is itself a decision that needs continual evaluation.  And <em>that\u2019s</em> where movements get into trouble.</p>\n\n<p>It\u2019s easy to say, <q>If it conforms with the w3c\u2019s (or Microsoft\u2019s or whoever\u2019s) standards, then it\u2019s good.</q>  I think that this might be a good start, but it\u2019s basically an <a href=\"http://en.wikipedia.org/wiki/Appeal_to_authority\">argument from authority</a>.  The w3c is a group of humans.  So is Microsoft.  Humans make mistakes, and have plenty of limitations; that\u2019s why we need a heuristic in the first place.</p>\n\n<p>It\u2019s also easy to say, <q>If it loads fast and looks right, then it\u2019s good.</q>  Sure, but how easy is it to debug it when it doesn\u2019t work as expected?  Can new developers add to it easily?  Is it expensive to maintain or re-purpose?</p>\n\n<p>Or, even worse, <q>This was written in (Rails, VB, Django, PHP, C#, valid CSS) so it\u2019s good.</q>  I think that a lot of the worst examples of Microsoft horrors were the result of a fanatical attachment to Visual Basic.  I\u2019ve seen (ok, \u201cwritten\u201d) some terrible CSS that was, nonetheless, technically \u201cvalid\u201d according to the W3C\u2019s validator.</p>\n\n<p>Sadly, most developers judge decisions based on their feelings rather than any kind of objective analysis.  <q>I wrote this, and it\u2019s clever, and it makes me happy, so it\u2019s good.</q>  There is no surer way to end up with a pile of garbage than this approach.  It\u2019s hard to let go of something that you worked on, and coders are certainly not the only culprits.  I\u2019ve seen execs spend countless hours on a deal that never yielded any value for the company, and designers fight tooth and nail for a visual approach that just didn\u2019t work.  Hell, we all have a relative or two with a recipe for something that they love, but which everyone knows is terribly bland.</p>\n\n<p>It\u2019s really <em>really</em> hard to let go of this emotional attachment to work.  The reason we feel good when we succeed is that our emotions are attached to our work.  It\u2019s why I get up in the morning.  But it\u2019s better to attach your feelings to how harsh you are on your code.  Understand that we all write terrible code, but that the difference between bad and good is that good coders recognize this fact and deal with it.</p>\n\n<p>Because of the incredible complexity in software development of any kind, there simply is no room for mindless zealotry or attachment to a movement.  Every project, every site, every module is a little different, and has a slightly different standard of quality.  (Even the rule \u201calways head upwards\u201d doesn\u2019t work for climbing all kinds of mountains.)  Keep the goal in mind, and think about the best way to get there.  Sometimes it\u2019ll be the accepted standards, hell most of the time it probably will be, but sometimes it might not.  It\u2019s our job to know the difference.</p>\n\n<p>Every once in a while, take a moment to re-evaluate your methods for evaluating the quality of your code.  You may have to let go of something comfortable, and it may sting, but in the end, you\u2019ll be better at what you do.</p>",
        "tree_html": ""
    },
    "reblog_key": "ZzL49o5e",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWy8lWVW",
    "slug": "theres-no-room-for-ego-or-zealotry-in-software",
    "state": "published",
    "summary": "There's no room for Ego or Zealotry in Software (especially on the web)",
    "tags": [
        "Code Ecosystems",
        "Sustainability"
    ],
    "timestamp": 1184607271,
    "title": "There's no room for Ego or Zealotry in Software (especially on the web)",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>For the last several years, there&rsquo;s been a lot of talk about why web standards are generally a good thing.  And I agree with the vast majority of it.  Writing clean code that sticks to a widely accepted standard is a very good way to help the future programmers who will invariably be touching your stuff once you&rsquo;re gone (or yourself fixing a bug next month or year later.)  In this sense, web standards are a sort of &ldquo;kindness in coding.&rdquo;</p>\n\n<p>However, as with the OOP zealotry that started 20 years ago and is still going strong today, this set of very useful guidelines has turned into a movement.  It has gained enough followers and momentum, and in many cases, seems to have become and End In Itself.</p>\n\n<p>Movements are like organisms.  They survive because the cells that make them up all continually and unthinkingly chant the mantras and make the arguments.  Ideas can be good.  Critically examining them is good.  Being passionate about a good idea is good.  But movements, more often than not, become problematic.</p>\n\n<p>Software is the most complicated thing that humans build, and we haven&rsquo;t really figured it out.  You could even make the argument that we probably never will fully figure out how to create software in a way that doesn&rsquo;t suck to some degree.  That&rsquo;s not to say we don&rsquo;t create some great software, great websites, great programs, etc.  But there are <em>always</em> bugs, and delays, and general chaos along the way, and I believe that there always will be.  The process involves an unknown number of unknowns.  Software is more complicated than the human brain can handle, and that&rsquo;s the only kind of brain that we have.</p>\n\n<p>So, how do you solve a problem when you don&rsquo;t know all the factors, and only have a vague idea of what success looks like?  It&rsquo;s like climbing a mountain when you can&rsquo;t see the top.  You can still see the slope, and can occasionally get glimpses of where you&rsquo;re going, or at least, you know that it&rsquo;s higher up.  If we are to approach quality software, then we must treat this exceedingly complicated problem in a manner that at least <em>approaches</em> quality heuristically, perhaps organically.</p>\n\n<p>Software is a process of making decisions, and then codifying and saving those decisions.  Bad decisions must be pruned ruthlessly, and good ones must be recognized and reused.  In a general sense, this is the heuristic that leads to quality software (or quality <em>anything</em> for that matter.)  The question of what makes a decision &ldquo;good&rdquo; or &ldquo;bad&rdquo; is itself a decision that needs continual evaluation.  And <em>that&rsquo;s</em> where movements get into trouble.</p>\n\n<p>It&rsquo;s easy to say, If it conforms with the w3c&rsquo;s (or Microsoft&rsquo;s or whoever&rsquo;s) standards, then it&rsquo;s good.  I think that this might be a good start, but it&rsquo;s basically an <a href=\"http://en.wikipedia.org/wiki/Appeal_to_authority\">argument from authority</a>.  The w3c is a group of humans.  So is Microsoft.  Humans make mistakes, and have plenty of limitations; that&rsquo;s why we need a heuristic in the first place.</p>\n\n<p>It&rsquo;s also easy to say, If it loads fast and looks right, then it&rsquo;s good.  Sure, but how easy is it to debug it when it doesn&rsquo;t work as expected?  Can new developers add to it easily?  Is it expensive to maintain or re-purpose?</p>\n\n<p>Or, even worse, This was written in (Rails, VB, Django, PHP, C#, valid CSS) so it&rsquo;s good.  I think that a lot of the worst examples of Microsoft horrors were the result of a fanatical attachment to Visual Basic.  I&rsquo;ve seen (ok, &ldquo;written&rdquo;) some terrible CSS that was, nonetheless, technically &ldquo;valid&rdquo; according to the W3C&rsquo;s validator.</p>\n\n<p>Sadly, most developers judge decisions based on their feelings rather than any kind of objective analysis.  I wrote this, and it&rsquo;s clever, and it makes me happy, so it&rsquo;s good.  There is no surer way to end up with a pile of garbage than this approach.  It&rsquo;s hard to let go of something that you worked on, and coders are certainly not the only culprits.  I&rsquo;ve seen execs spend countless hours on a deal that never yielded any value for the company, and designers fight tooth and nail for a visual approach that just didn&rsquo;t work.  Hell, we all have a relative or two with a recipe for something that they love, but which everyone knows is terribly bland.</p>\n\n<p>It&rsquo;s really <em>really</em> hard to let go of this emotional attachment to work.  The reason we feel good when we succeed is that our emotions are attached to our work.  It&rsquo;s why I get up in the morning.  But it&rsquo;s better to attach your feelings to how harsh you are on your code.  Understand that we all write terrible code, but that the difference between bad and good is that good coders recognize this fact and deal with it.</p>\n\n<p>Because of the incredible complexity in software development of any kind, there simply is no room for mindless zealotry or attachment to a movement.  Every project, every site, every module is a little different, and has a slightly different standard of quality.  (Even the rule &ldquo;always head upwards&rdquo; doesn&rsquo;t work for climbing all kinds of mountains.)  Keep the goal in mind, and think about the best way to get there.  Sometimes it&rsquo;ll be the accepted standards, hell most of the time it probably will be, but sometimes it might not.  It&rsquo;s our job to know the difference.</p>\n\n<p>Every once in a while, take a moment to re-evaluate your methods for evaluating the quality of your code.  You may have to let go of something comfortable, and it may sting, but in the end, you&rsquo;ll be better at what you do.</p>",
            "content_raw": "<p>For the last several years, there\u2019s been a lot of talk about why web standards are generally a good thing.  And I agree with the vast majority of it.  Writing clean code that sticks to a widely accepted standard is a very good way to help the future programmers who will invariably be touching your stuff once you\u2019re gone (or yourself fixing a bug next month or year later.)  In this sense, web standards are a sort of \u201ckindness in coding.\u201d</p>\n\n<p>However, as with the <abbr title=\"object oriented programming\">OOP</abbr> zealotry that started 20 years ago and is still going strong today, this set of very useful guidelines has turned into a movement.  It has gained enough followers and momentum, and in many cases, seems to have become and End In Itself.</p>\n\n<p>Movements are like organisms.  They survive because the cells that make them up all continually and unthinkingly chant the mantras and make the arguments.  Ideas can be good.  Critically examining them is good.  Being passionate about a good idea is good.  But movements, more often than not, become problematic.</p>\n\n<p>Software is the most complicated thing that humans build, and we haven\u2019t really figured it out.  You could even make the argument that we probably never will fully figure out how to create software in a way that doesn\u2019t suck to some degree.  That\u2019s not to say we don\u2019t create some great software, great websites, great programs, etc.  But there are <em>always</em> bugs, and delays, and general chaos along the way, and I believe that there always will be.  The process involves an unknown number of unknowns.  Software is more complicated than the human brain can handle, and that\u2019s the only kind of brain that we have.</p>\n\n<p>So, how do you solve a problem when you don\u2019t know all the factors, and only have a vague idea of what success looks like?  It\u2019s like climbing a mountain when you can\u2019t see the top.  You can still see the slope, and can occasionally get glimpses of where you\u2019re going, or at least, you know that it\u2019s higher up.  If we are to approach quality software, then we must treat this exceedingly complicated problem in a manner that at least <em>approaches</em> quality heuristically, perhaps organically.</p>\n\n<p>Software is a process of making decisions, and then codifying and saving those decisions.  Bad decisions must be pruned ruthlessly, and good ones must be recognized and reused.  In a general sense, this is the heuristic that leads to quality software (or quality <em>anything</em> for that matter.)  The question of what makes a decision \u201cgood\u201d or \u201cbad\u201d is itself a decision that needs continual evaluation.  And <em>that\u2019s</em> where movements get into trouble.</p>\n\n<p>It\u2019s easy to say, <q>If it conforms with the w3c\u2019s (or Microsoft\u2019s or whoever\u2019s) standards, then it\u2019s good.</q>  I think that this might be a good start, but it\u2019s basically an <a href=\"http://en.wikipedia.org/wiki/Appeal_to_authority\">argument from authority</a>.  The w3c is a group of humans.  So is Microsoft.  Humans make mistakes, and have plenty of limitations; that\u2019s why we need a heuristic in the first place.</p>\n\n<p>It\u2019s also easy to say, <q>If it loads fast and looks right, then it\u2019s good.</q>  Sure, but how easy is it to debug it when it doesn\u2019t work as expected?  Can new developers add to it easily?  Is it expensive to maintain or re-purpose?</p>\n\n<p>Or, even worse, <q>This was written in (Rails, VB, Django, PHP, C#, valid CSS) so it\u2019s good.</q>  I think that a lot of the worst examples of Microsoft horrors were the result of a fanatical attachment to Visual Basic.  I\u2019ve seen (ok, \u201cwritten\u201d) some terrible CSS that was, nonetheless, technically \u201cvalid\u201d according to the W3C\u2019s validator.</p>\n\n<p>Sadly, most developers judge decisions based on their feelings rather than any kind of objective analysis.  <q>I wrote this, and it\u2019s clever, and it makes me happy, so it\u2019s good.</q>  There is no surer way to end up with a pile of garbage than this approach.  It\u2019s hard to let go of something that you worked on, and coders are certainly not the only culprits.  I\u2019ve seen execs spend countless hours on a deal that never yielded any value for the company, and designers fight tooth and nail for a visual approach that just didn\u2019t work.  Hell, we all have a relative or two with a recipe for something that they love, but which everyone knows is terribly bland.</p>\n\n<p>It\u2019s really <em>really</em> hard to let go of this emotional attachment to work.  The reason we feel good when we succeed is that our emotions are attached to our work.  It\u2019s why I get up in the morning.  But it\u2019s better to attach your feelings to how harsh you are on your code.  Understand that we all write terrible code, but that the difference between bad and good is that good coders recognize this fact and deal with it.</p>\n\n<p>Because of the incredible complexity in software development of any kind, there simply is no room for mindless zealotry or attachment to a movement.  Every project, every site, every module is a little different, and has a slightly different standard of quality.  (Even the rule \u201calways head upwards\u201d doesn\u2019t work for climbing all kinds of mountains.)  Keep the goal in mind, and think about the best way to get there.  Sometimes it\u2019ll be the accepted standards, hell most of the time it probably will be, but sometimes it might not.  It\u2019s our job to know the difference.</p>\n\n<p>Every once in a while, take a moment to re-evaluate your methods for evaluating the quality of your code.  You may have to let go of something comfortable, and it may sting, but in the end, you\u2019ll be better at what you do.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "146671584"
            }
        }
    ],
    "type": "text"
}