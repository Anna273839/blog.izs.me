{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544578035,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>It&rsquo;s fairly common these days to think of JavaScript as a sort of\n&ldquo;assembly language for the web&rdquo;.  After all, it&rsquo;s the language that\nis natively supported by web browsers, making it the most widely\ndeployed runtime in history.  With Node, we have a very relevant\ngeneral purpose non-browser stack for doing system programming using\nthis language, so it&rsquo;s even more important as a language.</p>\n\n<p>Programmers like to improve things and solve problems.  This is a\nhealthy instinct, but like so many healthy instincts, it can be subject\nto runaway feedback loops and lead to pathological behavior.</p>\n\n<p>If you are designing a language, compiling it to JavaScript is a pretty\nattractive option, for much the same reason that compiling C to machine\ncode is an attractive option: running it in more places.</p>\n\n<p>However, so far, most of the times that I&rsquo;ve seen someone trot out the\n&ldquo;JS = new assembly&rdquo; horse, it&rsquo;s not an apt comparison.  The reason we\nwrite C instead of assembly is that:</p>\n\n<ol><li>Assembly varies wildly between architectures.  C is not as variable.\nSo, the compiler can abstract away a lot of that peculiarity, and you\nonly need to worry about it if you&rsquo;re distributing precompiled binaries.</li>\n<li>C offers an order of magnitude more expressiveness.</li>\n</ol><p>I&rsquo;m going to pick on CoffeeScript, because it&rsquo;s clearly the most popular\nto-JS language.  Jeremy Ashkenas is a great guy, and has shown himself\non repeated occasions to be remarkably sane with\nrespect to this issue.  Either he hasn&rsquo;t caught the language-wank\ncrazy, or he hides it <em>really</em> well.</p>\n\n<p>However, either or both of these points\napply to every other to-JS language, including but not limited to GWT,\nparen-js, sibilant, streamline, kaffiene, narrative, et al.  That&rsquo;s not\nto say that any of these systems are <em>bad</em>, just that the &ldquo;blah is to JS\nas C is to Assembly&rdquo; analogy is wildly wrongheaded.</p>\n\n<ol><li>CoffeeScript programs don&rsquo;t vary any less across architectures than\nthe JavaScript programs it creates.  That is, you don&rsquo;t compile it to target a given platform.\n(This is not true of GWT, which can compile different JS files for\ndifferent browsers, but that&rsquo;s not the norm in the to-JS world.)</li>\n<li>CoffeeScript does not offer an order of magnitude difference in\nexpressiveness.  I&rsquo;m not using &ldquo;expressiveness&rdquo; as some fuzzy term to\nmean &ldquo;how happy you are expressing yourself in X language&rdquo;, but the\nmore mathy technical meaning of &ldquo;how many relevant program tokens are\nrequired to do X task.&rdquo;  CoffeeScript may require fewer tokens, sure,\nbut not 10 to 1 fewer.</li>\n</ol><p>JavaScript is not the Assembly of the Web.  It&rsquo;s the C of the web.  The\nto-JS languages are lining up to become the C++ of the web.</p>\n\n<ol><li>They offer language features that make some sorts of programs a\nlittle bit easier to write, but don&rsquo;t make an order of\nmagnitude difference in expressive power.</li>\n<li>They&rsquo;re mostly backwards compatible with JavaScript.</li>\n<li>You still need to grok the DOM, or\nnode, or whatever other platform your program is interacting with,\nand that&rsquo;s probably documented in JavaScript.</li>\n<li>They break almost all of the tooling that exists for JavaScript\ndebugging.</li>\n</ol><hr><p><strong>Clarification</strong>: CoffeeScript <em>does</em> try very hard to compile to JS\nthat runs on all JS platforms.  However, it does not optimize <em>for</em> a given\nplatform, or have a specified target when it compiles.  The resulting\nJS is still a high-level general-purpose program, and the pitch, at least,\nis that it is a better one than you would have written as easily by hand.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2011-09-14 21:21:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 10213512387,
    "is_blocks_post_format": false,
    "note_count": 86,
    "post_url": "http://blog.izs.me/post/10213512387/javascript-is-not-web-assembly",
    "reblog": {
        "comment": "<p>It\u2019s fairly common these days to think of JavaScript as a sort of\n\u201cassembly language for the web\u201d.  After all, it\u2019s the language that\nis natively supported by web browsers, making it the most widely\ndeployed runtime in history.  With Node, we have a very relevant\ngeneral purpose non-browser stack for doing system programming using\nthis language, so it\u2019s even more important as a language.</p>\n\n<p>Programmers like to improve things and solve problems.  This is a\nhealthy instinct, but like so many healthy instincts, it can be subject\nto runaway feedback loops and lead to pathological behavior.</p>\n\n<p>If you are designing a language, compiling it to JavaScript is a pretty\nattractive option, for much the same reason that compiling C to machine\ncode is an attractive option: running it in more places.</p>\n\n<p>However, so far, most of the times that I\u2019ve seen someone trot out the\n\u201cJS = new assembly\u201d horse, it\u2019s not an apt comparison.  The reason we\nwrite C instead of assembly is that:</p>\n\n<ol><li>Assembly varies wildly between architectures.  C is not as variable.\nSo, the compiler can abstract away a lot of that peculiarity, and you\nonly need to worry about it if you\u2019re distributing precompiled binaries.</li>\n<li>C offers an order of magnitude more expressiveness.</li>\n</ol><p>I\u2019m going to pick on CoffeeScript, because it\u2019s clearly the most popular\nto-JS language.  Jeremy Ashkenas is a great guy, and has shown himself\non repeated occasions to be remarkably sane with\nrespect to this issue.  Either he hasn\u2019t caught the language-wank\ncrazy, or he hides it <em>really</em> well.</p>\n\n<p>However, either or both of these points\napply to every other to-JS language, including but not limited to GWT,\nparen-js, sibilant, streamline, kaffiene, narrative, et al.  That\u2019s not\nto say that any of these systems are <em>bad</em>, just that the \u201cblah is to JS\nas C is to Assembly\u201d analogy is wildly wrongheaded.</p>\n\n<ol><li>CoffeeScript programs don\u2019t vary any less across architectures than\nthe JavaScript programs it creates.  That is, you don\u2019t compile it to target a given platform.\n(This is not true of GWT, which can compile different JS files for\ndifferent browsers, but that\u2019s not the norm in the to-JS world.)</li>\n<li>CoffeeScript does not offer an order of magnitude difference in\nexpressiveness.  I\u2019m not using \u201cexpressiveness\u201d as some fuzzy term to\nmean \u201chow happy you are expressing yourself in X language\u201d, but the\nmore mathy technical meaning of \u201chow many relevant program tokens are\nrequired to do X task.\u201d  CoffeeScript may require fewer tokens, sure,\nbut not 10 to 1 fewer.</li>\n</ol><p>JavaScript is not the Assembly of the Web.  It\u2019s the C of the web.  The\nto-JS languages are lining up to become the C++ of the web.</p>\n\n<ol><li>They offer language features that make some sorts of programs a\nlittle bit easier to write, but don\u2019t make an order of\nmagnitude difference in expressive power.</li>\n<li>They\u2019re mostly backwards compatible with JavaScript.</li>\n<li>You still need to grok the DOM, or\nnode, or whatever other platform your program is interacting with,\nand that\u2019s probably documented in JavaScript.</li>\n<li>They break almost all of the tooling that exists for JavaScript\ndebugging.</li>\n</ol><hr><p><strong>Clarification</strong>: CoffeeScript <em>does</em> try very hard to compile to JS\nthat runs on all JS platforms.  However, it does not optimize <em>for</em> a given\nplatform, or have a specified target when it compiles.  The resulting\nJS is still a high-level general-purpose program, and the pitch, at least,\nis that it is a better one than you would have written as easily by hand.</p>",
        "tree_html": ""
    },
    "reblog_key": "wD7beQVB",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWy9WnTJ3",
    "slug": "javascript-is-not-web-assembly",
    "state": "published",
    "summary": "JavaScript is Not Web Assembly",
    "tags": [],
    "timestamp": 1316035260,
    "title": "JavaScript is Not Web Assembly  ",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>It&rsquo;s fairly common these days to think of JavaScript as a sort of\n&ldquo;assembly language for the web&rdquo;.  After all, it&rsquo;s the language that\nis natively supported by web browsers, making it the most widely\ndeployed runtime in history.  With Node, we have a very relevant\ngeneral purpose non-browser stack for doing system programming using\nthis language, so it&rsquo;s even more important as a language.</p>\n\n<p>Programmers like to improve things and solve problems.  This is a\nhealthy instinct, but like so many healthy instincts, it can be subject\nto runaway feedback loops and lead to pathological behavior.</p>\n\n<p>If you are designing a language, compiling it to JavaScript is a pretty\nattractive option, for much the same reason that compiling C to machine\ncode is an attractive option: running it in more places.</p>\n\n<p>However, so far, most of the times that I&rsquo;ve seen someone trot out the\n&ldquo;JS = new assembly&rdquo; horse, it&rsquo;s not an apt comparison.  The reason we\nwrite C instead of assembly is that:</p>\n\n<ol><li>Assembly varies wildly between architectures.  C is not as variable.\nSo, the compiler can abstract away a lot of that peculiarity, and you\nonly need to worry about it if you&rsquo;re distributing precompiled binaries.</li>\n<li>C offers an order of magnitude more expressiveness.</li>\n</ol><p>I&rsquo;m going to pick on CoffeeScript, because it&rsquo;s clearly the most popular\nto-JS language.  Jeremy Ashkenas is a great guy, and has shown himself\non repeated occasions to be remarkably sane with\nrespect to this issue.  Either he hasn&rsquo;t caught the language-wank\ncrazy, or he hides it <em>really</em> well.</p>\n\n<p>However, either or both of these points\napply to every other to-JS language, including but not limited to GWT,\nparen-js, sibilant, streamline, kaffiene, narrative, et al.  That&rsquo;s not\nto say that any of these systems are <em>bad</em>, just that the &ldquo;blah is to JS\nas C is to Assembly&rdquo; analogy is wildly wrongheaded.</p>\n\n<ol><li>CoffeeScript programs don&rsquo;t vary any less across architectures than\nthe JavaScript programs it creates.  That is, you don&rsquo;t compile it to target a given platform.\n(This is not true of GWT, which can compile different JS files for\ndifferent browsers, but that&rsquo;s not the norm in the to-JS world.)</li>\n<li>CoffeeScript does not offer an order of magnitude difference in\nexpressiveness.  I&rsquo;m not using &ldquo;expressiveness&rdquo; as some fuzzy term to\nmean &ldquo;how happy you are expressing yourself in X language&rdquo;, but the\nmore mathy technical meaning of &ldquo;how many relevant program tokens are\nrequired to do X task.&rdquo;  CoffeeScript may require fewer tokens, sure,\nbut not 10 to 1 fewer.</li>\n</ol><p>JavaScript is not the Assembly of the Web.  It&rsquo;s the C of the web.  The\nto-JS languages are lining up to become the C++ of the web.</p>\n\n<ol><li>They offer language features that make some sorts of programs a\nlittle bit easier to write, but don&rsquo;t make an order of\nmagnitude difference in expressive power.</li>\n<li>They&rsquo;re mostly backwards compatible with JavaScript.</li>\n<li>You still need to grok the DOM, or\nnode, or whatever other platform your program is interacting with,\nand that&rsquo;s probably documented in JavaScript.</li>\n<li>They break almost all of the tooling that exists for JavaScript\ndebugging.</li>\n</ol><hr /><p><strong>Clarification</strong>: CoffeeScript <em>does</em> try very hard to compile to JS\nthat runs on all JS platforms.  However, it does not optimize <em>for</em> a given\nplatform, or have a specified target when it compiles.  The resulting\nJS is still a high-level general-purpose program, and the pitch, at least,\nis that it is a better one than you would have written as easily by hand.</p>",
            "content_raw": "<p>It\u2019s fairly common these days to think of JavaScript as a sort of\n\u201cassembly language for the web\u201d.  After all, it\u2019s the language that\nis natively supported by web browsers, making it the most widely\ndeployed runtime in history.  With Node, we have a very relevant\ngeneral purpose non-browser stack for doing system programming using\nthis language, so it\u2019s even more important as a language.</p>\n\n<p>Programmers like to improve things and solve problems.  This is a\nhealthy instinct, but like so many healthy instincts, it can be subject\nto runaway feedback loops and lead to pathological behavior.</p>\n\n<p>If you are designing a language, compiling it to JavaScript is a pretty\nattractive option, for much the same reason that compiling C to machine\ncode is an attractive option: running it in more places.</p>\n\n<p>However, so far, most of the times that I\u2019ve seen someone trot out the\n\u201cJS = new assembly\u201d horse, it\u2019s not an apt comparison.  The reason we\nwrite C instead of assembly is that:</p>\n\n<ol><li>Assembly varies wildly between architectures.  C is not as variable.\nSo, the compiler can abstract away a lot of that peculiarity, and you\nonly need to worry about it if you\u2019re distributing precompiled binaries.</li>\n<li>C offers an order of magnitude more expressiveness.</li>\n</ol><p>I\u2019m going to pick on CoffeeScript, because it\u2019s clearly the most popular\nto-JS language.  Jeremy Ashkenas is a great guy, and has shown himself\non repeated occasions to be remarkably sane with\nrespect to this issue.  Either he hasn\u2019t caught the language-wank\ncrazy, or he hides it <em>really</em> well.</p>\n\n<p>However, either or both of these points\napply to every other to-JS language, including but not limited to GWT,\nparen-js, sibilant, streamline, kaffiene, narrative, et al.  That\u2019s not\nto say that any of these systems are <em>bad</em>, just that the \u201cblah is to JS\nas C is to Assembly\u201d analogy is wildly wrongheaded.</p>\n\n<ol><li>CoffeeScript programs don\u2019t vary any less across architectures than\nthe JavaScript programs it creates.  That is, you don\u2019t compile it to target a given platform.\n(This is not true of GWT, which can compile different JS files for\ndifferent browsers, but that\u2019s not the norm in the to-JS world.)</li>\n<li>CoffeeScript does not offer an order of magnitude difference in\nexpressiveness.  I\u2019m not using \u201cexpressiveness\u201d as some fuzzy term to\nmean \u201chow happy you are expressing yourself in X language\u201d, but the\nmore mathy technical meaning of \u201chow many relevant program tokens are\nrequired to do X task.\u201d  CoffeeScript may require fewer tokens, sure,\nbut not 10 to 1 fewer.</li>\n</ol><p>JavaScript is not the Assembly of the Web.  It\u2019s the C of the web.  The\nto-JS languages are lining up to become the C++ of the web.</p>\n\n<ol><li>They offer language features that make some sorts of programs a\nlittle bit easier to write, but don\u2019t make an order of\nmagnitude difference in expressive power.</li>\n<li>They\u2019re mostly backwards compatible with JavaScript.</li>\n<li>You still need to grok the DOM, or\nnode, or whatever other platform your program is interacting with,\nand that\u2019s probably documented in JavaScript.</li>\n<li>They break almost all of the tooling that exists for JavaScript\ndebugging.</li>\n</ol><hr><p><strong>Clarification</strong>: CoffeeScript <em>does</em> try very hard to compile to JS\nthat runs on all JS platforms.  However, it does not optimize <em>for</em> a given\nplatform, or have a specified target when it compiles.  The resulting\nJS is still a high-level general-purpose program, and the pitch, at least,\nis that it is a better one than you would have written as easily by hand.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "10213512387"
            }
        }
    ],
    "type": "text"
}