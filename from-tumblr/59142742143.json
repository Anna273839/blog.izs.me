{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544051896,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p><i>New 2014-06-30: You can contain Zalgo with the <a href=\"http://npm.im/dezalgo\">dezalgo module</a></i></p>\n\n<p>Some people asked me to explain what <a href=\"http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0355.html\">I\nmeant</a>\nby &ldquo;releasing Zalgo&rdquo; in async APIs, so I thought I&rsquo;d share\nthe following guidelines.</p>\n\n<p>Please follow all of these rules in your programs.  If you deviate\nfrom them, you do so at the peril of your very sanity.</p>\n\n<h3>Get Over Your Provincial Boilerplate Preferences</h3>\n\n<p>Personally, I don&rsquo;t actually care all that much about the whole\npromises/callbacks/coroutines/generators debate.  It&rsquo;s provably\ntrivial to turn any callback-taking API into a promise-returning API\nor generator-yielding API or vice-versa.</p>\n\n<p>I&rsquo;m of the opinion that breaking functionality into small enough\nchunks that your boilerplate doesn&rsquo;t <em>matter</em> is much more important\nthan <em>which</em> boilerplate you decide tastes the yummiest.  In\nJavaScript, we have first-class language support for passing functions\naround, so I tend to use callbacks, simply because it requires no\nextra &ldquo;stuff&rdquo;.</p>\n\n<p>What&rsquo;s important to me is that an API be useful, performant, and easy to\nreason about.  When I&rsquo;m writing JavaScript, I care a lot about how\nV8 is going to optimize it, and so try to choose patterns that it can\noptimize nicely.  As of today, generators just aren&rsquo;t first-class\nenough, and Promises require an extra abstraction.  That may change\nsomeday, but these principles probably will not.</p>\n\n<p>So, I&rsquo;m going to say &ldquo;callbacks&rdquo; below, but you can mentally\nsubstitute whatever thing you like.  The fundamental points are\nequally relevant if you&rsquo;re using threads, or gotos, or any other\nabstraction or language for doing things asynchronously and\ncontrolling what the computer does next.</p>\n\n<p>Note that all of this <em>also</em> applies if your asynchronous API &ldquo;looks\nsynchronous&rdquo;.  Even if you design a thing so that I do:</p>\n\n<pre><code>x = foo();</code></pre>\n\n<p>and it&rsquo;s completely agnostic at authoring time whether <code>foo()</code> spins\non CPU or yields while it awaits a network response, being able to\nreason about the program means that I need to be able to know whether\n<em>other</em> parts of the program will be running while I&rsquo;m waiting for\n<code>foo()</code> to return a value to be put into <code>x</code>.</p>\n\n<p>So, even if the <em>syntax</em> is the same (which has its benefits as well\nas its drawbacks, of course), the <em>semantics</em> must be crisply defined.</p>\n\n<p>Or else Zalgo is released.</p>\n\n<h3>Do Not Release Zalgo</h3>\n\n<p>Warning: Before proceeding any further, <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">go read this excellent essay\nby\nHavoc</a>.</p>\n\n<p>If you haven&rsquo;t read <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Havoc&rsquo;s post on\ncallbacks</a>,\nthen you will perhaps be tempted to make silly arguments that make no\nsense, and demand justification for things that have been established\nbeyond any reasonable doubt long ago, or tell me that I&rsquo;m overstating\nthe issue.</p>\n\n<p>Have you <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">read Havoc&rsquo;s post on\ncallbacks</a>?\nYes?  Ok.</p>\n\n<p>If you didn&rsquo;t, shame on you. <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read\nit.</a>\nIf you still haven&rsquo;t, I&rsquo;ll sum up:</p>\n\n<blockquote>\n<p>If you have an API which takes a callback,<br/>and <em>sometimes</em> that callback is called immediately,<br/>and <em>other times</em> that callback is called at some point in the future,<br/>then you will render any code using this API impossible to reason\nabout, and cause the release of <a href=\"http://knowyourmeme.com/memes/zalgo\">Zalgo</a>.</p>\n</blockquote>\n\n<p>Needless to say, releasing Zalgo onto unsuspecting users is extremely\ninappropriate.</p>\n\n<p>It&rsquo;s not the case that function-taking APIs must always call the\nfunction asynchronously.  For example, <code>Array.prototype.forEach</code> calls\nthe callback immediately, before returning.  <em>But then it never calls\nit again.</em></p>\n\n<p>Nor is it the case that function-taking APIs must always call the\nfunction synchronously.  For example, <code>setTimeout</code> and friends call\nthe callback after the current run-to-completion.  <em>But they always\nreturn before calling the callback.</em></p>\n\n<p>In other words, to avoid the release of Zalgo, exactly one of the\nfollowing must be true:</p>\n\n<pre><code class=\"lang-javascript\">var after = false;\ncallbackTaker(function() {\n  assert(after === true);\n});\nafter = true;</code></pre>\n\n<p>OR:</p>\n\n<pre><code class=\"lang-javascript\">var after = false;\ncallbackTaker(function() {\n  assert(after === false);\n});\nafter = true;</code></pre>\n\n<p>and in no case can you ever have a function where exactly one of these\nassertions is not guaranteed.</p>\n\n<h4>What about internal functions in my library that are not exposed?</h4>\n\n<p>Well, ok, but you&rsquo;re releasing Zalgo in your internal library.  I\ndon&rsquo;t recommend it.  Zalgo usually finds a way to sneak His Dark\u035d\nTend\u0334r\u0321i\u0489ls out into the world.</p>\n\n<h4>What if I suspect that a function might try to release Zalgo?</h4>\n\n<p>This is a great question.  For example, perhaps you let users supply\nyour library with a callback-taking function, and you worry that they\nmight be incompetent or careless, but want to ensure that <em>your</em>\nlibrary does its best to keep Th\u034fe Da\u0489rk Po\u0144y Lo\u0358r\u0360d HE \u0301C\u0361OM\u0334E\u0338S contained\nappropriately.</p>\n\n<p>Assuming that your platform has an event loop or some other kind of\nabstraction that you can hang stuff on, you can do something like\nthis:</p>\n\n<pre><code class=\"lang-javascript\">function zalgoContainer(cbTaker, cb) {\n  var sync = true;\n  cbTaker(cbWrap);\n  sync = false;\n\n  function cbWrap(er, data) {\n    if (sync)\n      process.nextTick(function() {\n        cb(er, data);\n      });\n    else\n      cb(er, data);\n  }\n}</code></pre>\n\n<p>This uses Node&rsquo;s synthetic deferral function: <code>process.nextTick</code>,\nwhich runs the supplied callback at the end of the current\nrun-to-completion.  You can also use <code>setImmediate</code>, but that&rsquo;s\nslightly slower.  (Yes, yes, it&rsquo;s named badly; <code>setImmediate</code> is\nslightly <em>less</em> &ldquo;immediate&rdquo; and more &ldquo;next&rdquo; than <code>nextTick</code>, but this\nis an accident of history we cannot correct without a time machine.)</p>\n\n<h4>But isn&rsquo;t it faster to just call the callback right away?</h4>\n\n<p><a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read Havoc&rsquo;s blog post.</a></p>\n\n<p>Moving on.</p>\n\n<h3>Avoid Synthetic Deferrals</h3>\n\n<p>I know what you&rsquo;re thinking: <i>&ldquo;But you just told me to use\n<code>nextTick</code>!&rdquo;</i></p>\n\n<p>And yes, it&rsquo;s true, you should use synthetic deferrals when the only\nalternative is releasing Zalgo.  However, these synthetic deferrals\nshould be treated as a code smell.  They are a sign that your API\nmight not be optimally designed.</p>\n\n<p>Ideally, you should know whether something is going to be immediately\navailable, or not.  Realistically, you should be able to take a pretty\ndecent guess about whether the result is going to be immediately\navailable <em>most of the time</em>, or not, and then follow this handy\nguide:</p>\n\n<ul><li><p><strong>If the result is usually available right now, and performance\nmatters a lot:</strong></p>\n<ol><li>Check if the result is available.</li>\n<li>If it is, return it.</li>\n<li>If it is not, return an error code, set a flag, etc.</li>\n<li>Provide some Zalgo-safe mechanism for handling the error case\nand awaiting future availability.</li>\n</ol><p>Here&rsquo;s an silly example to illustrate the pattern:</p>\n<pre><code class=\"lang-javascript\">var isAvailable = true;\nvar i = 0;\nfunction usuallyAvailable() {\n  i++;\n  if (i === 10) {\n    i = 0;\n    isAvailable = false;\n    setTimeout(function() {\n      isAvailable = true;\n      if (waiting.length) {\n        for (var cb = waiting.shift();\n             cb;\n             cb = waiting.shift()) {\n          cb();\n        }\n      }\n    });\n  }\n\n  return isAvailable ? i : new Error('not available');\n}\n\nfunction waitForAvailability(cb) {\n  // Could also defer this and just call it,\n  // but it is avoidable, which is the point.\n  if (isAvailable)\n    throw new Error(\"hey, dummy, check first!\");\n  waiting.push(cb);\n}</code></pre>\n<p>In this case, when the user calls <code>usuallyAvailable()</code> they&rsquo;ll get\na number between 0 and 9, 90% of the time.  It&rsquo;s on the caller to\ncheck the return value, see if it means that they have to wait,\netc.</p>\n<p>This makes the API a bit trickier to use, because the caller has\nto know to detect the error state.  If it&rsquo;s very rare, then\nthere&rsquo;s a chance that they might get surprised in production the\nfirst time it fails.  This is a communication problem, like most\nAPI design concerns, but if performance is critical, it <em>may</em> be\nworth the hit to avoid artificial deferrals in the common cases.</p>\n<p>Note that this is functionally equivalent to\n<code>O_NONBLOCK/EWOULDBLOCK/poll</code> pattern.  You try to do a thing,\nand if it is not available right now, it raises an error, and you\nwait until it IS available, and then try again.</p>\n</li>\n<li><p><strong>If the result is usually available right now, but performance\ndoesn&rsquo;t matter all that much</strong></p>\n<p>  For example, the function might only be called a few times at\n  startup, etc.</p>\n<p>  In this case, just follow the &ldquo;result is usually not available\n  right now&rdquo; approach.</p>\n<p>  Note that performance actually does matter much more often than\n  you probably realize.</p>\n</li>\n<li><p><strong>If the result is usually not available right now</strong></p>\n<ol><li>Take a callback.</li>\n<li>Artificially defer the callback if the data is available right\nnow.</li>\n</ol><p>Here&rsquo;s an example:</p>\n<pre><code class=\"lang-javascript\">var cachedValue;\nfunction usuallyAsync(cb) {\n  if (cachedValue !== undefined)\n    process.nextTick(function() {\n      cb(cachedValue);\n    });\n  else\n    doSomeSlowThing(function(result) {\n      cb(cachedValue = result);\n    });\n}</code></pre>\n</li>\n</ul><p>The basic point here is that &ldquo;async&rdquo; is not some magic mustard you\nsmear all over your API to make it fast.  <strong>Asynchronous APIs do\nnot go faster.  They go slower.</strong>  However, they prevent <em>other</em> parts\nof the program from having to wait for them, so <em>overall</em> program\nperformance can be improved.</p>\n\n<p>Note that this applies to not just callbacks, but also to Promises and\nany other control-flow abstractions.  If your API is frequently\nreturning a Promise for a value that you know <em>right now</em>, then either\nyou are leaving performance on the table, or your Promise\nimplementation releases H\u0335\u0358\u0361e \u0321wh\u0301o\u0360 \u0336Prom\u0300\u035f\u035di\u0334s\u0300es\u0300 o\u0489\u0336nl\u0328\u035fy\u0327 \u031b\u031bm\u0334\u0360\u035da\u0321\u031b\u0362d\u0321n\u0334\u0321e\u035ds\u0338s\u0360,\nT\u0322\u0489\u0338h\u0334\u0337\u0338\u0322\u0229\u0361 \u0358\u0360N\u0362\u0362e\u034f\u034f\u0362\u0360z\u031b\u034f\u035cp\u0338\u0300\u0315\u0360\u0229\u0301\u035d\u035dr\u0489\u031b\u0301\u0360d\u0334\u0300i\u0334\u0315\u0489\u035ea\u0334\u0321\u035d\u0360n\u0322\u035c\u035f\u0362\u035f \u0336\u0334\u0322\u035dh\u0337\u0315\u0360\u00ed\u0338\u0327\u031b\u035cv\u0336\u0322\u0362\u0361e\u0315\u0361-\u0338\u0300\u035dm\u0337\u035ci\u031b\u0358\u035e\u0146\u031b\u0358\u035f\u0489d\u0336\u0336\u0321\u0327\u035c \u0337\u031b\u035eo\u0335\u0322\u0358\u035f\u035ef\u0336\u0322\u0300\u0362\u0362 \u0336\u0327\u035f\u0361c\u0315\u035dh\u0336\u0300\u0358\u0358\u00e0\u034fo\u0489\u0334\u0301\u0362s\u0338\u0358\u0358\u035d\u035e.\u0328\u0362\u035e.</p>\n\n<p>So, don&rsquo;t do that.</p>\n\n<h3>Pick a Pattern and Stick With It</h3>\n\n<p>This really cannot be overstated.  Like the question of callbacks vs\nPromises vs whatever, the specific pattern that you choose doesn&rsquo;t\nmatter very much.  What <em>does</em> matter very much is that you stick to\nthat pattern with ruthless consistency.  The pattern should cover how\na user interacts with your API, and how errors are communicated.</p>\n\n<p>In Node.js, the callback pattern is:</p>\n\n<ol><li>Async functions take a single callback function as their final\nargument.</li>\n<li>That callback is called in the future with the first argument set\nto an <code>Error</code> object in the case of failure, and any additional\nresults as the subsequent arguments.</li>\n</ol><p>Why have the callback as the last argument?  Why make Error the first\narg?  It doesn&rsquo;t really matter very much.  Ostensibly, making the\ncallback the last arg is because</p>\n\n<pre><code class=\"lang-javascript\">doSomething(a, b, c, d, function(er) {\n  ...\n})</code></pre>\n\n<p>scans a bit better than:</p>\n\n<pre><code class=\"lang-javascript\">doSomething(function(er) {\n  ...\n}, a, b, c)</code></pre>\n\n<p>and putting the error first is so that it&rsquo;s always in the same place.</p>\n\n<p>There were other choices that could have been made.  But the important\nthing was just to pick one, and move forward with it.  This\nconsistency makes it much less difficult to convert Node APIs into\nother sorts of aync patterns, and greatly reduces the communication\nrequired to tell a user how to use a Node.js callback-taking API.\n </p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2013-08-23 23:06:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 59142742143,
    "is_blocks_post_format": false,
    "note_count": 61,
    "post_url": "http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony",
    "reblog": {
        "comment": "<p><i>New 2014-06-30: You can contain Zalgo with the <a href=\"http://npm.im/dezalgo\">dezalgo module</a></i></p>\n\n<p>Some people asked me to explain what <a href=\"http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0355.html\">I\nmeant</a>\nby \u201creleasing Zalgo\u201d in async APIs, so I thought I\u2019d share\nthe following guidelines.</p>\n\n<p>Please follow all of these rules in your programs.  If you deviate\nfrom them, you do so at the peril of your very sanity.</p>\n\n<h3>Get Over Your Provincial Boilerplate Preferences</h3>\n\n<p>Personally, I don\u2019t actually care all that much about the whole\npromises/callbacks/coroutines/generators debate.  It\u2019s provably\ntrivial to turn any callback-taking API into a promise-returning API\nor generator-yielding API or vice-versa.</p>\n\n<p>I\u2019m of the opinion that breaking functionality into small enough\nchunks that your boilerplate doesn\u2019t <em>matter</em> is much more important\nthan <em>which</em> boilerplate you decide tastes the yummiest.  In\nJavaScript, we have first-class language support for passing functions\naround, so I tend to use callbacks, simply because it requires no\nextra \u201cstuff\u201d.</p>\n\n<p>What\u2019s important to me is that an API be useful, performant, and easy to\nreason about.  When I\u2019m writing JavaScript, I care a lot about how\nV8 is going to optimize it, and so try to choose patterns that it can\noptimize nicely.  As of today, generators just aren\u2019t first-class\nenough, and Promises require an extra abstraction.  That may change\nsomeday, but these principles probably will not.</p>\n\n<p>So, I\u2019m going to say \u201ccallbacks\u201d below, but you can mentally\nsubstitute whatever thing you like.  The fundamental points are\nequally relevant if you\u2019re using threads, or gotos, or any other\nabstraction or language for doing things asynchronously and\ncontrolling what the computer does next.</p>\n\n<p>Note that all of this <em>also</em> applies if your asynchronous API \u201clooks\nsynchronous\u201d.  Even if you design a thing so that I do:</p>\n\n<pre><code>x = foo();</code></pre>\n\n<p>and it\u2019s completely agnostic at authoring time whether <code>foo()</code> spins\non CPU or yields while it awaits a network response, being able to\nreason about the program means that I need to be able to know whether\n<em>other</em> parts of the program will be running while I\u2019m waiting for\n<code>foo()</code> to return a value to be put into <code>x</code>.</p>\n\n<p>So, even if the <em>syntax</em> is the same (which has its benefits as well\nas its drawbacks, of course), the <em>semantics</em> must be crisply defined.</p>\n\n<p>Or else Zalgo is released.</p>\n\n<h3>Do Not Release Zalgo</h3>\n\n<p>Warning: Before proceeding any further, <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">go read this excellent essay\nby\nHavoc</a>.</p>\n\n<p>If you haven\u2019t read <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Havoc\u2019s post on\ncallbacks</a>,\nthen you will perhaps be tempted to make silly arguments that make no\nsense, and demand justification for things that have been established\nbeyond any reasonable doubt long ago, or tell me that I\u2019m overstating\nthe issue.</p>\n\n<p>Have you <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">read Havoc\u2019s post on\ncallbacks</a>?\nYes?  Ok.</p>\n\n<p>If you didn\u2019t, shame on you. <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read\nit.</a>\nIf you still haven\u2019t, I\u2019ll sum up:</p>\n\n<blockquote>\n<p>If you have an API which takes a callback,<br>and <em>sometimes</em> that callback is called immediately,<br>and <em>other times</em> that callback is called at some point in the future,<br>then you will render any code using this API impossible to reason\nabout, and cause the release of <a href=\"http://knowyourmeme.com/memes/zalgo\">Zalgo</a>.</p>\n</blockquote>\n\n<p>Needless to say, releasing Zalgo onto unsuspecting users is extremely\ninappropriate.</p>\n\n<p>It\u2019s not the case that function-taking APIs must always call the\nfunction asynchronously.  For example, <code>Array.prototype.forEach</code> calls\nthe callback immediately, before returning.  <em>But then it never calls\nit again.</em></p>\n\n<p>Nor is it the case that function-taking APIs must always call the\nfunction synchronously.  For example, <code>setTimeout</code> and friends call\nthe callback after the current run-to-completion.  <em>But they always\nreturn before calling the callback.</em></p>\n\n<p>In other words, to avoid the release of Zalgo, exactly one of the\nfollowing must be true:</p>\n\n<pre><code class=\"lang-javascript\">var after = false;\ncallbackTaker(function() {\n  assert(after === true);\n});\nafter = true;</code></pre>\n\n<p>OR:</p>\n\n<pre><code class=\"lang-javascript\">var after = false;\ncallbackTaker(function() {\n  assert(after === false);\n});\nafter = true;</code></pre>\n\n<p>and in no case can you ever have a function where exactly one of these\nassertions is not guaranteed.</p>\n\n<h4>What about internal functions in my library that are not exposed?</h4>\n\n<p>Well, ok, but you\u2019re releasing Zalgo in your internal library.  I\ndon\u2019t recommend it.  Zalgo usually finds a way to sneak His Dark\u035d\nTend\u0334r\u0321i\u0489ls out into the world.</p>\n\n<h4>What if I suspect that a function might try to release Zalgo?</h4>\n\n<p>This is a great question.  For example, perhaps you let users supply\nyour library with a callback-taking function, and you worry that they\nmight be incompetent or careless, but want to ensure that <em>your</em>\nlibrary does its best to keep Th\u034fe Da\u0489rk Po\u0144y Lo\u0358r\u0360d HE \u0301C\u0361OM\u0334E\u0338S contained\nappropriately.</p>\n\n<p>Assuming that your platform has an event loop or some other kind of\nabstraction that you can hang stuff on, you can do something like\nthis:</p>\n\n<pre><code class=\"lang-javascript\">function zalgoContainer(cbTaker, cb) {\n  var sync = true;\n  cbTaker(cbWrap);\n  sync = false;\n\n  function cbWrap(er, data) {\n    if (sync)\n      process.nextTick(function() {\n        cb(er, data);\n      });\n    else\n      cb(er, data);\n  }\n}</code></pre>\n\n<p>This uses Node\u2019s synthetic deferral function: <code>process.nextTick</code>,\nwhich runs the supplied callback at the end of the current\nrun-to-completion.  You can also use <code>setImmediate</code>, but that\u2019s\nslightly slower.  (Yes, yes, it\u2019s named badly; <code>setImmediate</code> is\nslightly <em>less</em> \u201cimmediate\u201d and more \u201cnext\u201d than <code>nextTick</code>, but this\nis an accident of history we cannot correct without a time machine.)</p>\n\n<h4>But isn\u2019t it faster to just call the callback right away?</h4>\n\n<p><a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read Havoc\u2019s blog post.</a></p>\n\n<p>Moving on.</p>\n\n<h3>Avoid Synthetic Deferrals</h3>\n\n<p>I know what you\u2019re thinking: <i>\u201cBut you just told me to use\n<code>nextTick</code>!\u201d</i></p>\n\n<p>And yes, it\u2019s true, you should use synthetic deferrals when the only\nalternative is releasing Zalgo.  However, these synthetic deferrals\nshould be treated as a code smell.  They are a sign that your API\nmight not be optimally designed.</p>\n\n<p>Ideally, you should know whether something is going to be immediately\navailable, or not.  Realistically, you should be able to take a pretty\ndecent guess about whether the result is going to be immediately\navailable <em>most of the time</em>, or not, and then follow this handy\nguide:</p>\n\n<ul><li><p><strong>If the result is usually available right now, and performance\nmatters a lot:</strong></p>\n<ol><li>Check if the result is available.</li>\n<li>If it is, return it.</li>\n<li>If it is not, return an error code, set a flag, etc.</li>\n<li>Provide some Zalgo-safe mechanism for handling the error case\nand awaiting future availability.</li>\n</ol><p>Here\u2019s an silly example to illustrate the pattern:</p>\n<pre><code class=\"lang-javascript\">var isAvailable = true;\nvar i = 0;\nfunction usuallyAvailable() {\n  i++;\n  if (i === 10) {\n    i = 0;\n    isAvailable = false;\n    setTimeout(function() {\n      isAvailable = true;\n      if (waiting.length) {\n        for (var cb = waiting.shift();\n             cb;\n             cb = waiting.shift()) {\n          cb();\n        }\n      }\n    });\n  }\n\n  return isAvailable ? i : new Error('not available');\n}\n\nfunction waitForAvailability(cb) {\n  // Could also defer this and just call it,\n  // but it is avoidable, which is the point.\n  if (isAvailable)\n    throw new Error(\"hey, dummy, check first!\");\n  waiting.push(cb);\n}</code></pre>\n<p>In this case, when the user calls <code>usuallyAvailable()</code> they\u2019ll get\na number between 0 and 9, 90% of the time.  It\u2019s on the caller to\ncheck the return value, see if it means that they have to wait,\netc.</p>\n<p>This makes the API a bit trickier to use, because the caller has\nto know to detect the error state.  If it\u2019s very rare, then\nthere\u2019s a chance that they might get surprised in production the\nfirst time it fails.  This is a communication problem, like most\nAPI design concerns, but if performance is critical, it <em>may</em> be\nworth the hit to avoid artificial deferrals in the common cases.</p>\n<p>Note that this is functionally equivalent to\n<code>O_NONBLOCK/EWOULDBLOCK/poll</code> pattern.  You try to do a thing,\nand if it is not available right now, it raises an error, and you\nwait until it IS available, and then try again.</p>\n</li>\n<li><p><strong>If the result is usually available right now, but performance\ndoesn\u2019t matter all that much</strong></p>\n<p>  For example, the function might only be called a few times at\n  startup, etc.</p>\n<p>  In this case, just follow the \u201cresult is usually not available\n  right now\u201d approach.</p>\n<p>  Note that performance actually does matter much more often than\n  you probably realize.</p>\n</li>\n<li><p><strong>If the result is usually not available right now</strong></p>\n<ol><li>Take a callback.</li>\n<li>Artificially defer the callback if the data is available right\nnow.</li>\n</ol><p>Here\u2019s an example:</p>\n<pre><code class=\"lang-javascript\">var cachedValue;\nfunction usuallyAsync(cb) {\n  if (cachedValue !== undefined)\n    process.nextTick(function() {\n      cb(cachedValue);\n    });\n  else\n    doSomeSlowThing(function(result) {\n      cb(cachedValue = result);\n    });\n}</code></pre>\n</li>\n</ul><p>The basic point here is that \u201casync\u201d is not some magic mustard you\nsmear all over your API to make it fast.  <strong>Asynchronous APIs do\nnot go faster.  They go slower.</strong>  However, they prevent <em>other</em> parts\nof the program from having to wait for them, so <em>overall</em> program\nperformance can be improved.</p>\n\n<p>Note that this applies to not just callbacks, but also to Promises and\nany other control-flow abstractions.  If your API is frequently\nreturning a Promise for a value that you know <em>right now</em>, then either\nyou are leaving performance on the table, or your Promise\nimplementation releases H\u0335\u0358\u0361e \u0321wh\u0301o\u0360 \u0336Prom\u0300\u035f\u035di\u0334s\u0300es\u0300 o\u0489\u0336nl\u0328\u035fy\u0327 \u031b\u031bm\u0334\u0360\u035da\u0321\u031b\u0362d\u0321n\u0334\u0321e\u035ds\u0338s\u0360,\nT\u0322\u0489\u0338h\u0334\u0337\u0338\u0322\u0229\u0361 \u0358\u0360N\u0362\u0362e\u034f\u034f\u0362\u0360z\u031b\u034f\u035cp\u0338\u0300\u0315\u0360\u0229\u0301\u035d\u035dr\u0489\u031b\u0301\u0360d\u0334\u0300i\u0334\u0315\u0489\u035ea\u0334\u0321\u035d\u0360n\u0322\u035c\u035f\u0362\u035f \u0336\u0334\u0322\u035dh\u0337\u0315\u0360\u00ed\u0338\u0327\u031b\u035cv\u0336\u0322\u0362\u0361e\u0315\u0361-\u0338\u0300\u035dm\u0337\u035ci\u031b\u0358\u035e\u0146\u031b\u0358\u035f\u0489d\u0336\u0336\u0321\u0327\u035c \u0337\u031b\u035eo\u0335\u0322\u0358\u035f\u035ef\u0336\u0322\u0300\u0362\u0362 \u0336\u0327\u035f\u0361c\u0315\u035dh\u0336\u0300\u0358\u0358\u00e0\u034fo\u0489\u0334\u0301\u0362s\u0338\u0358\u0358\u035d\u035e.\u0328\u0362\u035e.</p>\n\n<p>So, don\u2019t do that.</p>\n\n<h3>Pick a Pattern and Stick With It</h3>\n\n<p>This really cannot be overstated.  Like the question of callbacks vs\nPromises vs whatever, the specific pattern that you choose doesn\u2019t\nmatter very much.  What <em>does</em> matter very much is that you stick to\nthat pattern with ruthless consistency.  The pattern should cover how\na user interacts with your API, and how errors are communicated.</p>\n\n<p>In Node.js, the callback pattern is:</p>\n\n<ol><li>Async functions take a single callback function as their final\nargument.</li>\n<li>That callback is called in the future with the first argument set\nto an <code>Error</code> object in the case of failure, and any additional\nresults as the subsequent arguments.</li>\n</ol><p>Why have the callback as the last argument?  Why make Error the first\narg?  It doesn\u2019t really matter very much.  Ostensibly, making the\ncallback the last arg is because</p>\n\n<pre><code class=\"lang-javascript\">doSomething(a, b, c, d, function(er) {\n  ...\n})</code></pre>\n\n<p>scans a bit better than:</p>\n\n<pre><code class=\"lang-javascript\">doSomething(function(er) {\n  ...\n}, a, b, c)</code></pre>\n\n<p>and putting the error first is so that it\u2019s always in the same place.</p>\n\n<p>There were other choices that could have been made.  But the important\nthing was just to pick one, and move forward with it.  This\nconsistency makes it much less difficult to convert Node APIs into\nother sorts of aync patterns, and greatly reduces the communication\nrequired to tell a user how to use a Node.js callback-taking API.\n </p>",
        "tree_html": ""
    },
    "reblog_key": "747nQFtU",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWyt5Bg1-",
    "slug": "designing-apis-for-asynchrony",
    "state": "published",
    "summary": "Designing APIs for Asynchrony",
    "tags": [],
    "timestamp": 1377299160,
    "title": "Designing APIs for Asynchrony",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p><i>New 2014-06-30: You can contain Zalgo with the <a href=\"http://npm.im/dezalgo\">dezalgo module</a></i></p>\n\n<p>Some people asked me to explain what <a href=\"http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0355.html\">I\nmeant</a>\nby &ldquo;releasing Zalgo&rdquo; in async APIs, so I thought I&rsquo;d share\nthe following guidelines.</p>\n\n<p>Please follow all of these rules in your programs.  If you deviate\nfrom them, you do so at the peril of your very sanity.</p>\n\n<h3>Get Over Your Provincial Boilerplate Preferences</h3>\n\n<p>Personally, I don&rsquo;t actually care all that much about the whole\npromises/callbacks/coroutines/generators debate.  It&rsquo;s provably\ntrivial to turn any callback-taking API into a promise-returning API\nor generator-yielding API or vice-versa.</p>\n\n<p>I&rsquo;m of the opinion that breaking functionality into small enough\nchunks that your boilerplate doesn&rsquo;t <em>matter</em> is much more important\nthan <em>which</em> boilerplate you decide tastes the yummiest.  In\nJavaScript, we have first-class language support for passing functions\naround, so I tend to use callbacks, simply because it requires no\nextra &ldquo;stuff&rdquo;.</p>\n\n<p>What&rsquo;s important to me is that an API be useful, performant, and easy to\nreason about.  When I&rsquo;m writing JavaScript, I care a lot about how\nV8 is going to optimize it, and so try to choose patterns that it can\noptimize nicely.  As of today, generators just aren&rsquo;t first-class\nenough, and Promises require an extra abstraction.  That may change\nsomeday, but these principles probably will not.</p>\n\n<p>So, I&rsquo;m going to say &ldquo;callbacks&rdquo; below, but you can mentally\nsubstitute whatever thing you like.  The fundamental points are\nequally relevant if you&rsquo;re using threads, or gotos, or any other\nabstraction or language for doing things asynchronously and\ncontrolling what the computer does next.</p>\n\n<p>Note that all of this <em>also</em> applies if your asynchronous API &ldquo;looks\nsynchronous&rdquo;.  Even if you design a thing so that I do:</p>\n\n<pre><code>x = foo();</code></pre>\n\n<p>and it&rsquo;s completely agnostic at authoring time whether <code>foo()</code> spins\non CPU or yields while it awaits a network response, being able to\nreason about the program means that I need to be able to know whether\n<em>other</em> parts of the program will be running while I&rsquo;m waiting for\n<code>foo()</code> to return a value to be put into <code>x</code>.</p>\n\n<p>So, even if the <em>syntax</em> is the same (which has its benefits as well\nas its drawbacks, of course), the <em>semantics</em> must be crisply defined.</p>\n\n<p>Or else Zalgo is released.</p>\n\n<h3>Do Not Release Zalgo</h3>\n\n<p>Warning: Before proceeding any further, <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">go read this excellent essay\nby\nHavoc</a>.</p>\n\n<p>If you haven&rsquo;t read <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Havoc&rsquo;s post on\ncallbacks</a>,\nthen you will perhaps be tempted to make silly arguments that make no\nsense, and demand justification for things that have been established\nbeyond any reasonable doubt long ago, or tell me that I&rsquo;m overstating\nthe issue.</p>\n\n<p>Have you <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">read Havoc&rsquo;s post on\ncallbacks</a>?\nYes?  Ok.</p>\n\n<p>If you didn&rsquo;t, shame on you. <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read\nit.</a>\nIf you still haven&rsquo;t, I&rsquo;ll sum up:</p>\n\n<blockquote>\n<p>If you have an API which takes a callback,<br />and <em>sometimes</em> that callback is called immediately,<br />and <em>other times</em> that callback is called at some point in the future,<br />then you will render any code using this API impossible to reason\nabout, and cause the release of <a href=\"http://knowyourmeme.com/memes/zalgo\">Zalgo</a>.</p>\n</blockquote>\n\n<p>Needless to say, releasing Zalgo onto unsuspecting users is extremely\ninappropriate.</p>\n\n<p>It&rsquo;s not the case that function-taking APIs must always call the\nfunction asynchronously.  For example, <code>Array.prototype.forEach</code> calls\nthe callback immediately, before returning.  <em>But then it never calls\nit again.</em></p>\n\n<p>Nor is it the case that function-taking APIs must always call the\nfunction synchronously.  For example, <code>setTimeout</code> and friends call\nthe callback after the current run-to-completion.  <em>But they always\nreturn before calling the callback.</em></p>\n\n<p>In other words, to avoid the release of Zalgo, exactly one of the\nfollowing must be true:</p>\n\n<pre><code>var after = false;\ncallbackTaker(function() {\n  assert(after === true);\n});\nafter = true;</code></pre>\n\n<p>OR:</p>\n\n<pre><code>var after = false;\ncallbackTaker(function() {\n  assert(after === false);\n});\nafter = true;</code></pre>\n\n<p>and in no case can you ever have a function where exactly one of these\nassertions is not guaranteed.</p>\n\n<h4>What about internal functions in my library that are not exposed?</h4>\n\n<p>Well, ok, but you&rsquo;re releasing Zalgo in your internal library.  I\ndon&rsquo;t recommend it.  Zalgo usually finds a way to sneak His Dark&#861;\nTend&#820;r&#801;i&#1161;ls out into the world.</p>\n\n<h4>What if I suspect that a function might try to release Zalgo?</h4>\n\n<p>This is a great question.  For example, perhaps you let users supply\nyour library with a callback-taking function, and you worry that they\nmight be incompetent or careless, but want to ensure that <em>your</em>\nlibrary does its best to keep Th&#847;e Da&#1161;rk Po&#324;y Lo&#856;r&#864;d HE &#769;C&#865;OM&#820;E&#824;S contained\nappropriately.</p>\n\n<p>Assuming that your platform has an event loop or some other kind of\nabstraction that you can hang stuff on, you can do something like\nthis:</p>\n\n<pre><code>function zalgoContainer(cbTaker, cb) {\n  var sync = true;\n  cbTaker(cbWrap);\n  sync = false;\n\n  function cbWrap(er, data) {\n    if (sync)\n      process.nextTick(function() {\n        cb(er, data);\n      });\n    else\n      cb(er, data);\n  }\n}</code></pre>\n\n<p>This uses Node&rsquo;s synthetic deferral function: <code>process.nextTick</code>,\nwhich runs the supplied callback at the end of the current\nrun-to-completion.  You can also use <code>setImmediate</code>, but that&rsquo;s\nslightly slower.  (Yes, yes, it&rsquo;s named badly; <code>setImmediate</code> is\nslightly <em>less</em> &ldquo;immediate&rdquo; and more &ldquo;next&rdquo; than <code>nextTick</code>, but this\nis an accident of history we cannot correct without a time machine.)</p>\n\n<h4>But isn&rsquo;t it faster to just call the callback right away?</h4>\n\n<p><a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read Havoc&rsquo;s blog post.</a></p>\n\n<p>Moving on.</p>\n\n<h3>Avoid Synthetic Deferrals</h3>\n\n<p>I know what you&rsquo;re thinking: <i>&ldquo;But you just told me to use\n<code>nextTick</code>!&rdquo;</i></p>\n\n<p>And yes, it&rsquo;s true, you should use synthetic deferrals when the only\nalternative is releasing Zalgo.  However, these synthetic deferrals\nshould be treated as a code smell.  They are a sign that your API\nmight not be optimally designed.</p>\n\n<p>Ideally, you should know whether something is going to be immediately\navailable, or not.  Realistically, you should be able to take a pretty\ndecent guess about whether the result is going to be immediately\navailable <em>most of the time</em>, or not, and then follow this handy\nguide:</p>\n\n<ul><li><p><strong>If the result is usually available right now, and performance\nmatters a lot:</strong></p>\n<ol><li>Check if the result is available.</li>\n<li>If it is, return it.</li>\n<li>If it is not, return an error code, set a flag, etc.</li>\n<li>Provide some Zalgo-safe mechanism for handling the error case\nand awaiting future availability.</li>\n</ol><p>Here&rsquo;s an silly example to illustrate the pattern:</p>\n<pre><code>var isAvailable = true;\nvar i = 0;\nfunction usuallyAvailable() {\n  i++;\n  if (i === 10) {\n    i = 0;\n    isAvailable = false;\n    setTimeout(function() {\n      isAvailable = true;\n      if (waiting.length) {\n        for (var cb = waiting.shift();\n             cb;\n             cb = waiting.shift()) {\n          cb();\n        }\n      }\n    });\n  }\n\n  return isAvailable ? i : new Error('not available');\n}\n\nfunction waitForAvailability(cb) {\n  // Could also defer this and just call it,\n  // but it is avoidable, which is the point.\n  if (isAvailable)\n    throw new Error(\"hey, dummy, check first!\");\n  waiting.push(cb);\n}</code></pre>\n<p>In this case, when the user calls <code>usuallyAvailable()</code> they&rsquo;ll get\na number between 0 and 9, 90% of the time.  It&rsquo;s on the caller to\ncheck the return value, see if it means that they have to wait,\netc.</p>\n<p>This makes the API a bit trickier to use, because the caller has\nto know to detect the error state.  If it&rsquo;s very rare, then\nthere&rsquo;s a chance that they might get surprised in production the\nfirst time it fails.  This is a communication problem, like most\nAPI design concerns, but if performance is critical, it <em>may</em> be\nworth the hit to avoid artificial deferrals in the common cases.</p>\n<p>Note that this is functionally equivalent to\n<code>O_NONBLOCK/EWOULDBLOCK/poll</code> pattern.  You try to do a thing,\nand if it is not available right now, it raises an error, and you\nwait until it IS available, and then try again.</p>\n</li>\n<li><p><strong>If the result is usually available right now, but performance\ndoesn&rsquo;t matter all that much</strong></p>\n<p>  For example, the function might only be called a few times at\n  startup, etc.</p>\n<p>  In this case, just follow the &ldquo;result is usually not available\n  right now&rdquo; approach.</p>\n<p>  Note that performance actually does matter much more often than\n  you probably realize.</p>\n</li>\n<li><p><strong>If the result is usually not available right now</strong></p>\n<ol><li>Take a callback.</li>\n<li>Artificially defer the callback if the data is available right\nnow.</li>\n</ol><p>Here&rsquo;s an example:</p>\n<pre><code>var cachedValue;\nfunction usuallyAsync(cb) {\n  if (cachedValue !== undefined)\n    process.nextTick(function() {\n      cb(cachedValue);\n    });\n  else\n    doSomeSlowThing(function(result) {\n      cb(cachedValue = result);\n    });\n}</code></pre>\n</li>\n</ul><p>The basic point here is that &ldquo;async&rdquo; is not some magic mustard you\nsmear all over your API to make it fast.  <strong>Asynchronous APIs do\nnot go faster.  They go slower.</strong>  However, they prevent <em>other</em> parts\nof the program from having to wait for them, so <em>overall</em> program\nperformance can be improved.</p>\n\n<p>Note that this applies to not just callbacks, but also to Promises and\nany other control-flow abstractions.  If your API is frequently\nreturning a Promise for a value that you know <em>right now</em>, then either\nyou are leaving performance on the table, or your Promise\nimplementation releases H&#821;&#856;&#865;e &#801;wh&#769;o&#864; &#822;Prom&#768;&#863;&#861;i&#820;s&#768;es&#768; o&#1161;&#822;nl&#808;&#863;y&#807; &#795;&#795;m&#820;&#864;&#861;a&#801;&#795;&#866;d&#801;n&#820;&#801;e&#861;s&#824;s&#864;,\nT&#802;&#1161;&#824;h&#820;&#823;&#824;&#802;&#553;&#865; &#856;&#864;N&#866;&#866;e&#847;&#847;&#866;&#864;z&#795;&#847;&#860;p&#824;&#768;&#789;&#864;&#553;&#769;&#861;&#861;r&#1161;&#795;&#769;&#864;d&#820;&#768;i&#820;&#789;&#1161;&#862;a&#820;&#801;&#861;&#864;n&#802;&#860;&#863;&#866;&#863; &#822;&#820;&#802;&#861;h&#823;&#789;&#864;&iacute;&#824;&#807;&#795;&#860;v&#822;&#802;&#866;&#865;e&#789;&#865;-&#824;&#768;&#861;m&#823;&#860;i&#795;&#856;&#862;&#326;&#795;&#856;&#863;&#1161;d&#822;&#822;&#801;&#807;&#860; &#823;&#795;&#862;o&#821;&#802;&#856;&#863;&#862;f&#822;&#802;&#768;&#866;&#866; &#822;&#807;&#863;&#865;c&#789;&#861;h&#822;&#768;&#856;&#856;&agrave;&#847;o&#1161;&#820;&#769;&#866;s&#824;&#856;&#856;&#861;&#862;.&#808;&#866;&#862;.</p>\n\n<p>So, don&rsquo;t do that.</p>\n\n<h3>Pick a Pattern and Stick With It</h3>\n\n<p>This really cannot be overstated.  Like the question of callbacks vs\nPromises vs whatever, the specific pattern that you choose doesn&rsquo;t\nmatter very much.  What <em>does</em> matter very much is that you stick to\nthat pattern with ruthless consistency.  The pattern should cover how\na user interacts with your API, and how errors are communicated.</p>\n\n<p>In Node.js, the callback pattern is:</p>\n\n<ol><li>Async functions take a single callback function as their final\nargument.</li>\n<li>That callback is called in the future with the first argument set\nto an <code>Error</code> object in the case of failure, and any additional\nresults as the subsequent arguments.</li>\n</ol><p>Why have the callback as the last argument?  Why make Error the first\narg?  It doesn&rsquo;t really matter very much.  Ostensibly, making the\ncallback the last arg is because</p>\n\n<pre><code>doSomething(a, b, c, d, function(er) {\n  ...\n})</code></pre>\n\n<p>scans a bit better than:</p>\n\n<pre><code>doSomething(function(er) {\n  ...\n}, a, b, c)</code></pre>\n\n<p>and putting the error first is so that it&rsquo;s always in the same place.</p>\n\n<p>There were other choices that could have been made.  But the important\nthing was just to pick one, and move forward with it.  This\nconsistency makes it much less difficult to convert Node APIs into\nother sorts of aync patterns, and greatly reduces the communication\nrequired to tell a user how to use a Node.js callback-taking API.\n </p>",
            "content_raw": "<p><i>New 2014-06-30: You can contain Zalgo with the <a href=\"http://npm.im/dezalgo\">dezalgo module</a></i></p>\n\n<p>Some people asked me to explain what <a href=\"http://lists.w3.org/Archives/Public/public-webapps/2013JulSep/0355.html\">I\nmeant</a>\nby \u201creleasing Zalgo\u201d in async APIs, so I thought I\u2019d share\nthe following guidelines.</p>\n\n<p>Please follow all of these rules in your programs.  If you deviate\nfrom them, you do so at the peril of your very sanity.</p>\n\n<h3>Get Over Your Provincial Boilerplate Preferences</h3>\n\n<p>Personally, I don\u2019t actually care all that much about the whole\npromises/callbacks/coroutines/generators debate.  It\u2019s provably\ntrivial to turn any callback-taking API into a promise-returning API\nor generator-yielding API or vice-versa.</p>\n\n<p>I\u2019m of the opinion that breaking functionality into small enough\nchunks that your boilerplate doesn\u2019t <em>matter</em> is much more important\nthan <em>which</em> boilerplate you decide tastes the yummiest.  In\nJavaScript, we have first-class language support for passing functions\naround, so I tend to use callbacks, simply because it requires no\nextra \u201cstuff\u201d.</p>\n\n<p>What\u2019s important to me is that an API be useful, performant, and easy to\nreason about.  When I\u2019m writing JavaScript, I care a lot about how\nV8 is going to optimize it, and so try to choose patterns that it can\noptimize nicely.  As of today, generators just aren\u2019t first-class\nenough, and Promises require an extra abstraction.  That may change\nsomeday, but these principles probably will not.</p>\n\n<p>So, I\u2019m going to say \u201ccallbacks\u201d below, but you can mentally\nsubstitute whatever thing you like.  The fundamental points are\nequally relevant if you\u2019re using threads, or gotos, or any other\nabstraction or language for doing things asynchronously and\ncontrolling what the computer does next.</p>\n\n<p>Note that all of this <em>also</em> applies if your asynchronous API \u201clooks\nsynchronous\u201d.  Even if you design a thing so that I do:</p>\n\n<pre><code>x = foo();</code></pre>\n\n<p>and it\u2019s completely agnostic at authoring time whether <code>foo()</code> spins\non CPU or yields while it awaits a network response, being able to\nreason about the program means that I need to be able to know whether\n<em>other</em> parts of the program will be running while I\u2019m waiting for\n<code>foo()</code> to return a value to be put into <code>x</code>.</p>\n\n<p>So, even if the <em>syntax</em> is the same (which has its benefits as well\nas its drawbacks, of course), the <em>semantics</em> must be crisply defined.</p>\n\n<p>Or else Zalgo is released.</p>\n\n<h3>Do Not Release Zalgo</h3>\n\n<p>Warning: Before proceeding any further, <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">go read this excellent essay\nby\nHavoc</a>.</p>\n\n<p>If you haven\u2019t read <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Havoc\u2019s post on\ncallbacks</a>,\nthen you will perhaps be tempted to make silly arguments that make no\nsense, and demand justification for things that have been established\nbeyond any reasonable doubt long ago, or tell me that I\u2019m overstating\nthe issue.</p>\n\n<p>Have you <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">read Havoc\u2019s post on\ncallbacks</a>?\nYes?  Ok.</p>\n\n<p>If you didn\u2019t, shame on you. <a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read\nit.</a>\nIf you still haven\u2019t, I\u2019ll sum up:</p>\n\n<blockquote>\n<p>If you have an API which takes a callback,<br>and <em>sometimes</em> that callback is called immediately,<br>and <em>other times</em> that callback is called at some point in the future,<br>then you will render any code using this API impossible to reason\nabout, and cause the release of <a href=\"http://knowyourmeme.com/memes/zalgo\">Zalgo</a>.</p>\n</blockquote>\n\n<p>Needless to say, releasing Zalgo onto unsuspecting users is extremely\ninappropriate.</p>\n\n<p>It\u2019s not the case that function-taking APIs must always call the\nfunction asynchronously.  For example, <code>Array.prototype.forEach</code> calls\nthe callback immediately, before returning.  <em>But then it never calls\nit again.</em></p>\n\n<p>Nor is it the case that function-taking APIs must always call the\nfunction synchronously.  For example, <code>setTimeout</code> and friends call\nthe callback after the current run-to-completion.  <em>But they always\nreturn before calling the callback.</em></p>\n\n<p>In other words, to avoid the release of Zalgo, exactly one of the\nfollowing must be true:</p>\n\n<pre><code class=\"lang-javascript\">var after = false;\ncallbackTaker(function() {\n  assert(after === true);\n});\nafter = true;</code></pre>\n\n<p>OR:</p>\n\n<pre><code class=\"lang-javascript\">var after = false;\ncallbackTaker(function() {\n  assert(after === false);\n});\nafter = true;</code></pre>\n\n<p>and in no case can you ever have a function where exactly one of these\nassertions is not guaranteed.</p>\n\n<h4>What about internal functions in my library that are not exposed?</h4>\n\n<p>Well, ok, but you\u2019re releasing Zalgo in your internal library.  I\ndon\u2019t recommend it.  Zalgo usually finds a way to sneak His Dark\u035d\nTend\u0334r\u0321i\u0489ls out into the world.</p>\n\n<h4>What if I suspect that a function might try to release Zalgo?</h4>\n\n<p>This is a great question.  For example, perhaps you let users supply\nyour library with a callback-taking function, and you worry that they\nmight be incompetent or careless, but want to ensure that <em>your</em>\nlibrary does its best to keep Th\u034fe Da\u0489rk Po\u0144y Lo\u0358r\u0360d HE \u0301C\u0361OM\u0334E\u0338S contained\nappropriately.</p>\n\n<p>Assuming that your platform has an event loop or some other kind of\nabstraction that you can hang stuff on, you can do something like\nthis:</p>\n\n<pre><code class=\"lang-javascript\">function zalgoContainer(cbTaker, cb) {\n  var sync = true;\n  cbTaker(cbWrap);\n  sync = false;\n\n  function cbWrap(er, data) {\n    if (sync)\n      process.nextTick(function() {\n        cb(er, data);\n      });\n    else\n      cb(er, data);\n  }\n}</code></pre>\n\n<p>This uses Node\u2019s synthetic deferral function: <code>process.nextTick</code>,\nwhich runs the supplied callback at the end of the current\nrun-to-completion.  You can also use <code>setImmediate</code>, but that\u2019s\nslightly slower.  (Yes, yes, it\u2019s named badly; <code>setImmediate</code> is\nslightly <em>less</em> \u201cimmediate\u201d and more \u201cnext\u201d than <code>nextTick</code>, but this\nis an accident of history we cannot correct without a time machine.)</p>\n\n<h4>But isn\u2019t it faster to just call the callback right away?</h4>\n\n<p><a href=\"http://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/\">Go read Havoc\u2019s blog post.</a></p>\n\n<p>Moving on.</p>\n\n<h3>Avoid Synthetic Deferrals</h3>\n\n<p>I know what you\u2019re thinking: <i>\u201cBut you just told me to use\n<code>nextTick</code>!\u201d</i></p>\n\n<p>And yes, it\u2019s true, you should use synthetic deferrals when the only\nalternative is releasing Zalgo.  However, these synthetic deferrals\nshould be treated as a code smell.  They are a sign that your API\nmight not be optimally designed.</p>\n\n<p>Ideally, you should know whether something is going to be immediately\navailable, or not.  Realistically, you should be able to take a pretty\ndecent guess about whether the result is going to be immediately\navailable <em>most of the time</em>, or not, and then follow this handy\nguide:</p>\n\n<ul><li><p><strong>If the result is usually available right now, and performance\nmatters a lot:</strong></p>\n<ol><li>Check if the result is available.</li>\n<li>If it is, return it.</li>\n<li>If it is not, return an error code, set a flag, etc.</li>\n<li>Provide some Zalgo-safe mechanism for handling the error case\nand awaiting future availability.</li>\n</ol><p>Here\u2019s an silly example to illustrate the pattern:</p>\n<pre><code class=\"lang-javascript\">var isAvailable = true;\nvar i = 0;\nfunction usuallyAvailable() {\n  i++;\n  if (i === 10) {\n    i = 0;\n    isAvailable = false;\n    setTimeout(function() {\n      isAvailable = true;\n      if (waiting.length) {\n        for (var cb = waiting.shift();\n             cb;\n             cb = waiting.shift()) {\n          cb();\n        }\n      }\n    });\n  }\n\n  return isAvailable ? i : new Error('not available');\n}\n\nfunction waitForAvailability(cb) {\n  // Could also defer this and just call it,\n  // but it is avoidable, which is the point.\n  if (isAvailable)\n    throw new Error(\"hey, dummy, check first!\");\n  waiting.push(cb);\n}</code></pre>\n<p>In this case, when the user calls <code>usuallyAvailable()</code> they\u2019ll get\na number between 0 and 9, 90% of the time.  It\u2019s on the caller to\ncheck the return value, see if it means that they have to wait,\netc.</p>\n<p>This makes the API a bit trickier to use, because the caller has\nto know to detect the error state.  If it\u2019s very rare, then\nthere\u2019s a chance that they might get surprised in production the\nfirst time it fails.  This is a communication problem, like most\nAPI design concerns, but if performance is critical, it <em>may</em> be\nworth the hit to avoid artificial deferrals in the common cases.</p>\n<p>Note that this is functionally equivalent to\n<code>O_NONBLOCK/EWOULDBLOCK/poll</code> pattern.  You try to do a thing,\nand if it is not available right now, it raises an error, and you\nwait until it IS available, and then try again.</p>\n</li>\n<li><p><strong>If the result is usually available right now, but performance\ndoesn\u2019t matter all that much</strong></p>\n<p>  For example, the function might only be called a few times at\n  startup, etc.</p>\n<p>  In this case, just follow the \u201cresult is usually not available\n  right now\u201d approach.</p>\n<p>  Note that performance actually does matter much more often than\n  you probably realize.</p>\n</li>\n<li><p><strong>If the result is usually not available right now</strong></p>\n<ol><li>Take a callback.</li>\n<li>Artificially defer the callback if the data is available right\nnow.</li>\n</ol><p>Here\u2019s an example:</p>\n<pre><code class=\"lang-javascript\">var cachedValue;\nfunction usuallyAsync(cb) {\n  if (cachedValue !== undefined)\n    process.nextTick(function() {\n      cb(cachedValue);\n    });\n  else\n    doSomeSlowThing(function(result) {\n      cb(cachedValue = result);\n    });\n}</code></pre>\n</li>\n</ul><p>The basic point here is that \u201casync\u201d is not some magic mustard you\nsmear all over your API to make it fast.  <strong>Asynchronous APIs do\nnot go faster.  They go slower.</strong>  However, they prevent <em>other</em> parts\nof the program from having to wait for them, so <em>overall</em> program\nperformance can be improved.</p>\n\n<p>Note that this applies to not just callbacks, but also to Promises and\nany other control-flow abstractions.  If your API is frequently\nreturning a Promise for a value that you know <em>right now</em>, then either\nyou are leaving performance on the table, or your Promise\nimplementation releases H\u0335\u0358\u0361e \u0321wh\u0301o\u0360 \u0336Prom\u0300\u035f\u035di\u0334s\u0300es\u0300 o\u0489\u0336nl\u0328\u035fy\u0327 \u031b\u031bm\u0334\u0360\u035da\u0321\u031b\u0362d\u0321n\u0334\u0321e\u035ds\u0338s\u0360,\nT\u0322\u0489\u0338h\u0334\u0337\u0338\u0322\u0229\u0361 \u0358\u0360N\u0362\u0362e\u034f\u034f\u0362\u0360z\u031b\u034f\u035cp\u0338\u0300\u0315\u0360\u0229\u0301\u035d\u035dr\u0489\u031b\u0301\u0360d\u0334\u0300i\u0334\u0315\u0489\u035ea\u0334\u0321\u035d\u0360n\u0322\u035c\u035f\u0362\u035f \u0336\u0334\u0322\u035dh\u0337\u0315\u0360\u00ed\u0338\u0327\u031b\u035cv\u0336\u0322\u0362\u0361e\u0315\u0361-\u0338\u0300\u035dm\u0337\u035ci\u031b\u0358\u035e\u0146\u031b\u0358\u035f\u0489d\u0336\u0336\u0321\u0327\u035c \u0337\u031b\u035eo\u0335\u0322\u0358\u035f\u035ef\u0336\u0322\u0300\u0362\u0362 \u0336\u0327\u035f\u0361c\u0315\u035dh\u0336\u0300\u0358\u0358\u00e0\u034fo\u0489\u0334\u0301\u0362s\u0338\u0358\u0358\u035d\u035e.\u0328\u0362\u035e.</p>\n\n<p>So, don\u2019t do that.</p>\n\n<h3>Pick a Pattern and Stick With It</h3>\n\n<p>This really cannot be overstated.  Like the question of callbacks vs\nPromises vs whatever, the specific pattern that you choose doesn\u2019t\nmatter very much.  What <em>does</em> matter very much is that you stick to\nthat pattern with ruthless consistency.  The pattern should cover how\na user interacts with your API, and how errors are communicated.</p>\n\n<p>In Node.js, the callback pattern is:</p>\n\n<ol><li>Async functions take a single callback function as their final\nargument.</li>\n<li>That callback is called in the future with the first argument set\nto an <code>Error</code> object in the case of failure, and any additional\nresults as the subsequent arguments.</li>\n</ol><p>Why have the callback as the last argument?  Why make Error the first\narg?  It doesn\u2019t really matter very much.  Ostensibly, making the\ncallback the last arg is because</p>\n\n<pre><code class=\"lang-javascript\">doSomething(a, b, c, d, function(er) {\n  ...\n})</code></pre>\n\n<p>scans a bit better than:</p>\n\n<pre><code class=\"lang-javascript\">doSomething(function(er) {\n  ...\n}, a, b, c)</code></pre>\n\n<p>and putting the error first is so that it\u2019s always in the same place.</p>\n\n<p>There were other choices that could have been made.  But the important\nthing was just to pick one, and move forward with it.  This\nconsistency makes it much less difficult to convert Node APIs into\nother sorts of aync patterns, and greatly reduces the communication\nrequired to tell a user how to use a Node.js callback-taking API.\n </p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "59142742143"
            }
        }
    ],
    "type": "text"
}