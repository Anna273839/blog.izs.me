{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544051896,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p class=\"small\">Edit: You should probably also read <a href=\"http://sandofsky.com/blog/git-workflow.html\"> Understanding the Git Workflow</a>.  Much more succinct explanation of the point that I dance around a lot below.  Almost as if we&rsquo;d had roughly the same ideas, but he squashed the messages more eloquently ;)</p>\n\n<p>A <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">recent article on git-merge vs git-rebase</a> kicked off a very interesting conversation on twitter the other day among a bunch of us nerds.</p>\n\n<p>It started with <a href=\"https://twitter.com/polotek\">Marco</a> saying</p>\n\n<blockquote><p>Good article on merge vs. rebase. It&rsquo;s pretty balanced, but I&rsquo;m still firmly against rebase after reading. <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">blog.sourcetreeapp.com/2012/08/21/mer\u2026</a><br/>\u2014 Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277541092184965120\" data-datetime=\"2012-12-08T22:32:07+00:00\">December 8, 2012</a></p></blockquote>\n\n<p>A few of us objected.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> I wouldn\u2019t recommend being \u201cfirmly\u201d against rebase. That\u2019s like being &ldquo;firmly&rdquo; against a particular coding style. Forest for trees.<br/>\u2014 Jason Smith (@_jhs) <a href=\"https://twitter.com/_jhs/status/277621735241695232\" data-datetime=\"2012-12-09T03:52:34+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>Then there were like a bazillion more replies back and forth, and it got too much for Twitter.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/polotek\">polotek</a> @<a href=\"https://twitter.com/rwaldron\">rwaldron</a> @<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/oscargodson\">oscargodson</a> I&rsquo;ll reply in blog format. ENOSPC.<br/>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/277812898095566849\" data-datetime=\"2012-12-09T16:32:11+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>So here I am writing a blog post now.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>I&rsquo;m pretty sure I stole this line from someone, but I couldn&rsquo;t find any reference earlier than <a href=\"https://groups.google.com/d/msg/nodejs/xFfzu9XIBvY/414wq6ZbS8gJ\">mine</a>, so maybe I made this up. It&rsquo;s a way of thinking about git that I really like:</p>\n\n<blockquote><p>cvs and svn are remote backups that you use to save your changes.<br/> git is an editor that you use to write your code&rsquo;s biography.<br/>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/13997541348\" data-datetime=\"2010-05-14T21:07:58+00:00\">May 14, 2010</a></p></blockquote>\n\n<p>So my reply to Marco was:</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> Git is an editor. &ldquo;Firmly against rebase&rdquo; is like being firmly against backspace.<br/>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/277656808959660032\" data-datetime=\"2012-12-09T06:11:56+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>I hope that some of the implication of that becomes clearer by the time I get to the end of this post.</p>\n\n<h3>&ldquo;tidy&rdquo;</h3>\n\n<p>A lot of the discussion of git-rebase fixates on keeping the commit history &ldquo;tidy&rdquo;.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> rebasing into a release branch is clean and tidy. You still have the data in your feature branch.<br/>\u2014 Emily Rose (@nexxylove) <a href=\"https://twitter.com/nexxylove/status/277659451849330688\" data-datetime=\"2012-12-09T06:22:26+00:00\">December 9, 2012</a></p></blockquote>\n\n<blockquote><p>@<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> what does clean and tidy buy besides a sense of satisfaction?<br/>\u2014 Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277689191037538305\" data-datetime=\"2012-12-09T08:20:37+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>The workflow that everyone is discussing seems to be:</p>\n\n<ul><li>Working on a feature branch</li>\n<li>Make some commits</li>\n<li>The upstream branch changes (because someone else pushed to it) and now it&rsquo;s time to merge it in.</li>\n<li>Do you <code>git pull --rebase</code> (so that you pretend to have always been working on the changes) or <code>git pull</code> the upstream (so that you get a merge commit)?</li>\n</ul><p><a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">The article</a> that started the conversation really only discussed this single use of rebase.</p>\n\n<p>However, rebase is much more versatile that this. <strong>Rebase is a tool that can be used to arbitrarily edit the commit history.</strong> If that sounds <em>universally</em> scary or bad, I&rsquo;d argue that your understanding of &ldquo;edit&rdquo; and &ldquo;history&rdquo; are perhaps a bit limited.</p>\n\n<h3>Tidying Up History</h3>\n\n<p>Consider the following two stories:</p>\n\n<h4>Story 1</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I walked down Adams Street to Whole Foods so I could buy milk.</p>\n  \n  <p>I mean, no, Whole Foods isn&rsquo;t on Adams, it&rsquo;s on Bay Place, so I\n  walked down Bay Place to get to Whole Foods to buy milk.</p>\n  \n  <p>Oh, but first, I had to walk down Grand Ave, then take a right on\n  Bay Place, then parked my car&ndash;shit.</p>\n  \n  <p>I got in my car, drove down Grand Ave, took a right on Bay Place,\n  parked my car at Whole Foods, and needed my wallet, so&hellip; right, ok,\n  so before I drove in my car, I got my wallet, drove to Whole Foods\n  on Bay Place by going down Grand, and then bought some milk.</p>\n  \n  <p>No, wait, I didn&rsquo;t to whole foods, that&rsquo;s right, because they&rsquo;re\n  crazy expensive.  I went to the Grand Lake Safeway.</p>\n</blockquote>\n\n<h4>Story 2</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I drove to the Grand Lake Safeway and bought some milk.</p>\n</blockquote>\n\n<p>This seems silly, but the benefit of a tool that can tidy up history is that <em>you get to write whatever crazy awful untidy history you want</em>, while you&rsquo;re experimenting and editing code, and then organize it later. When I&rsquo;m actually writing code, my commit history looks a lot like Story 1.</p>\n\n<p>Typically I work on a <code>blahblah-feature-name-wip</code> branch, and then rebase it down to a <code>blahblah-feature-name</code> branch when I&rsquo;ve got it into a working state and understand how it&rsquo;s supposed to go. The <code>-wip</code> branches are a godawful mess of <code>kinda working, except breaks all the fs tests</code> commits, and <code>Revert \"kinda working, except...\"</code> commits. The benefit of tidiness then, is that I can track my work in a more or less play-by-play fashion, and still end up with something readable.</p>\n\n<p>Is it better, then, to push all those play-by-play commits?</p>\n\n<p>What is the <strong>purpose</strong> of a git history? Is it a forensic record of every edit to a file? Or is it a way for others to determine the <em>reason</em> for those edits?</p>\n\n<p>My answer is: It&rsquo;s both, depending on context.</p>\n\n<p>I keep the <code>-wip</code> branch around for as long as the forensics are interesting. There&rsquo;s a lot of times that I notice something is broken in the &ldquo;real&rdquo; feature branch, and think, &ldquo;Oh, I could&rsquo;ve sworn that was working yesterday.. what was I doing..?&rdquo; At moments like those, the forensic record of my thoughts is invaluable.</p>\n\n<p>But if someone, years later, is looking at a bit of code that seems strange, and they run <code>git blame</code> on the file, and track the edit back to <code>Revert \"Revert \"hmm this seems broken but it sorta works i dunno\"\"</code> then they&rsquo;ll be rightly upset with me for letting such useless garbage into the repository.</p>\n\n<p>One possible answer is: &ldquo;Don&rsquo;t write code like that.&rdquo; Write a test for the feature, then write the code to make the test pass, and never make mistakes.</p>\n\n<p>The problem is that I&rsquo;m not smart enough to not make mistakes and know exactly what code to write before I start writing it. Also, I enjoy the liberty of messing around, tracking every bit, and still sharing an elegant useful story with my future collaborators (including future-isaacs.)</p>\n\n<h3>Forensics - Platform vs Service</h3>\n\n<p>It&rsquo;s very interesting to me, but not at all surprising, that the people in this conversation that were most in favor of &ldquo;merge only, never rebase&rdquo; are generally working on a production web service (Yammer, most of them), and the people who favored rebase seemed to be working primarily on platforms (Node and npm in my case; JQuery Johnny5 and others in the case of Rick Waldron.) A few folks (mikeal, Jason Smith) work on both sorts of systems, and of course this breakdown is imprecise.</p>\n\n<p>I&rsquo;ve seen a similar reaction to rebase-vs-merge in coworkers at Yahoo, Kakai, and Joyent. (Basically ever since I&rsquo;ve been using git, and exposed to this sort of conversation.) People who spend most of their day debugging production issues want the history to be as detailed and &ldquo;forensically accurate&rdquo; as possible. People who spend most of their day debugging platforms or libraries tend to want the history to be the most &ldquo;elegant story&rdquo; possible.</p>\n\n<p>For the purpose of this discussion, &ldquo;Yammer&rdquo; is a service, and &ldquo;node&rdquo; is a platform. You install a platform and then build your program on it, and you install updates yourself. You use a service in production on someone else&rsquo;s computers, and it is updated by other people. (From this point of view, &ldquo;PaaS&rdquo; is actually a Service, not a Platform. Pedants please direct all complaints to /dev/null.)</p>\n\n<p>There is of course some overlap in the concerns. I definitely do not want any changes whatsoever to the history of release branches in the <a href=\"https://github.com/joyent/node\">joyent/node</a>, even if it means the occasional messy revert. If something has gone out as a part of a release, then it is <strong>definitely</strong> off-limits, and anyone who rebases that into some other shape will be ruthlessly punished (perhaps with the removal of commit access, if the infraction is repeated.)</p>\n\n<p>I think that this split comes down to a simple question: When encountering a new problem, are you likely to use <code>git-bisect</code> to track it down, or are you going to revert to some known-good state and go from there?</p>\n\n<h3>Git&rsquo;s Killer Feature: Bisect</h3>\n\n<p>If you have never used git bisect, then you don&rsquo;t fully understand why git is useful. Git bisect is one of those tools that, once you use it, you realize that there is simply no way you could have ever debugged without it. And, the first time you try to bisect over a commit history littered with merge commits and reverts and broken states, you&rsquo;ll see why &ldquo;tidiness&rdquo; is so powerful.</p>\n\n<p>For the uninitiated, here&rsquo;s a run-down of what bisect does, in broad strokes:</p>\n\n<ol><li>You run your tests, and realize &ldquo;Oh, shit, it&rsquo;s busted.&rdquo;</li>\n<li>You know that it was working yesterday (or whenever).</li>\n<li>You run <code>git bisect bad</code>.  (Answer &ldquo;yes&rdquo; to the prompt.)</li>\n<li>You do <code>git checkout &lt;known-good-state&gt;</code>.  (Run the test again\njust to make sure that you&rsquo;re not mis-remembering.)</li>\n<li>Run <code>git bisect good</code>.</li>\n<li>Git will proceed to hop you to various commits, at which point you\nrun your test and do <code>git bisect good</code> if it&rsquo;s good, or <code>git bisect\nbad</code> if it&rsquo;s bad.  (If necessary, you can also check out commits\nmanually, and mark them as good/bad.)</li>\n<li>Shockingly quickly, git tells you which commit was the first bad\none.</li>\n</ol><p>Because the &ldquo;test&rdquo; can be literally anything, I often use this to track down which commit in libuv broke something in node, if the node bisect shows that it was a <code>update libuv to deadbeef</code> type of commit that is the culprit. I run the <code>git bisect</code> in the libuv repo, and the &ldquo;test&rdquo; is putting the libuv code in node&rsquo;s deps/uv folder, and running the node test.</p>\n\n<p>To make bisect even more interesting, you can add something like this to your <code>~/.gitconfig</code> file:</p>\n\n<pre><code>[alias]\n  lg = log --graph --pretty=format:'%Cred%h%Creset %C(yellow)%an%d%Creset %s %Cgreen(%cr)%Creset' --date=relative\n</code></pre>\n\n<p>Then running <code>git lg</code> will show you a very terse listing of the history, which shows all the bisect tags.</p>\n\n<p>As you can imagine, this works most efficiently when you have a relatively straightforward history. If you have messy back and forth play-by-play commits, where tests are breaking and un-breaking repeatedly, or the build is failing occasionally, then bisect is essentially worthless. Bisect can go over merge commits, but it becomes a lot less trivial to track what it&rsquo;s doing, and I&rsquo;ve found a lot of times the &ldquo;first bad commit&rdquo; is the merge commit, which is pretty much useless.</p>\n\n<p>Tidiness makes bisect even more powerful. I&rsquo;d use git without bisect, because it&rsquo;s the de facto standard of the open source world. But without bisect, I would love git half as much. If I could make bisect even more powerful by rubbing grease on my elbows, I&rsquo;d do it.</p>\n\n<p>This is not about a sense of satisfaction. Tidiness is about taking 20 minutes to track down a bug, instead of taking all day.</p>\n\n<h3>Upstream Motion and Large Feature Branches</h3>\n\n<p>Occasionally you have a &ldquo;Feature&rdquo; branch that is really a major refactor of some sort, which cannot be accomplished in a single burst of coding. My most recent example is <a href=\"https://github.com/joyent/node/compare/streams2\">streams2</a>, which I&rsquo;ve been working on for a few weeks. (There&rsquo;s been a lot of input and feedback from many others, and the code has been used as a <a href=\"https://npm.im/readable-stream\">userland module</a>, so this isn&rsquo;t a code-dump in progress.)</p>\n\n<p>In order to not end up in a state where we have a zillion conflicts to resolve, and to be able to bisect out problems, I&rsquo;ve been continually rebasing streams2 on top of the upstream master branch.</p>\n\n<p>This is especially important when a change comes into the upstream master that breaks my feature branch, <em>but doesn&rsquo;t break master</em>. I&rsquo;m not sure how I&rsquo;d even go about testing that if I was merging master into streams2 (unless I were to merge each commit individually, which is kind of absurd).</p>\n\n<p>Here&rsquo;s how I found the source of the problem:</p>\n\n<ol><li>Check out master into a new &ldquo;clean&rdquo; workspace. (NB: I didn&rsquo;t have to download anything again. I could just do <code>cd ..; git clone ./node ./node-clean</code>, and then <code>git pull origin master</code>, since &ldquo;origin&rdquo; is the &ldquo;streams2&rdquo; workspace.)</li>\n<li>Run <code>git bisect bad</code>.</li>\n<li>Check out master from 4 weeks ago, which I&rsquo;m pretty sure worked. (Could have probably been a bit more conservative, but who cares? Bisect uses the magic of a binary search, so it&rsquo;s probably just one extra test!)</li>\n<li>Just to make sure, in the first workspace, rebase streams2 onto that 4-week-old commit. (Because streams2 was already based on master, I did this via <code>git rebase -i &lt;old-commit&gt;</code> and then deleted all the the lines that were above the first streams2 commit.) Sure enough, test passes fine.</li>\n<li>Back in the &ldquo;clean&rdquo; workspace, run <code>git bisect good</code>.</li>\n<li>Repeat step 4 in the &ldquo;streams2&rdquo; workspace, running <code>git bisect good</code> or <code>git bisect bad</code> in the &ldquo;clean&rdquo; workspace.</li>\n</ol><p>I&rsquo;m sure that there was probably a simpler way to do this. Maybe even some argument to bisect to tell it to rebase onto the commit, or a shell script that&rsquo;d do it all for me. But this worked, was fast, and totally got the job done. I don&rsquo;t even know how I would have figured that out otherwise.</p>\n\n<p>(In this case, the culprit was a libuv update. Bisecting through libuv using the technique I described above tracked it down to a <code>remove libev</code> mega-commit, so the moral of the story is that, even with great tools, dependencies suck sometimes.)</p>\n\n<p>Seriously. If you&rsquo;re doing a big refactor that takes some time, and the upstream root is changing, how do you manage to find these kinds of issues? If I was merging in, all I&rsquo;d know is that the merge commit made the test fail, but the test <em>doesn&rsquo;t</em> fail on master. In this case it&rsquo;s only the combination that is problematic.</p>\n\n<p>I don&rsquo;t know how to find or solve that sort of problem without rebase. I&rsquo;m sure that there&rsquo;s some way, because I vaguely remember handling these kinds of issues when I used CVS and SVN, but it&rsquo;s all hazy now that I&rsquo;m spoiled by bisect&rsquo;s awesome mightiness and the power of a mutable history.</p>\n\n<h3>Taking Patches and &ldquo;Ideal Workflows&rdquo;</h3>\n\n<p>As the maintainer of several open source projects, a few of which get a lot of outside contributions, I am faced with a choice:</p>\n\n<ol><li>Make every potential contributor follow the ideal workflow (for some value of &ldquo;ideal&rdquo;), and reject a lot of patches because they are &ldquo;incorrect&rdquo; in some trivial way.</li>\n<li>Be ok with using <code>git am</code> and <code>git rebase</code> occasionally.</li>\n</ol><p>That to me is a nobrainer. My approach to contributions is closer to the &ldquo;email a patch&rdquo; model than the &ldquo;click the green merge button&rdquo; approach. Having that many merge commits would fuck up my precious bisect, and I <strong>always</strong> want to test the commit locally before pushing it live.</p>\n\n<p>This doesn&rsquo;t mean that I don&rsquo;t use github&rsquo;s pull request features. On the contrary, I love them! They&rsquo;re a great lightweight way to do discussion and code reviews, they integrate well with email, and when it&rsquo;s ready to accept, I can do:</p>\n\n<pre><code>curl <a href=\"https://github.com/joyent/node/pulls/12345.patch\">https://github.com/joyent/node/pulls/12345.patch</a> | git am\n</code></pre>\n\n<p>Or to pull just one commit:</p>\n\n<pre><code>curl <a href=\"https://github.com/john-q-contributor/node/deadbeef00.patch\">https://github.com/john-q-contributor/node/deadbeef00.patch</a> | git am\n</code></pre>\n\n<p>Did the user have a long commit message that is in broken english and will be confusing later? No problem. <code>git rebase -i HEAD^</code>, and reword it. Did they make some minor lint mistake? No matter. <code>make jslintfix &amp;&amp; gci -am 'lint fixup'</code> and then squash the commits together.  Did they put 3 features in one commit?  Easy, just do a <code>git rebase -i</code>, mark the commit for editing, then split it up into 3.  They get credit for the work that they did, and I get a history that&rsquo;s easy to read with a minimum of clutter.  In the most extreme case, I can even use <code>git format-patch</code> to output a patch file, edit it manually, and then <code>git am</code> that puppy.</p>\n\n<p>Rebase, am, and apply allow a project lead to be liberal in what they accept, and strict in what they send.</p>\n\n<p>Yes, this can all be abused.  So, don&rsquo;t abuse it.  Great power great responsibility blah blah blah.  In fact it&rsquo;s pretty easy to not fuck up, far easier than <em>actually</em> writing perfect code or getting contributors to make perfect commits.  If you do mess it up, oh well, there are plenty of forks; just reset and start over.</p>\n\n<h3>It&rsquo;s About History</h3>\n\n<p>It would be unreasonable to say that you should <em>always</em> use rebase instead of merge. For example, we routinely merge node&rsquo;s stable branch into master. Rebasing master onto the latest stable branch would destroy the history of all our previous unstable releases, and would be much harder to manage.</p>\n\n<p>In the case of that &ldquo;big feature branch&rdquo; for streams2, even if it ends up being a fast-forward due to being rebased onto the latest master, I&rsquo;m going to merge it in with <code>--no-ff</code> to <em>force</em> a merge commit, so that it&rsquo;s easy to pluck off if it turns out that the feature is actually crap.</p>\n\n<p>Git is a tool for managing content. There are a lot of ways to manage content. If something has been pushed live (or even &ldquo;pushed upstream&rdquo;) then you probably want to maintain forensic-level control over it.</p>\n\n<p>I think of &ldquo;history&rdquo; in terms of levels of granularity.</p>\n\n<p>Take for example, the assassination of Abraham Lincoln, an extremely relevant historical event in the history of the United States.</p>\n\n<p>At the lowest level of granularity, there&rsquo;s a lot of first-hand data: the eye-witness accounts that were given to police at the scene, the notes from the doctors in the ambulance and at the hospital where Lincoln was rushed after being shot, the descriptions and reports of other forensic evidence at the scene, the writings of John Wilkes Booth and the testimony of his conspirators (who all failed in their missions, for various reasons). There&rsquo;s also the context of the Civil War being in the process of ending (but that being in some dispute at the time). There&rsquo;s the account of the Union soldiers who tracked Booth down to a barn, set it on fire, then shot him as he fled, and the account of John St. Helen, who claimed to actually be John Wilkes Booth, having escaped and lived under a pseudonym in Texas for years, before committing suicide.</p>\n\n<p>You don&rsquo;t learn any of that in history class, because reading police reports makes it significantly more difficult to understand the story. <em>Some</em> context is great, but reading 25 conflicting eye-witness reports is not actually that useful over a hundred years later. Sure, we keep them around, just in case, but what you really want to know is just <em>what actually happened</em>. So, on top of those low-level accounts, we have various different accounts that go into different levels of detail, resolving and synthesizing the inconsistencies into a coherent story. At the highest level of history, you have the kids&rsquo; book version: &ldquo;Abraham Lincoln was the president during the Civil War. He abolished slavery, and then got shot in a theater.&rdquo;</p>\n\n<p>The <code>-wip</code> branches are my version of the conflicting police reports. The feature branch is a tidied up version which is actually useful, but probably still too detailed for most people to want to parse through. The ChangeLog is the effective &ldquo;what happened when&rdquo; sort of history, and at the highest level, you&rsquo;ll have a tweet from @nodejs that says &ldquo;Version 0.9.5 Released - streams2 support!&rdquo; with a link go to download it.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>One objection to the &ldquo;git is an editor&rdquo; mindset is that it&rsquo;s actually a database.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> Git isn&rsquo;t an editor, it&rsquo;s a database. It should keep a record of everything that happens with tracked files. Rebase loses data<br/>\u2014 Daniel Erickson (@TechWraith) <a href=\"https://twitter.com/TechWraith/status/277658833772486657\" data-datetime=\"2012-12-09T06:19:59+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>Of course, the problem with that is that a text file can be a database also, and you still use an editor to edit it; and a database is just a fancy editor for manipulating and retrieving blocks of data off a disk, and provides some ways to manipulate that data that take advantage of its regularity.</p>\n\n<p>Many &ldquo;databases&rdquo; have mechanisms to delete data.  (In fact, all that I know of have something like this.)  Losing data is only a problem if you lose data that you care about; losing data that you <em>don&rsquo;t</em> care about increases the overall understanding and makes the data that you <em>do</em> care about easier to get to.</p>\n\n<p>Use the tools wisely.  Use the editor to tell a good story, the right kind of story that your application needs told.  If you need forensic details of every change to your production service, well good news, git can do that!  If you need a clear explanation of the reasoning behind features in your library, git is great for that, also.  Like a good editor, it can be used to tell a variety of different kinds of stories.  Like a good database, it gives you the tools to organize your data into the shape that is most useful to you.</p>\n\n<p>The backspace key is very dangerous.  You can delete an entire file with it!  But the trade-offs are worth the benefit.  For the same reason that you delete code rather than comment it out (because it&rsquo;s in the git history, so why keep the clutter?) it&rsquo;s also great to rebase work-in-progress branches into a good state for their final merge.  Some aspects of history are ok to lose.  In many situations, <em>not</em> losing that bit of history makes the story harder to follow.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2012-12-10 19:05:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 37650663670,
    "is_blocks_post_format": false,
    "note_count": 26,
    "post_url": "http://blog.izs.me/post/37650663670/git-rebase",
    "reblog": {
        "comment": "<p class=\"small\">Edit: You should probably also read <a href=\"http://sandofsky.com/blog/git-workflow.html\"> Understanding the Git Workflow</a>.  Much more succinct explanation of the point that I dance around a lot below.  Almost as if we\u2019d had roughly the same ideas, but he squashed the messages more eloquently ;)</p>\n\n<p>A <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">recent article on git-merge vs git-rebase</a> kicked off a very interesting conversation on twitter the other day among a bunch of us nerds.</p>\n\n<p>It started with <a href=\"https://twitter.com/polotek\">Marco</a> saying</p>\n\n<blockquote><p>Good article on merge vs. rebase. It\u2019s pretty balanced, but I\u2019m still firmly against rebase after reading. <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">blog.sourcetreeapp.com/2012/08/21/mer\u2026</a><br>\u2014 Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277541092184965120\" data-datetime=\"2012-12-08T22:32:07+00:00\">December 8, 2012</a></p></blockquote>\n\n<p>A few of us objected.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> I wouldn\u2019t recommend being \u201cfirmly\u201d against rebase. That\u2019s like being \u201cfirmly\u201d against a particular coding style. Forest for trees.<br>\u2014 Jason Smith (@_jhs) <a href=\"https://twitter.com/_jhs/status/277621735241695232\" data-datetime=\"2012-12-09T03:52:34+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>Then there were like a bazillion more replies back and forth, and it got too much for Twitter.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/polotek\">polotek</a> @<a href=\"https://twitter.com/rwaldron\">rwaldron</a> @<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/oscargodson\">oscargodson</a> I\u2019ll reply in blog format. ENOSPC.<br>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/277812898095566849\" data-datetime=\"2012-12-09T16:32:11+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>So here I am writing a blog post now.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>I\u2019m pretty sure I stole this line from someone, but I couldn\u2019t find any reference earlier than <a href=\"https://groups.google.com/d/msg/nodejs/xFfzu9XIBvY/414wq6ZbS8gJ\">mine</a>, so maybe I made this up. It\u2019s a way of thinking about git that I really like:</p>\n\n<blockquote><p>cvs and svn are remote backups that you use to save your changes.<br> git is an editor that you use to write your code\u2019s biography.<br>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/13997541348\" data-datetime=\"2010-05-14T21:07:58+00:00\">May 14, 2010</a></p></blockquote>\n\n<p>So my reply to Marco was:</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> Git is an editor. \u201cFirmly against rebase\u201d is like being firmly against backspace.<br>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/277656808959660032\" data-datetime=\"2012-12-09T06:11:56+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>I hope that some of the implication of that becomes clearer by the time I get to the end of this post.</p>\n\n<h3>\u201ctidy\u201d</h3>\n\n<p>A lot of the discussion of git-rebase fixates on keeping the commit history \u201ctidy\u201d.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> rebasing into a release branch is clean and tidy. You still have the data in your feature branch.<br>\u2014 Emily Rose (@nexxylove) <a href=\"https://twitter.com/nexxylove/status/277659451849330688\" data-datetime=\"2012-12-09T06:22:26+00:00\">December 9, 2012</a></p></blockquote>\n\n<blockquote><p>@<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> what does clean and tidy buy besides a sense of satisfaction?<br>\u2014 Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277689191037538305\" data-datetime=\"2012-12-09T08:20:37+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>The workflow that everyone is discussing seems to be:</p>\n\n<ul><li>Working on a feature branch</li>\n<li>Make some commits</li>\n<li>The upstream branch changes (because someone else pushed to it) and now it\u2019s time to merge it in.</li>\n<li>Do you <code>git pull --rebase</code> (so that you pretend to have always been working on the changes) or <code>git pull</code> the upstream (so that you get a merge commit)?</li>\n</ul><p><a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">The article</a> that started the conversation really only discussed this single use of rebase.</p>\n\n<p>However, rebase is much more versatile that this. <strong>Rebase is a tool that can be used to arbitrarily edit the commit history.</strong> If that sounds <em>universally</em> scary or bad, I\u2019d argue that your understanding of \u201cedit\u201d and \u201chistory\u201d are perhaps a bit limited.</p>\n\n<h3>Tidying Up History</h3>\n\n<p>Consider the following two stories:</p>\n\n<h4>Story 1</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I walked down Adams Street to Whole Foods so I could buy milk.</p>\n  \n  <p>I mean, no, Whole Foods isn\u2019t on Adams, it\u2019s on Bay Place, so I\n  walked down Bay Place to get to Whole Foods to buy milk.</p>\n  \n  <p>Oh, but first, I had to walk down Grand Ave, then take a right on\n  Bay Place, then parked my car\u2013shit.</p>\n  \n  <p>I got in my car, drove down Grand Ave, took a right on Bay Place,\n  parked my car at Whole Foods, and needed my wallet, so\u2026 right, ok,\n  so before I drove in my car, I got my wallet, drove to Whole Foods\n  on Bay Place by going down Grand, and then bought some milk.</p>\n  \n  <p>No, wait, I didn\u2019t to whole foods, that\u2019s right, because they\u2019re\n  crazy expensive.  I went to the Grand Lake Safeway.</p>\n</blockquote>\n\n<h4>Story 2</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I drove to the Grand Lake Safeway and bought some milk.</p>\n</blockquote>\n\n<p>This seems silly, but the benefit of a tool that can tidy up history is that <em>you get to write whatever crazy awful untidy history you want</em>, while you\u2019re experimenting and editing code, and then organize it later. When I\u2019m actually writing code, my commit history looks a lot like Story 1.</p>\n\n<p>Typically I work on a <code>blahblah-feature-name-wip</code> branch, and then rebase it down to a <code>blahblah-feature-name</code> branch when I\u2019ve got it into a working state and understand how it\u2019s supposed to go. The <code>-wip</code> branches are a godawful mess of <code>kinda working, except breaks all the fs tests</code> commits, and <code>Revert \"kinda working, except...\"</code> commits. The benefit of tidiness then, is that I can track my work in a more or less play-by-play fashion, and still end up with something readable.</p>\n\n<p>Is it better, then, to push all those play-by-play commits?</p>\n\n<p>What is the <strong>purpose</strong> of a git history? Is it a forensic record of every edit to a file? Or is it a way for others to determine the <em>reason</em> for those edits?</p>\n\n<p>My answer is: It\u2019s both, depending on context.</p>\n\n<p>I keep the <code>-wip</code> branch around for as long as the forensics are interesting. There\u2019s a lot of times that I notice something is broken in the \u201creal\u201d feature branch, and think, \u201cOh, I could\u2019ve sworn that was working yesterday.. what was I doing..?\u201d At moments like those, the forensic record of my thoughts is invaluable.</p>\n\n<p>But if someone, years later, is looking at a bit of code that seems strange, and they run <code>git blame</code> on the file, and track the edit back to <code>Revert \"Revert \"hmm this seems broken but it sorta works i dunno\"\"</code> then they\u2019ll be rightly upset with me for letting such useless garbage into the repository.</p>\n\n<p>One possible answer is: \u201cDon\u2019t write code like that.\u201d Write a test for the feature, then write the code to make the test pass, and never make mistakes.</p>\n\n<p>The problem is that I\u2019m not smart enough to not make mistakes and know exactly what code to write before I start writing it. Also, I enjoy the liberty of messing around, tracking every bit, and still sharing an elegant useful story with my future collaborators (including future-isaacs.)</p>\n\n<h3>Forensics - Platform vs Service</h3>\n\n<p>It\u2019s very interesting to me, but not at all surprising, that the people in this conversation that were most in favor of \u201cmerge only, never rebase\u201d are generally working on a production web service (Yammer, most of them), and the people who favored rebase seemed to be working primarily on platforms (Node and npm in my case; JQuery Johnny5 and others in the case of Rick Waldron.) A few folks (mikeal, Jason Smith) work on both sorts of systems, and of course this breakdown is imprecise.</p>\n\n<p>I\u2019ve seen a similar reaction to rebase-vs-merge in coworkers at Yahoo, Kakai, and Joyent. (Basically ever since I\u2019ve been using git, and exposed to this sort of conversation.) People who spend most of their day debugging production issues want the history to be as detailed and \u201cforensically accurate\u201d as possible. People who spend most of their day debugging platforms or libraries tend to want the history to be the most \u201celegant story\u201d possible.</p>\n\n<p>For the purpose of this discussion, \u201cYammer\u201d is a service, and \u201cnode\u201d is a platform. You install a platform and then build your program on it, and you install updates yourself. You use a service in production on someone else\u2019s computers, and it is updated by other people. (From this point of view, \u201cPaaS\u201d is actually a Service, not a Platform. Pedants please direct all complaints to /dev/null.)</p>\n\n<p>There is of course some overlap in the concerns. I definitely do not want any changes whatsoever to the history of release branches in the <a href=\"https://github.com/joyent/node\">joyent/node</a>, even if it means the occasional messy revert. If something has gone out as a part of a release, then it is <strong>definitely</strong> off-limits, and anyone who rebases that into some other shape will be ruthlessly punished (perhaps with the removal of commit access, if the infraction is repeated.)</p>\n\n<p>I think that this split comes down to a simple question: When encountering a new problem, are you likely to use <code>git-bisect</code> to track it down, or are you going to revert to some known-good state and go from there?</p>\n\n<h3>Git\u2019s Killer Feature: Bisect</h3>\n\n<p>If you have never used git bisect, then you don\u2019t fully understand why git is useful. Git bisect is one of those tools that, once you use it, you realize that there is simply no way you could have ever debugged without it. And, the first time you try to bisect over a commit history littered with merge commits and reverts and broken states, you\u2019ll see why \u201ctidiness\u201d is so powerful.</p>\n\n<p>For the uninitiated, here\u2019s a run-down of what bisect does, in broad strokes:</p>\n\n<ol><li>You run your tests, and realize \u201cOh, shit, it\u2019s busted.\u201d</li>\n<li>You know that it was working yesterday (or whenever).</li>\n<li>You run <code>git bisect bad</code>.  (Answer \u201cyes\u201d to the prompt.)</li>\n<li>You do <code>git checkout &lt;known-good-state&gt;</code>.  (Run the test again\njust to make sure that you\u2019re not mis-remembering.)</li>\n<li>Run <code>git bisect good</code>.</li>\n<li>Git will proceed to hop you to various commits, at which point you\nrun your test and do <code>git bisect good</code> if it\u2019s good, or <code>git bisect\nbad</code> if it\u2019s bad.  (If necessary, you can also check out commits\nmanually, and mark them as good/bad.)</li>\n<li>Shockingly quickly, git tells you which commit was the first bad\none.</li>\n</ol><p>Because the \u201ctest\u201d can be literally anything, I often use this to track down which commit in libuv broke something in node, if the node bisect shows that it was a <code>update libuv to deadbeef</code> type of commit that is the culprit. I run the <code>git bisect</code> in the libuv repo, and the \u201ctest\u201d is putting the libuv code in node\u2019s deps/uv folder, and running the node test.</p>\n\n<p>To make bisect even more interesting, you can add something like this to your <code>~/.gitconfig</code> file:</p>\n\n<pre><code>[alias]\n  lg = log --graph --pretty=format:'%Cred%h%Creset %C(yellow)%an%d%Creset %s %Cgreen(%cr)%Creset' --date=relative\n</code></pre>\n\n<p>Then running <code>git lg</code> will show you a very terse listing of the history, which shows all the bisect tags.</p>\n\n<p>As you can imagine, this works most efficiently when you have a relatively straightforward history. If you have messy back and forth play-by-play commits, where tests are breaking and un-breaking repeatedly, or the build is failing occasionally, then bisect is essentially worthless. Bisect can go over merge commits, but it becomes a lot less trivial to track what it\u2019s doing, and I\u2019ve found a lot of times the \u201cfirst bad commit\u201d is the merge commit, which is pretty much useless.</p>\n\n<p>Tidiness makes bisect even more powerful. I\u2019d use git without bisect, because it\u2019s the de facto standard of the open source world. But without bisect, I would love git half as much. If I could make bisect even more powerful by rubbing grease on my elbows, I\u2019d do it.</p>\n\n<p>This is not about a sense of satisfaction. Tidiness is about taking 20 minutes to track down a bug, instead of taking all day.</p>\n\n<h3>Upstream Motion and Large Feature Branches</h3>\n\n<p>Occasionally you have a \u201cFeature\u201d branch that is really a major refactor of some sort, which cannot be accomplished in a single burst of coding. My most recent example is <a href=\"https://github.com/joyent/node/compare/streams2\">streams2</a>, which I\u2019ve been working on for a few weeks. (There\u2019s been a lot of input and feedback from many others, and the code has been used as a <a href=\"https://npm.im/readable-stream\">userland module</a>, so this isn\u2019t a code-dump in progress.)</p>\n\n<p>In order to not end up in a state where we have a zillion conflicts to resolve, and to be able to bisect out problems, I\u2019ve been continually rebasing streams2 on top of the upstream master branch.</p>\n\n<p>This is especially important when a change comes into the upstream master that breaks my feature branch, <em>but doesn\u2019t break master</em>. I\u2019m not sure how I\u2019d even go about testing that if I was merging master into streams2 (unless I were to merge each commit individually, which is kind of absurd).</p>\n\n<p>Here\u2019s how I found the source of the problem:</p>\n\n<ol><li>Check out master into a new \u201cclean\u201d workspace. (NB: I didn\u2019t have to download anything again. I could just do <code>cd ..; git clone ./node ./node-clean</code>, and then <code>git pull origin master</code>, since \u201corigin\u201d is the \u201cstreams2\u201d workspace.)</li>\n<li>Run <code>git bisect bad</code>.</li>\n<li>Check out master from 4 weeks ago, which I\u2019m pretty sure worked. (Could have probably been a bit more conservative, but who cares? Bisect uses the magic of a binary search, so it\u2019s probably just one extra test!)</li>\n<li>Just to make sure, in the first workspace, rebase streams2 onto that 4-week-old commit. (Because streams2 was already based on master, I did this via <code>git rebase -i &lt;old-commit&gt;</code> and then deleted all the the lines that were above the first streams2 commit.) Sure enough, test passes fine.</li>\n<li>Back in the \u201cclean\u201d workspace, run <code>git bisect good</code>.</li>\n<li>Repeat step 4 in the \u201cstreams2\u201d workspace, running <code>git bisect good</code> or <code>git bisect bad</code> in the \u201cclean\u201d workspace.</li>\n</ol><p>I\u2019m sure that there was probably a simpler way to do this. Maybe even some argument to bisect to tell it to rebase onto the commit, or a shell script that\u2019d do it all for me. But this worked, was fast, and totally got the job done. I don\u2019t even know how I would have figured that out otherwise.</p>\n\n<p>(In this case, the culprit was a libuv update. Bisecting through libuv using the technique I described above tracked it down to a <code>remove libev</code> mega-commit, so the moral of the story is that, even with great tools, dependencies suck sometimes.)</p>\n\n<p>Seriously. If you\u2019re doing a big refactor that takes some time, and the upstream root is changing, how do you manage to find these kinds of issues? If I was merging in, all I\u2019d know is that the merge commit made the test fail, but the test <em>doesn\u2019t</em> fail on master. In this case it\u2019s only the combination that is problematic.</p>\n\n<p>I don\u2019t know how to find or solve that sort of problem without rebase. I\u2019m sure that there\u2019s some way, because I vaguely remember handling these kinds of issues when I used CVS and SVN, but it\u2019s all hazy now that I\u2019m spoiled by bisect\u2019s awesome mightiness and the power of a mutable history.</p>\n\n<h3>Taking Patches and \u201cIdeal Workflows\u201d</h3>\n\n<p>As the maintainer of several open source projects, a few of which get a lot of outside contributions, I am faced with a choice:</p>\n\n<ol><li>Make every potential contributor follow the ideal workflow (for some value of \u201cideal\u201d), and reject a lot of patches because they are \u201cincorrect\u201d in some trivial way.</li>\n<li>Be ok with using <code>git am</code> and <code>git rebase</code> occasionally.</li>\n</ol><p>That to me is a nobrainer. My approach to contributions is closer to the \u201cemail a patch\u201d model than the \u201cclick the green merge button\u201d approach. Having that many merge commits would fuck up my precious bisect, and I <strong>always</strong> want to test the commit locally before pushing it live.</p>\n\n<p>This doesn\u2019t mean that I don\u2019t use github\u2019s pull request features. On the contrary, I love them! They\u2019re a great lightweight way to do discussion and code reviews, they integrate well with email, and when it\u2019s ready to accept, I can do:</p>\n\n<pre><code>curl <a href=\"https://github.com/joyent/node/pulls/12345.patch\">https://github.com/joyent/node/pulls/12345.patch</a> | git am\n</code></pre>\n\n<p>Or to pull just one commit:</p>\n\n<pre><code>curl <a href=\"https://github.com/john-q-contributor/node/deadbeef00.patch\">https://github.com/john-q-contributor/node/deadbeef00.patch</a> | git am\n</code></pre>\n\n<p>Did the user have a long commit message that is in broken english and will be confusing later? No problem. <code>git rebase -i HEAD^</code>, and reword it. Did they make some minor lint mistake? No matter. <code>make jslintfix &amp;&amp; gci -am 'lint fixup'</code> and then squash the commits together.  Did they put 3 features in one commit?  Easy, just do a <code>git rebase -i</code>, mark the commit for editing, then split it up into 3.  They get credit for the work that they did, and I get a history that\u2019s easy to read with a minimum of clutter.  In the most extreme case, I can even use <code>git format-patch</code> to output a patch file, edit it manually, and then <code>git am</code> that puppy.</p>\n\n<p>Rebase, am, and apply allow a project lead to be liberal in what they accept, and strict in what they send.</p>\n\n<p>Yes, this can all be abused.  So, don\u2019t abuse it.  Great power great responsibility blah blah blah.  In fact it\u2019s pretty easy to not fuck up, far easier than <em>actually</em> writing perfect code or getting contributors to make perfect commits.  If you do mess it up, oh well, there are plenty of forks; just reset and start over.</p>\n\n<h3>It\u2019s About History</h3>\n\n<p>It would be unreasonable to say that you should <em>always</em> use rebase instead of merge. For example, we routinely merge node\u2019s stable branch into master. Rebasing master onto the latest stable branch would destroy the history of all our previous unstable releases, and would be much harder to manage.</p>\n\n<p>In the case of that \u201cbig feature branch\u201d for streams2, even if it ends up being a fast-forward due to being rebased onto the latest master, I\u2019m going to merge it in with <code>--no-ff</code> to <em>force</em> a merge commit, so that it\u2019s easy to pluck off if it turns out that the feature is actually crap.</p>\n\n<p>Git is a tool for managing content. There are a lot of ways to manage content. If something has been pushed live (or even \u201cpushed upstream\u201d) then you probably want to maintain forensic-level control over it.</p>\n\n<p>I think of \u201chistory\u201d in terms of levels of granularity.</p>\n\n<p>Take for example, the assassination of Abraham Lincoln, an extremely relevant historical event in the history of the United States.</p>\n\n<p>At the lowest level of granularity, there\u2019s a lot of first-hand data: the eye-witness accounts that were given to police at the scene, the notes from the doctors in the ambulance and at the hospital where Lincoln was rushed after being shot, the descriptions and reports of other forensic evidence at the scene, the writings of John Wilkes Booth and the testimony of his conspirators (who all failed in their missions, for various reasons). There\u2019s also the context of the Civil War being in the process of ending (but that being in some dispute at the time). There\u2019s the account of the Union soldiers who tracked Booth down to a barn, set it on fire, then shot him as he fled, and the account of John St. Helen, who claimed to actually be John Wilkes Booth, having escaped and lived under a pseudonym in Texas for years, before committing suicide.</p>\n\n<p>You don\u2019t learn any of that in history class, because reading police reports makes it significantly more difficult to understand the story. <em>Some</em> context is great, but reading 25 conflicting eye-witness reports is not actually that useful over a hundred years later. Sure, we keep them around, just in case, but what you really want to know is just <em>what actually happened</em>. So, on top of those low-level accounts, we have various different accounts that go into different levels of detail, resolving and synthesizing the inconsistencies into a coherent story. At the highest level of history, you have the kids\u2019 book version: \u201cAbraham Lincoln was the president during the Civil War. He abolished slavery, and then got shot in a theater.\u201d</p>\n\n<p>The <code>-wip</code> branches are my version of the conflicting police reports. The feature branch is a tidied up version which is actually useful, but probably still too detailed for most people to want to parse through. The ChangeLog is the effective \u201cwhat happened when\u201d sort of history, and at the highest level, you\u2019ll have a tweet from @nodejs that says \u201cVersion 0.9.5 Released - streams2 support!\u201d with a link go to download it.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>One objection to the \u201cgit is an editor\u201d mindset is that it\u2019s actually a database.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> Git isn\u2019t an editor, it\u2019s a database. It should keep a record of everything that happens with tracked files. Rebase loses data<br>\u2014 Daniel Erickson (@TechWraith) <a href=\"https://twitter.com/TechWraith/status/277658833772486657\" data-datetime=\"2012-12-09T06:19:59+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>Of course, the problem with that is that a text file can be a database also, and you still use an editor to edit it; and a database is just a fancy editor for manipulating and retrieving blocks of data off a disk, and provides some ways to manipulate that data that take advantage of its regularity.</p>\n\n<p>Many \u201cdatabases\u201d have mechanisms to delete data.  (In fact, all that I know of have something like this.)  Losing data is only a problem if you lose data that you care about; losing data that you <em>don\u2019t</em> care about increases the overall understanding and makes the data that you <em>do</em> care about easier to get to.</p>\n\n<p>Use the tools wisely.  Use the editor to tell a good story, the right kind of story that your application needs told.  If you need forensic details of every change to your production service, well good news, git can do that!  If you need a clear explanation of the reasoning behind features in your library, git is great for that, also.  Like a good editor, it can be used to tell a variety of different kinds of stories.  Like a good database, it gives you the tools to organize your data into the shape that is most useful to you.</p>\n\n<p>The backspace key is very dangerous.  You can delete an entire file with it!  But the trade-offs are worth the benefit.  For the same reason that you delete code rather than comment it out (because it\u2019s in the git history, so why keep the clutter?) it\u2019s also great to rebase work-in-progress branches into a good state for their final merge.  Some aspects of history are ok to lose.  In many situations, <em>not</em> losing that bit of history makes the story harder to follow.</p>",
        "tree_html": ""
    },
    "reblog_key": "mBWmXvMI",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWyZ49uZs",
    "slug": "git-rebase",
    "state": "published",
    "summary": "git-rebase",
    "tags": [],
    "timestamp": 1355166300,
    "title": "git-rebase",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>Edit: You should probably also read <a href=\"http://sandofsky.com/blog/git-workflow.html\"> Understanding the Git Workflow</a>.  Much more succinct explanation of the point that I dance around a lot below.  Almost as if we&rsquo;d had roughly the same ideas, but he squashed the messages more eloquently ;)</p>\n\n<p>A <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">recent article on git-merge vs git-rebase</a> kicked off a very interesting conversation on twitter the other day among a bunch of us nerds.</p>\n\n<p>It started with <a href=\"https://twitter.com/polotek\">Marco</a> saying</p>\n\n<blockquote><p>Good article on merge vs. rebase. It&rsquo;s pretty balanced, but I&rsquo;m still firmly against rebase after reading. <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">blog.sourcetreeapp.com/2012/08/21/mer&hellip;</a><br />&mdash; Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277541092184965120\">December 8, 2012</a></p></blockquote>\n\n<p>A few of us objected.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> I wouldn&rsquo;t recommend being &ldquo;firmly&rdquo; against rebase. That&rsquo;s like being &ldquo;firmly&rdquo; against a particular coding style. Forest for trees.<br />&mdash; Jason Smith (@_jhs) <a href=\"https://twitter.com/_jhs/status/277621735241695232\">December 9, 2012</a></p></blockquote>\n\n<p>Then there were like a bazillion more replies back and forth, and it got too much for Twitter.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/polotek\">polotek</a> @<a href=\"https://twitter.com/rwaldron\">rwaldron</a> @<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/oscargodson\">oscargodson</a> I&rsquo;ll reply in blog format. ENOSPC.<br />&mdash; isaacs (@izs) <a href=\"https://twitter.com/izs/status/277812898095566849\">December 9, 2012</a></p></blockquote>\n\n<p>So here I am writing a blog post now.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>I&rsquo;m pretty sure I stole this line from someone, but I couldn&rsquo;t find any reference earlier than <a href=\"https://groups.google.com/d/msg/nodejs/xFfzu9XIBvY/414wq6ZbS8gJ\">mine</a>, so maybe I made this up. It&rsquo;s a way of thinking about git that I really like:</p>\n\n<blockquote><p>cvs and svn are remote backups that you use to save your changes.<br /> git is an editor that you use to write your code&rsquo;s biography.<br />&mdash; isaacs (@izs) <a href=\"https://twitter.com/izs/status/13997541348\">May 14, 2010</a></p></blockquote>\n\n<p>So my reply to Marco was:</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> Git is an editor. &ldquo;Firmly against rebase&rdquo; is like being firmly against backspace.<br />&mdash; isaacs (@izs) <a href=\"https://twitter.com/izs/status/277656808959660032\">December 9, 2012</a></p></blockquote>\n\n<p>I hope that some of the implication of that becomes clearer by the time I get to the end of this post.</p>\n\n<h3>&ldquo;tidy&rdquo;</h3>\n\n<p>A lot of the discussion of git-rebase fixates on keeping the commit history &ldquo;tidy&rdquo;.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> rebasing into a release branch is clean and tidy. You still have the data in your feature branch.<br />&mdash; Emily Rose (@nexxylove) <a href=\"https://twitter.com/nexxylove/status/277659451849330688\">December 9, 2012</a></p></blockquote>\n\n<blockquote><p>@<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> what does clean and tidy buy besides a sense of satisfaction?<br />&mdash; Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277689191037538305\">December 9, 2012</a></p></blockquote>\n\n<p>The workflow that everyone is discussing seems to be:</p>\n\n<ul><li>Working on a feature branch</li>\n<li>Make some commits</li>\n<li>The upstream branch changes (because someone else pushed to it) and now it&rsquo;s time to merge it in.</li>\n<li>Do you <code>git pull --rebase</code> (so that you pretend to have always been working on the changes) or <code>git pull</code> the upstream (so that you get a merge commit)?</li>\n</ul><p><a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">The article</a> that started the conversation really only discussed this single use of rebase.</p>\n\n<p>However, rebase is much more versatile that this. <strong>Rebase is a tool that can be used to arbitrarily edit the commit history.</strong> If that sounds <em>universally</em> scary or bad, I&rsquo;d argue that your understanding of &ldquo;edit&rdquo; and &ldquo;history&rdquo; are perhaps a bit limited.</p>\n\n<h3>Tidying Up History</h3>\n\n<p>Consider the following two stories:</p>\n\n<h4>Story 1</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I walked down Adams Street to Whole Foods so I could buy milk.</p>\n  \n  <p>I mean, no, Whole Foods isn&rsquo;t on Adams, it&rsquo;s on Bay Place, so I\n  walked down Bay Place to get to Whole Foods to buy milk.</p>\n  \n  <p>Oh, but first, I had to walk down Grand Ave, then take a right on\n  Bay Place, then parked my car&ndash;shit.</p>\n  \n  <p>I got in my car, drove down Grand Ave, took a right on Bay Place,\n  parked my car at Whole Foods, and needed my wallet, so&hellip; right, ok,\n  so before I drove in my car, I got my wallet, drove to Whole Foods\n  on Bay Place by going down Grand, and then bought some milk.</p>\n  \n  <p>No, wait, I didn&rsquo;t to whole foods, that&rsquo;s right, because they&rsquo;re\n  crazy expensive.  I went to the Grand Lake Safeway.</p>\n</blockquote>\n\n<h4>Story 2</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I drove to the Grand Lake Safeway and bought some milk.</p>\n</blockquote>\n\n<p>This seems silly, but the benefit of a tool that can tidy up history is that <em>you get to write whatever crazy awful untidy history you want</em>, while you&rsquo;re experimenting and editing code, and then organize it later. When I&rsquo;m actually writing code, my commit history looks a lot like Story 1.</p>\n\n<p>Typically I work on a <code>blahblah-feature-name-wip</code> branch, and then rebase it down to a <code>blahblah-feature-name</code> branch when I&rsquo;ve got it into a working state and understand how it&rsquo;s supposed to go. The <code>-wip</code> branches are a godawful mess of <code>kinda working, except breaks all the fs tests</code> commits, and <code>Revert \"kinda working, except...\"</code> commits. The benefit of tidiness then, is that I can track my work in a more or less play-by-play fashion, and still end up with something readable.</p>\n\n<p>Is it better, then, to push all those play-by-play commits?</p>\n\n<p>What is the <strong>purpose</strong> of a git history? Is it a forensic record of every edit to a file? Or is it a way for others to determine the <em>reason</em> for those edits?</p>\n\n<p>My answer is: It&rsquo;s both, depending on context.</p>\n\n<p>I keep the <code>-wip</code> branch around for as long as the forensics are interesting. There&rsquo;s a lot of times that I notice something is broken in the &ldquo;real&rdquo; feature branch, and think, &ldquo;Oh, I could&rsquo;ve sworn that was working yesterday.. what was I doing..?&rdquo; At moments like those, the forensic record of my thoughts is invaluable.</p>\n\n<p>But if someone, years later, is looking at a bit of code that seems strange, and they run <code>git blame</code> on the file, and track the edit back to <code>Revert \"Revert \"hmm this seems broken but it sorta works i dunno\"\"</code> then they&rsquo;ll be rightly upset with me for letting such useless garbage into the repository.</p>\n\n<p>One possible answer is: &ldquo;Don&rsquo;t write code like that.&rdquo; Write a test for the feature, then write the code to make the test pass, and never make mistakes.</p>\n\n<p>The problem is that I&rsquo;m not smart enough to not make mistakes and know exactly what code to write before I start writing it. Also, I enjoy the liberty of messing around, tracking every bit, and still sharing an elegant useful story with my future collaborators (including future-isaacs.)</p>\n\n<h3>Forensics - Platform vs Service</h3>\n\n<p>It&rsquo;s very interesting to me, but not at all surprising, that the people in this conversation that were most in favor of &ldquo;merge only, never rebase&rdquo; are generally working on a production web service (Yammer, most of them), and the people who favored rebase seemed to be working primarily on platforms (Node and npm in my case; JQuery Johnny5 and others in the case of Rick Waldron.) A few folks (mikeal, Jason Smith) work on both sorts of systems, and of course this breakdown is imprecise.</p>\n\n<p>I&rsquo;ve seen a similar reaction to rebase-vs-merge in coworkers at Yahoo, Kakai, and Joyent. (Basically ever since I&rsquo;ve been using git, and exposed to this sort of conversation.) People who spend most of their day debugging production issues want the history to be as detailed and &ldquo;forensically accurate&rdquo; as possible. People who spend most of their day debugging platforms or libraries tend to want the history to be the most &ldquo;elegant story&rdquo; possible.</p>\n\n<p>For the purpose of this discussion, &ldquo;Yammer&rdquo; is a service, and &ldquo;node&rdquo; is a platform. You install a platform and then build your program on it, and you install updates yourself. You use a service in production on someone else&rsquo;s computers, and it is updated by other people. (From this point of view, &ldquo;PaaS&rdquo; is actually a Service, not a Platform. Pedants please direct all complaints to /dev/null.)</p>\n\n<p>There is of course some overlap in the concerns. I definitely do not want any changes whatsoever to the history of release branches in the <a href=\"https://github.com/joyent/node\">joyent/node</a>, even if it means the occasional messy revert. If something has gone out as a part of a release, then it is <strong>definitely</strong> off-limits, and anyone who rebases that into some other shape will be ruthlessly punished (perhaps with the removal of commit access, if the infraction is repeated.)</p>\n\n<p>I think that this split comes down to a simple question: When encountering a new problem, are you likely to use <code>git-bisect</code> to track it down, or are you going to revert to some known-good state and go from there?</p>\n\n<h3>Git&rsquo;s Killer Feature: Bisect</h3>\n\n<p>If you have never used git bisect, then you don&rsquo;t fully understand why git is useful. Git bisect is one of those tools that, once you use it, you realize that there is simply no way you could have ever debugged without it. And, the first time you try to bisect over a commit history littered with merge commits and reverts and broken states, you&rsquo;ll see why &ldquo;tidiness&rdquo; is so powerful.</p>\n\n<p>For the uninitiated, here&rsquo;s a run-down of what bisect does, in broad strokes:</p>\n\n<ol><li>You run your tests, and realize &ldquo;Oh, shit, it&rsquo;s busted.&rdquo;</li>\n<li>You know that it was working yesterday (or whenever).</li>\n<li>You run <code>git bisect bad</code>.  (Answer &ldquo;yes&rdquo; to the prompt.)</li>\n<li>You do <code>git checkout &lt;known-good-state&gt;</code>.  (Run the test again\njust to make sure that you&rsquo;re not mis-remembering.)</li>\n<li>Run <code>git bisect good</code>.</li>\n<li>Git will proceed to hop you to various commits, at which point you\nrun your test and do <code>git bisect good</code> if it&rsquo;s good, or <code>git bisect\nbad</code> if it&rsquo;s bad.  (If necessary, you can also check out commits\nmanually, and mark them as good/bad.)</li>\n<li>Shockingly quickly, git tells you which commit was the first bad\none.</li>\n</ol><p>Because the &ldquo;test&rdquo; can be literally anything, I often use this to track down which commit in libuv broke something in node, if the node bisect shows that it was a <code>update libuv to deadbeef</code> type of commit that is the culprit. I run the <code>git bisect</code> in the libuv repo, and the &ldquo;test&rdquo; is putting the libuv code in node&rsquo;s deps/uv folder, and running the node test.</p>\n\n<p>To make bisect even more interesting, you can add something like this to your <code>~/.gitconfig</code> file:</p>\n\n<pre><code>[alias]\n  lg = log --graph --pretty=format:'%Cred%h%Creset %C(yellow)%an%d%Creset %s %Cgreen(%cr)%Creset' --date=relative\n</code></pre>\n\n<p>Then running <code>git lg</code> will show you a very terse listing of the history, which shows all the bisect tags.</p>\n\n<p>As you can imagine, this works most efficiently when you have a relatively straightforward history. If you have messy back and forth play-by-play commits, where tests are breaking and un-breaking repeatedly, or the build is failing occasionally, then bisect is essentially worthless. Bisect can go over merge commits, but it becomes a lot less trivial to track what it&rsquo;s doing, and I&rsquo;ve found a lot of times the &ldquo;first bad commit&rdquo; is the merge commit, which is pretty much useless.</p>\n\n<p>Tidiness makes bisect even more powerful. I&rsquo;d use git without bisect, because it&rsquo;s the de facto standard of the open source world. But without bisect, I would love git half as much. If I could make bisect even more powerful by rubbing grease on my elbows, I&rsquo;d do it.</p>\n\n<p>This is not about a sense of satisfaction. Tidiness is about taking 20 minutes to track down a bug, instead of taking all day.</p>\n\n<h3>Upstream Motion and Large Feature Branches</h3>\n\n<p>Occasionally you have a &ldquo;Feature&rdquo; branch that is really a major refactor of some sort, which cannot be accomplished in a single burst of coding. My most recent example is <a href=\"https://github.com/joyent/node/compare/streams2\">streams2</a>, which I&rsquo;ve been working on for a few weeks. (There&rsquo;s been a lot of input and feedback from many others, and the code has been used as a <a href=\"https://npm.im/readable-stream\">userland module</a>, so this isn&rsquo;t a code-dump in progress.)</p>\n\n<p>In order to not end up in a state where we have a zillion conflicts to resolve, and to be able to bisect out problems, I&rsquo;ve been continually rebasing streams2 on top of the upstream master branch.</p>\n\n<p>This is especially important when a change comes into the upstream master that breaks my feature branch, <em>but doesn&rsquo;t break master</em>. I&rsquo;m not sure how I&rsquo;d even go about testing that if I was merging master into streams2 (unless I were to merge each commit individually, which is kind of absurd).</p>\n\n<p>Here&rsquo;s how I found the source of the problem:</p>\n\n<ol><li>Check out master into a new &ldquo;clean&rdquo; workspace. (NB: I didn&rsquo;t have to download anything again. I could just do <code>cd ..; git clone ./node ./node-clean</code>, and then <code>git pull origin master</code>, since &ldquo;origin&rdquo; is the &ldquo;streams2&rdquo; workspace.)</li>\n<li>Run <code>git bisect bad</code>.</li>\n<li>Check out master from 4 weeks ago, which I&rsquo;m pretty sure worked. (Could have probably been a bit more conservative, but who cares? Bisect uses the magic of a binary search, so it&rsquo;s probably just one extra test!)</li>\n<li>Just to make sure, in the first workspace, rebase streams2 onto that 4-week-old commit. (Because streams2 was already based on master, I did this via <code>git rebase -i &lt;old-commit&gt;</code> and then deleted all the the lines that were above the first streams2 commit.) Sure enough, test passes fine.</li>\n<li>Back in the &ldquo;clean&rdquo; workspace, run <code>git bisect good</code>.</li>\n<li>Repeat step 4 in the &ldquo;streams2&rdquo; workspace, running <code>git bisect good</code> or <code>git bisect bad</code> in the &ldquo;clean&rdquo; workspace.</li>\n</ol><p>I&rsquo;m sure that there was probably a simpler way to do this. Maybe even some argument to bisect to tell it to rebase onto the commit, or a shell script that&rsquo;d do it all for me. But this worked, was fast, and totally got the job done. I don&rsquo;t even know how I would have figured that out otherwise.</p>\n\n<p>(In this case, the culprit was a libuv update. Bisecting through libuv using the technique I described above tracked it down to a <code>remove libev</code> mega-commit, so the moral of the story is that, even with great tools, dependencies suck sometimes.)</p>\n\n<p>Seriously. If you&rsquo;re doing a big refactor that takes some time, and the upstream root is changing, how do you manage to find these kinds of issues? If I was merging in, all I&rsquo;d know is that the merge commit made the test fail, but the test <em>doesn&rsquo;t</em> fail on master. In this case it&rsquo;s only the combination that is problematic.</p>\n\n<p>I don&rsquo;t know how to find or solve that sort of problem without rebase. I&rsquo;m sure that there&rsquo;s some way, because I vaguely remember handling these kinds of issues when I used CVS and SVN, but it&rsquo;s all hazy now that I&rsquo;m spoiled by bisect&rsquo;s awesome mightiness and the power of a mutable history.</p>\n\n<h3>Taking Patches and &ldquo;Ideal Workflows&rdquo;</h3>\n\n<p>As the maintainer of several open source projects, a few of which get a lot of outside contributions, I am faced with a choice:</p>\n\n<ol><li>Make every potential contributor follow the ideal workflow (for some value of &ldquo;ideal&rdquo;), and reject a lot of patches because they are &ldquo;incorrect&rdquo; in some trivial way.</li>\n<li>Be ok with using <code>git am</code> and <code>git rebase</code> occasionally.</li>\n</ol><p>That to me is a nobrainer. My approach to contributions is closer to the &ldquo;email a patch&rdquo; model than the &ldquo;click the green merge button&rdquo; approach. Having that many merge commits would fuck up my precious bisect, and I <strong>always</strong> want to test the commit locally before pushing it live.</p>\n\n<p>This doesn&rsquo;t mean that I don&rsquo;t use github&rsquo;s pull request features. On the contrary, I love them! They&rsquo;re a great lightweight way to do discussion and code reviews, they integrate well with email, and when it&rsquo;s ready to accept, I can do:</p>\n\n<pre><code>curl <a href=\"https://github.com/joyent/node/pulls/12345.patch\">https://github.com/joyent/node/pulls/12345.patch</a> | git am\n</code></pre>\n\n<p>Or to pull just one commit:</p>\n\n<pre><code>curl <a href=\"https://github.com/john-q-contributor/node/deadbeef00.patch\">https://github.com/john-q-contributor/node/deadbeef00.patch</a> | git am\n</code></pre>\n\n<p>Did the user have a long commit message that is in broken english and will be confusing later? No problem. <code>git rebase -i HEAD^</code>, and reword it. Did they make some minor lint mistake? No matter. <code>make jslintfix &amp;&amp; gci -am 'lint fixup'</code> and then squash the commits together.  Did they put 3 features in one commit?  Easy, just do a <code>git rebase -i</code>, mark the commit for editing, then split it up into 3.  They get credit for the work that they did, and I get a history that&rsquo;s easy to read with a minimum of clutter.  In the most extreme case, I can even use <code>git format-patch</code> to output a patch file, edit it manually, and then <code>git am</code> that puppy.</p>\n\n<p>Rebase, am, and apply allow a project lead to be liberal in what they accept, and strict in what they send.</p>\n\n<p>Yes, this can all be abused.  So, don&rsquo;t abuse it.  Great power great responsibility blah blah blah.  In fact it&rsquo;s pretty easy to not fuck up, far easier than <em>actually</em> writing perfect code or getting contributors to make perfect commits.  If you do mess it up, oh well, there are plenty of forks; just reset and start over.</p>\n\n<h3>It&rsquo;s About History</h3>\n\n<p>It would be unreasonable to say that you should <em>always</em> use rebase instead of merge. For example, we routinely merge node&rsquo;s stable branch into master. Rebasing master onto the latest stable branch would destroy the history of all our previous unstable releases, and would be much harder to manage.</p>\n\n<p>In the case of that &ldquo;big feature branch&rdquo; for streams2, even if it ends up being a fast-forward due to being rebased onto the latest master, I&rsquo;m going to merge it in with <code>--no-ff</code> to <em>force</em> a merge commit, so that it&rsquo;s easy to pluck off if it turns out that the feature is actually crap.</p>\n\n<p>Git is a tool for managing content. There are a lot of ways to manage content. If something has been pushed live (or even &ldquo;pushed upstream&rdquo;) then you probably want to maintain forensic-level control over it.</p>\n\n<p>I think of &ldquo;history&rdquo; in terms of levels of granularity.</p>\n\n<p>Take for example, the assassination of Abraham Lincoln, an extremely relevant historical event in the history of the United States.</p>\n\n<p>At the lowest level of granularity, there&rsquo;s a lot of first-hand data: the eye-witness accounts that were given to police at the scene, the notes from the doctors in the ambulance and at the hospital where Lincoln was rushed after being shot, the descriptions and reports of other forensic evidence at the scene, the writings of John Wilkes Booth and the testimony of his conspirators (who all failed in their missions, for various reasons). There&rsquo;s also the context of the Civil War being in the process of ending (but that being in some dispute at the time). There&rsquo;s the account of the Union soldiers who tracked Booth down to a barn, set it on fire, then shot him as he fled, and the account of John St. Helen, who claimed to actually be John Wilkes Booth, having escaped and lived under a pseudonym in Texas for years, before committing suicide.</p>\n\n<p>You don&rsquo;t learn any of that in history class, because reading police reports makes it significantly more difficult to understand the story. <em>Some</em> context is great, but reading 25 conflicting eye-witness reports is not actually that useful over a hundred years later. Sure, we keep them around, just in case, but what you really want to know is just <em>what actually happened</em>. So, on top of those low-level accounts, we have various different accounts that go into different levels of detail, resolving and synthesizing the inconsistencies into a coherent story. At the highest level of history, you have the kids&rsquo; book version: &ldquo;Abraham Lincoln was the president during the Civil War. He abolished slavery, and then got shot in a theater.&rdquo;</p>\n\n<p>The <code>-wip</code> branches are my version of the conflicting police reports. The feature branch is a tidied up version which is actually useful, but probably still too detailed for most people to want to parse through. The ChangeLog is the effective &ldquo;what happened when&rdquo; sort of history, and at the highest level, you&rsquo;ll have a tweet from @nodejs that says &ldquo;Version 0.9.5 Released - streams2 support!&rdquo; with a link go to download it.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>One objection to the &ldquo;git is an editor&rdquo; mindset is that it&rsquo;s actually a database.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> Git isn&rsquo;t an editor, it&rsquo;s a database. It should keep a record of everything that happens with tracked files. Rebase loses data<br />&mdash; Daniel Erickson (@TechWraith) <a href=\"https://twitter.com/TechWraith/status/277658833772486657\">December 9, 2012</a></p></blockquote>\n\n<p>Of course, the problem with that is that a text file can be a database also, and you still use an editor to edit it; and a database is just a fancy editor for manipulating and retrieving blocks of data off a disk, and provides some ways to manipulate that data that take advantage of its regularity.</p>\n\n<p>Many &ldquo;databases&rdquo; have mechanisms to delete data.  (In fact, all that I know of have something like this.)  Losing data is only a problem if you lose data that you care about; losing data that you <em>don&rsquo;t</em> care about increases the overall understanding and makes the data that you <em>do</em> care about easier to get to.</p>\n\n<p>Use the tools wisely.  Use the editor to tell a good story, the right kind of story that your application needs told.  If you need forensic details of every change to your production service, well good news, git can do that!  If you need a clear explanation of the reasoning behind features in your library, git is great for that, also.  Like a good editor, it can be used to tell a variety of different kinds of stories.  Like a good database, it gives you the tools to organize your data into the shape that is most useful to you.</p>\n\n<p>The backspace key is very dangerous.  You can delete an entire file with it!  But the trade-offs are worth the benefit.  For the same reason that you delete code rather than comment it out (because it&rsquo;s in the git history, so why keep the clutter?) it&rsquo;s also great to rebase work-in-progress branches into a good state for their final merge.  Some aspects of history are ok to lose.  In many situations, <em>not</em> losing that bit of history makes the story harder to follow.</p>",
            "content_raw": "<p class=\"small\">Edit: You should probably also read <a href=\"http://sandofsky.com/blog/git-workflow.html\"> Understanding the Git Workflow</a>.  Much more succinct explanation of the point that I dance around a lot below.  Almost as if we\u2019d had roughly the same ideas, but he squashed the messages more eloquently ;)</p>\n\n<p>A <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">recent article on git-merge vs git-rebase</a> kicked off a very interesting conversation on twitter the other day among a bunch of us nerds.</p>\n\n<p>It started with <a href=\"https://twitter.com/polotek\">Marco</a> saying</p>\n\n<blockquote><p>Good article on merge vs. rebase. It\u2019s pretty balanced, but I\u2019m still firmly against rebase after reading. <a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">blog.sourcetreeapp.com/2012/08/21/mer\u2026</a><br>\u2014 Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277541092184965120\" data-datetime=\"2012-12-08T22:32:07+00:00\">December 8, 2012</a></p></blockquote>\n\n<p>A few of us objected.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> I wouldn\u2019t recommend being \u201cfirmly\u201d against rebase. That\u2019s like being \u201cfirmly\u201d against a particular coding style. Forest for trees.<br>\u2014 Jason Smith (@_jhs) <a href=\"https://twitter.com/_jhs/status/277621735241695232\" data-datetime=\"2012-12-09T03:52:34+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>Then there were like a bazillion more replies back and forth, and it got too much for Twitter.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/polotek\">polotek</a> @<a href=\"https://twitter.com/rwaldron\">rwaldron</a> @<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/oscargodson\">oscargodson</a> I\u2019ll reply in blog format. ENOSPC.<br>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/277812898095566849\" data-datetime=\"2012-12-09T16:32:11+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>So here I am writing a blog post now.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>I\u2019m pretty sure I stole this line from someone, but I couldn\u2019t find any reference earlier than <a href=\"https://groups.google.com/d/msg/nodejs/xFfzu9XIBvY/414wq6ZbS8gJ\">mine</a>, so maybe I made this up. It\u2019s a way of thinking about git that I really like:</p>\n\n<blockquote><p>cvs and svn are remote backups that you use to save your changes.<br> git is an editor that you use to write your code\u2019s biography.<br>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/13997541348\" data-datetime=\"2010-05-14T21:07:58+00:00\">May 14, 2010</a></p></blockquote>\n\n<p>So my reply to Marco was:</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/polotek\">polotek</a> Git is an editor. \u201cFirmly against rebase\u201d is like being firmly against backspace.<br>\u2014 isaacs (@izs) <a href=\"https://twitter.com/izs/status/277656808959660032\" data-datetime=\"2012-12-09T06:11:56+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>I hope that some of the implication of that becomes clearer by the time I get to the end of this post.</p>\n\n<h3>\u201ctidy\u201d</h3>\n\n<p>A lot of the discussion of git-rebase fixates on keeping the commit history \u201ctidy\u201d.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> rebasing into a release branch is clean and tidy. You still have the data in your feature branch.<br>\u2014 Emily Rose (@nexxylove) <a href=\"https://twitter.com/nexxylove/status/277659451849330688\" data-datetime=\"2012-12-09T06:22:26+00:00\">December 9, 2012</a></p></blockquote>\n\n<blockquote><p>@<a href=\"https://twitter.com/nexxylove\">nexxylove</a> @<a href=\"https://twitter.com/techwraith\">techwraith</a> @<a href=\"https://twitter.com/izs\">izs</a> what does clean and tidy buy besides a sense of satisfaction?<br>\u2014 Marco Rogers (@polotek) <a href=\"https://twitter.com/polotek/status/277689191037538305\" data-datetime=\"2012-12-09T08:20:37+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>The workflow that everyone is discussing seems to be:</p>\n\n<ul><li>Working on a feature branch</li>\n<li>Make some commits</li>\n<li>The upstream branch changes (because someone else pushed to it) and now it\u2019s time to merge it in.</li>\n<li>Do you <code>git pull --rebase</code> (so that you pretend to have always been working on the changes) or <code>git pull</code> the upstream (so that you get a merge commit)?</li>\n</ul><p><a href=\"http://blog.sourcetreeapp.com/2012/08/21/merge-or-rebase/\">The article</a> that started the conversation really only discussed this single use of rebase.</p>\n\n<p>However, rebase is much more versatile that this. <strong>Rebase is a tool that can be used to arbitrarily edit the commit history.</strong> If that sounds <em>universally</em> scary or bad, I\u2019d argue that your understanding of \u201cedit\u201d and \u201chistory\u201d are perhaps a bit limited.</p>\n\n<h3>Tidying Up History</h3>\n\n<p>Consider the following two stories:</p>\n\n<h4>Story 1</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I walked down Adams Street to Whole Foods so I could buy milk.</p>\n  \n  <p>I mean, no, Whole Foods isn\u2019t on Adams, it\u2019s on Bay Place, so I\n  walked down Bay Place to get to Whole Foods to buy milk.</p>\n  \n  <p>Oh, but first, I had to walk down Grand Ave, then take a right on\n  Bay Place, then parked my car\u2013shit.</p>\n  \n  <p>I got in my car, drove down Grand Ave, took a right on Bay Place,\n  parked my car at Whole Foods, and needed my wallet, so\u2026 right, ok,\n  so before I drove in my car, I got my wallet, drove to Whole Foods\n  on Bay Place by going down Grand, and then bought some milk.</p>\n  \n  <p>No, wait, I didn\u2019t to whole foods, that\u2019s right, because they\u2019re\n  crazy expensive.  I went to the Grand Lake Safeway.</p>\n</blockquote>\n\n<h4>Story 2</h4>\n\n<blockquote>\n  <p>I ran out of milk.</p>\n  \n  <p>I drove to the Grand Lake Safeway and bought some milk.</p>\n</blockquote>\n\n<p>This seems silly, but the benefit of a tool that can tidy up history is that <em>you get to write whatever crazy awful untidy history you want</em>, while you\u2019re experimenting and editing code, and then organize it later. When I\u2019m actually writing code, my commit history looks a lot like Story 1.</p>\n\n<p>Typically I work on a <code>blahblah-feature-name-wip</code> branch, and then rebase it down to a <code>blahblah-feature-name</code> branch when I\u2019ve got it into a working state and understand how it\u2019s supposed to go. The <code>-wip</code> branches are a godawful mess of <code>kinda working, except breaks all the fs tests</code> commits, and <code>Revert \"kinda working, except...\"</code> commits. The benefit of tidiness then, is that I can track my work in a more or less play-by-play fashion, and still end up with something readable.</p>\n\n<p>Is it better, then, to push all those play-by-play commits?</p>\n\n<p>What is the <strong>purpose</strong> of a git history? Is it a forensic record of every edit to a file? Or is it a way for others to determine the <em>reason</em> for those edits?</p>\n\n<p>My answer is: It\u2019s both, depending on context.</p>\n\n<p>I keep the <code>-wip</code> branch around for as long as the forensics are interesting. There\u2019s a lot of times that I notice something is broken in the \u201creal\u201d feature branch, and think, \u201cOh, I could\u2019ve sworn that was working yesterday.. what was I doing..?\u201d At moments like those, the forensic record of my thoughts is invaluable.</p>\n\n<p>But if someone, years later, is looking at a bit of code that seems strange, and they run <code>git blame</code> on the file, and track the edit back to <code>Revert \"Revert \"hmm this seems broken but it sorta works i dunno\"\"</code> then they\u2019ll be rightly upset with me for letting such useless garbage into the repository.</p>\n\n<p>One possible answer is: \u201cDon\u2019t write code like that.\u201d Write a test for the feature, then write the code to make the test pass, and never make mistakes.</p>\n\n<p>The problem is that I\u2019m not smart enough to not make mistakes and know exactly what code to write before I start writing it. Also, I enjoy the liberty of messing around, tracking every bit, and still sharing an elegant useful story with my future collaborators (including future-isaacs.)</p>\n\n<h3>Forensics - Platform vs Service</h3>\n\n<p>It\u2019s very interesting to me, but not at all surprising, that the people in this conversation that were most in favor of \u201cmerge only, never rebase\u201d are generally working on a production web service (Yammer, most of them), and the people who favored rebase seemed to be working primarily on platforms (Node and npm in my case; JQuery Johnny5 and others in the case of Rick Waldron.) A few folks (mikeal, Jason Smith) work on both sorts of systems, and of course this breakdown is imprecise.</p>\n\n<p>I\u2019ve seen a similar reaction to rebase-vs-merge in coworkers at Yahoo, Kakai, and Joyent. (Basically ever since I\u2019ve been using git, and exposed to this sort of conversation.) People who spend most of their day debugging production issues want the history to be as detailed and \u201cforensically accurate\u201d as possible. People who spend most of their day debugging platforms or libraries tend to want the history to be the most \u201celegant story\u201d possible.</p>\n\n<p>For the purpose of this discussion, \u201cYammer\u201d is a service, and \u201cnode\u201d is a platform. You install a platform and then build your program on it, and you install updates yourself. You use a service in production on someone else\u2019s computers, and it is updated by other people. (From this point of view, \u201cPaaS\u201d is actually a Service, not a Platform. Pedants please direct all complaints to /dev/null.)</p>\n\n<p>There is of course some overlap in the concerns. I definitely do not want any changes whatsoever to the history of release branches in the <a href=\"https://github.com/joyent/node\">joyent/node</a>, even if it means the occasional messy revert. If something has gone out as a part of a release, then it is <strong>definitely</strong> off-limits, and anyone who rebases that into some other shape will be ruthlessly punished (perhaps with the removal of commit access, if the infraction is repeated.)</p>\n\n<p>I think that this split comes down to a simple question: When encountering a new problem, are you likely to use <code>git-bisect</code> to track it down, or are you going to revert to some known-good state and go from there?</p>\n\n<h3>Git\u2019s Killer Feature: Bisect</h3>\n\n<p>If you have never used git bisect, then you don\u2019t fully understand why git is useful. Git bisect is one of those tools that, once you use it, you realize that there is simply no way you could have ever debugged without it. And, the first time you try to bisect over a commit history littered with merge commits and reverts and broken states, you\u2019ll see why \u201ctidiness\u201d is so powerful.</p>\n\n<p>For the uninitiated, here\u2019s a run-down of what bisect does, in broad strokes:</p>\n\n<ol><li>You run your tests, and realize \u201cOh, shit, it\u2019s busted.\u201d</li>\n<li>You know that it was working yesterday (or whenever).</li>\n<li>You run <code>git bisect bad</code>.  (Answer \u201cyes\u201d to the prompt.)</li>\n<li>You do <code>git checkout &lt;known-good-state&gt;</code>.  (Run the test again\njust to make sure that you\u2019re not mis-remembering.)</li>\n<li>Run <code>git bisect good</code>.</li>\n<li>Git will proceed to hop you to various commits, at which point you\nrun your test and do <code>git bisect good</code> if it\u2019s good, or <code>git bisect\nbad</code> if it\u2019s bad.  (If necessary, you can also check out commits\nmanually, and mark them as good/bad.)</li>\n<li>Shockingly quickly, git tells you which commit was the first bad\none.</li>\n</ol><p>Because the \u201ctest\u201d can be literally anything, I often use this to track down which commit in libuv broke something in node, if the node bisect shows that it was a <code>update libuv to deadbeef</code> type of commit that is the culprit. I run the <code>git bisect</code> in the libuv repo, and the \u201ctest\u201d is putting the libuv code in node\u2019s deps/uv folder, and running the node test.</p>\n\n<p>To make bisect even more interesting, you can add something like this to your <code>~/.gitconfig</code> file:</p>\n\n<pre><code>[alias]\n  lg = log --graph --pretty=format:'%Cred%h%Creset %C(yellow)%an%d%Creset %s %Cgreen(%cr)%Creset' --date=relative\n</code></pre>\n\n<p>Then running <code>git lg</code> will show you a very terse listing of the history, which shows all the bisect tags.</p>\n\n<p>As you can imagine, this works most efficiently when you have a relatively straightforward history. If you have messy back and forth play-by-play commits, where tests are breaking and un-breaking repeatedly, or the build is failing occasionally, then bisect is essentially worthless. Bisect can go over merge commits, but it becomes a lot less trivial to track what it\u2019s doing, and I\u2019ve found a lot of times the \u201cfirst bad commit\u201d is the merge commit, which is pretty much useless.</p>\n\n<p>Tidiness makes bisect even more powerful. I\u2019d use git without bisect, because it\u2019s the de facto standard of the open source world. But without bisect, I would love git half as much. If I could make bisect even more powerful by rubbing grease on my elbows, I\u2019d do it.</p>\n\n<p>This is not about a sense of satisfaction. Tidiness is about taking 20 minutes to track down a bug, instead of taking all day.</p>\n\n<h3>Upstream Motion and Large Feature Branches</h3>\n\n<p>Occasionally you have a \u201cFeature\u201d branch that is really a major refactor of some sort, which cannot be accomplished in a single burst of coding. My most recent example is <a href=\"https://github.com/joyent/node/compare/streams2\">streams2</a>, which I\u2019ve been working on for a few weeks. (There\u2019s been a lot of input and feedback from many others, and the code has been used as a <a href=\"https://npm.im/readable-stream\">userland module</a>, so this isn\u2019t a code-dump in progress.)</p>\n\n<p>In order to not end up in a state where we have a zillion conflicts to resolve, and to be able to bisect out problems, I\u2019ve been continually rebasing streams2 on top of the upstream master branch.</p>\n\n<p>This is especially important when a change comes into the upstream master that breaks my feature branch, <em>but doesn\u2019t break master</em>. I\u2019m not sure how I\u2019d even go about testing that if I was merging master into streams2 (unless I were to merge each commit individually, which is kind of absurd).</p>\n\n<p>Here\u2019s how I found the source of the problem:</p>\n\n<ol><li>Check out master into a new \u201cclean\u201d workspace. (NB: I didn\u2019t have to download anything again. I could just do <code>cd ..; git clone ./node ./node-clean</code>, and then <code>git pull origin master</code>, since \u201corigin\u201d is the \u201cstreams2\u201d workspace.)</li>\n<li>Run <code>git bisect bad</code>.</li>\n<li>Check out master from 4 weeks ago, which I\u2019m pretty sure worked. (Could have probably been a bit more conservative, but who cares? Bisect uses the magic of a binary search, so it\u2019s probably just one extra test!)</li>\n<li>Just to make sure, in the first workspace, rebase streams2 onto that 4-week-old commit. (Because streams2 was already based on master, I did this via <code>git rebase -i &lt;old-commit&gt;</code> and then deleted all the the lines that were above the first streams2 commit.) Sure enough, test passes fine.</li>\n<li>Back in the \u201cclean\u201d workspace, run <code>git bisect good</code>.</li>\n<li>Repeat step 4 in the \u201cstreams2\u201d workspace, running <code>git bisect good</code> or <code>git bisect bad</code> in the \u201cclean\u201d workspace.</li>\n</ol><p>I\u2019m sure that there was probably a simpler way to do this. Maybe even some argument to bisect to tell it to rebase onto the commit, or a shell script that\u2019d do it all for me. But this worked, was fast, and totally got the job done. I don\u2019t even know how I would have figured that out otherwise.</p>\n\n<p>(In this case, the culprit was a libuv update. Bisecting through libuv using the technique I described above tracked it down to a <code>remove libev</code> mega-commit, so the moral of the story is that, even with great tools, dependencies suck sometimes.)</p>\n\n<p>Seriously. If you\u2019re doing a big refactor that takes some time, and the upstream root is changing, how do you manage to find these kinds of issues? If I was merging in, all I\u2019d know is that the merge commit made the test fail, but the test <em>doesn\u2019t</em> fail on master. In this case it\u2019s only the combination that is problematic.</p>\n\n<p>I don\u2019t know how to find or solve that sort of problem without rebase. I\u2019m sure that there\u2019s some way, because I vaguely remember handling these kinds of issues when I used CVS and SVN, but it\u2019s all hazy now that I\u2019m spoiled by bisect\u2019s awesome mightiness and the power of a mutable history.</p>\n\n<h3>Taking Patches and \u201cIdeal Workflows\u201d</h3>\n\n<p>As the maintainer of several open source projects, a few of which get a lot of outside contributions, I am faced with a choice:</p>\n\n<ol><li>Make every potential contributor follow the ideal workflow (for some value of \u201cideal\u201d), and reject a lot of patches because they are \u201cincorrect\u201d in some trivial way.</li>\n<li>Be ok with using <code>git am</code> and <code>git rebase</code> occasionally.</li>\n</ol><p>That to me is a nobrainer. My approach to contributions is closer to the \u201cemail a patch\u201d model than the \u201cclick the green merge button\u201d approach. Having that many merge commits would fuck up my precious bisect, and I <strong>always</strong> want to test the commit locally before pushing it live.</p>\n\n<p>This doesn\u2019t mean that I don\u2019t use github\u2019s pull request features. On the contrary, I love them! They\u2019re a great lightweight way to do discussion and code reviews, they integrate well with email, and when it\u2019s ready to accept, I can do:</p>\n\n<pre><code>curl <a href=\"https://github.com/joyent/node/pulls/12345.patch\">https://github.com/joyent/node/pulls/12345.patch</a> | git am\n</code></pre>\n\n<p>Or to pull just one commit:</p>\n\n<pre><code>curl <a href=\"https://github.com/john-q-contributor/node/deadbeef00.patch\">https://github.com/john-q-contributor/node/deadbeef00.patch</a> | git am\n</code></pre>\n\n<p>Did the user have a long commit message that is in broken english and will be confusing later? No problem. <code>git rebase -i HEAD^</code>, and reword it. Did they make some minor lint mistake? No matter. <code>make jslintfix &amp;&amp; gci -am 'lint fixup'</code> and then squash the commits together.  Did they put 3 features in one commit?  Easy, just do a <code>git rebase -i</code>, mark the commit for editing, then split it up into 3.  They get credit for the work that they did, and I get a history that\u2019s easy to read with a minimum of clutter.  In the most extreme case, I can even use <code>git format-patch</code> to output a patch file, edit it manually, and then <code>git am</code> that puppy.</p>\n\n<p>Rebase, am, and apply allow a project lead to be liberal in what they accept, and strict in what they send.</p>\n\n<p>Yes, this can all be abused.  So, don\u2019t abuse it.  Great power great responsibility blah blah blah.  In fact it\u2019s pretty easy to not fuck up, far easier than <em>actually</em> writing perfect code or getting contributors to make perfect commits.  If you do mess it up, oh well, there are plenty of forks; just reset and start over.</p>\n\n<h3>It\u2019s About History</h3>\n\n<p>It would be unreasonable to say that you should <em>always</em> use rebase instead of merge. For example, we routinely merge node\u2019s stable branch into master. Rebasing master onto the latest stable branch would destroy the history of all our previous unstable releases, and would be much harder to manage.</p>\n\n<p>In the case of that \u201cbig feature branch\u201d for streams2, even if it ends up being a fast-forward due to being rebased onto the latest master, I\u2019m going to merge it in with <code>--no-ff</code> to <em>force</em> a merge commit, so that it\u2019s easy to pluck off if it turns out that the feature is actually crap.</p>\n\n<p>Git is a tool for managing content. There are a lot of ways to manage content. If something has been pushed live (or even \u201cpushed upstream\u201d) then you probably want to maintain forensic-level control over it.</p>\n\n<p>I think of \u201chistory\u201d in terms of levels of granularity.</p>\n\n<p>Take for example, the assassination of Abraham Lincoln, an extremely relevant historical event in the history of the United States.</p>\n\n<p>At the lowest level of granularity, there\u2019s a lot of first-hand data: the eye-witness accounts that were given to police at the scene, the notes from the doctors in the ambulance and at the hospital where Lincoln was rushed after being shot, the descriptions and reports of other forensic evidence at the scene, the writings of John Wilkes Booth and the testimony of his conspirators (who all failed in their missions, for various reasons). There\u2019s also the context of the Civil War being in the process of ending (but that being in some dispute at the time). There\u2019s the account of the Union soldiers who tracked Booth down to a barn, set it on fire, then shot him as he fled, and the account of John St. Helen, who claimed to actually be John Wilkes Booth, having escaped and lived under a pseudonym in Texas for years, before committing suicide.</p>\n\n<p>You don\u2019t learn any of that in history class, because reading police reports makes it significantly more difficult to understand the story. <em>Some</em> context is great, but reading 25 conflicting eye-witness reports is not actually that useful over a hundred years later. Sure, we keep them around, just in case, but what you really want to know is just <em>what actually happened</em>. So, on top of those low-level accounts, we have various different accounts that go into different levels of detail, resolving and synthesizing the inconsistencies into a coherent story. At the highest level of history, you have the kids\u2019 book version: \u201cAbraham Lincoln was the president during the Civil War. He abolished slavery, and then got shot in a theater.\u201d</p>\n\n<p>The <code>-wip</code> branches are my version of the conflicting police reports. The feature branch is a tidied up version which is actually useful, but probably still too detailed for most people to want to parse through. The ChangeLog is the effective \u201cwhat happened when\u201d sort of history, and at the highest level, you\u2019ll have a tweet from @nodejs that says \u201cVersion 0.9.5 Released - streams2 support!\u201d with a link go to download it.</p>\n\n<h3>Git is an Editor</h3>\n\n<p>One objection to the \u201cgit is an editor\u201d mindset is that it\u2019s actually a database.</p>\n\n<blockquote><p>@<a href=\"https://twitter.com/izs\">izs</a> @<a href=\"https://twitter.com/polotek\">polotek</a> Git isn\u2019t an editor, it\u2019s a database. It should keep a record of everything that happens with tracked files. Rebase loses data<br>\u2014 Daniel Erickson (@TechWraith) <a href=\"https://twitter.com/TechWraith/status/277658833772486657\" data-datetime=\"2012-12-09T06:19:59+00:00\">December 9, 2012</a></p></blockquote>\n\n<p>Of course, the problem with that is that a text file can be a database also, and you still use an editor to edit it; and a database is just a fancy editor for manipulating and retrieving blocks of data off a disk, and provides some ways to manipulate that data that take advantage of its regularity.</p>\n\n<p>Many \u201cdatabases\u201d have mechanisms to delete data.  (In fact, all that I know of have something like this.)  Losing data is only a problem if you lose data that you care about; losing data that you <em>don\u2019t</em> care about increases the overall understanding and makes the data that you <em>do</em> care about easier to get to.</p>\n\n<p>Use the tools wisely.  Use the editor to tell a good story, the right kind of story that your application needs told.  If you need forensic details of every change to your production service, well good news, git can do that!  If you need a clear explanation of the reasoning behind features in your library, git is great for that, also.  Like a good editor, it can be used to tell a variety of different kinds of stories.  Like a good database, it gives you the tools to organize your data into the shape that is most useful to you.</p>\n\n<p>The backspace key is very dangerous.  You can delete an entire file with it!  But the trade-offs are worth the benefit.  For the same reason that you delete code rather than comment it out (because it\u2019s in the git history, so why keep the clutter?) it\u2019s also great to rebase work-in-progress branches into a good state for their final merge.  Some aspects of history are ok to lose.  In many situations, <em>not</em> losing that bit of history makes the story harder to follow.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "37650663670"
            }
        }
    ],
    "type": "text"
}