{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544051896,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p>My nerd rage on the topic of Fibers, co-routines, and compiled-to-js languages in node.js comes from seeing a non-problem solved in a way that makes it worse.</p>\n\n<p>There are two really dangerous rationalizations in software design:</p>\n\n<ol><li>&ldquo;We need to make it easier for newcomers.&rdquo;</li>\n<li>&ldquo;Only experts will use this, anyway.&rdquo;</li>\n</ol><h3>Tower of Babel of Cards</h3>\n\n<p>They&rsquo;re dangerous because each seems to imply that the other can be disregarded.  The worst approach is to vacillate between them: &ldquo;We need to make (async IO, object cleanup, database queries, whatever) easier for new users, so we&rsquo;ll add this magic that experts will use to make intuitive APIs.&rdquo;</p>\n\n<p>It&rsquo;s a vicious spiral.  You can justify adding complexity, because &ldquo;this is for experts only&rdquo;, and also exposing the functionality in an obscured way in the name of making it &ldquo;intuitive&rdquo; for newcomers.  The result is inevitably a towering house of cards.  On a somewhat visceral level, I get this gut reaction to a &ldquo;handing down from the mountain&rdquo; mentality that is only harmful in the long run for everyone.</p>\n\n<p>A better goal is to make an API such that when an expert uses it expertly, a newcomer can still understand it thoroughly.  It requires an API (and more importantly, a culture) that limits experts, and educates newcomers.  I don&rsquo;t know the best way to approach problems to get there, but I&rsquo;ve found pretty good results from thinking, &ldquo;I&rsquo;m probably going to mess this up the next time I touch it, so I&rsquo;d better make it really obvious.&rdquo;  I usually fail at it, and end up cursing myself later when I rewrite the damn thing yet again.</p>\n\n<p>Passing around a function that gets called later is <em>not that hard</em>.  We&rsquo;ve been doing that in JavaScript forever.  Yes, newcomers to the language, especially if they come from a language without closures and first-class functions, have a little bit of a learning curve to get used to this phenomenon.  In my opinion, you do them a disservice by trying to shield them from that.</p>\n\n<p>(Passing around function pointers in C is actually a little bit better in some ways, because you <em>can&rsquo;t</em> define your functions inline, and all the captured data must be passed around explicitly.  This is a bit like using named functions instead of nested closures, which is a common low-complexity approach to the alleged callback problem.)</p>\n\n<p>I&rsquo;ve been writing JavaScript for a while now, and other languages for a few years before I got into JavaScript.  I&rsquo;m not the most expert at it, but I certainly don&rsquo;t consider myself a newcomer.  In that time, I&rsquo;ve learned something:</p>\n\n<h3>We&rsquo;re All Idiots</h3>\n\n<p>All of us, whether experts or newcomers.  Well-meaning idiots, perhaps, but idiots.  We all write bugs, all the time.  That is the normal state of software.  There is no abstraction so perfect that a human won&rsquo;t fuck it up at the first opportunity.  But we can try to be better, simpler, to make it easier for our future idiotic selves to figure out what we were thinking in our cleverly idiotic brains, and chop the problems into smaller pieces so that our future selves can have some clues to find the maddeningly idiotic bugs we stuffed in there.</p>\n\n<p>If your code uses step or async or slide or Q, I can read it, and I see a function getting called and passed some arguments.  I can look at how you got that function from a require() statement, pull up that module, and look at its definition.  These are lightweight abstractions that are highly penetrable.  I&rsquo;ve suggested in the past that everyone should write their own flow control lib, because it&rsquo;s the best way to really understand how they work, and it&rsquo;s not that hard.  Once you grasp the basic concepts, reading someone else&rsquo;s flow control utility is pretty easy.</p>\n\n<p>If your code uses a compiled fibers library, or something that transforms the code, then it&rsquo;s <em>much</em> harder for me to figure out what the heck is going on.  The introspection is gone.  The languages change.  Stuff happens that isn&rsquo;t present in the code I&rsquo;m looking at.  <strong>This is fundamentally different from a library that just passes functions around.</strong></p>\n\n<p>That means: I won&rsquo;t use your library if there&rsquo;s any alternative (including writing the exact same functionality myself).  It&rsquo;s nothing personal.  I just would rather spend my time solving necessary problems rather than manufactured ones.  I simply don&rsquo;t believe that you&rsquo;ve put the same level of thinking into your coro util that TC-39 and the v8 team has put into JavaScript, or that Bert and Ryan and Ben and Igor have put into libuv.</p>\n\n<p>Not everyone is the same, and that&rsquo;s great!!  If you find that Fibers solve a problem <em>for you</em>, and they make the code that you write easier <em>for you</em> to manage and design, then that&rsquo;s awesome.  Use them.  Understand them.  Drop the illusory dichotomy of &ldquo;experts&rdquo; and &ldquo;newcomers&rdquo;, and realize that they are both idiots, and both you.</p>\n\n<p>Every choice that isn&rsquo;t completely boring will alienate someone.  Pleasing everyone is a recipe for blandness.  That&rsquo;s why we keep the node-core standard lib super small, and encourage variation and repetition and iteration in userland modules.</p>\n\n<h3>Absolutes</h3>\n\n<p>If your goal is to please <em>me</em> (and other stodgy &ldquo;javascript is fine, callbacks aren&rsquo;t hard&rdquo; types) with a compiled coroutine library that adds magic to the language, you should realize how horribly unlikely that is.  I do actually think that this approach is fundamentally flawed.  I&rsquo;ve played with Marcel&rsquo;s fibers lib a bit, and it&rsquo;s about the nicest I&rsquo;ve seen, but it still adds an unacceptable <em>(for me!)</em> amount of magic to programs.</p>\n\n<p>Programmers tend to think in absolutes, perhaps because computers are such absolute things, or maybe just because absolutes are easier and we&rsquo;re all idiots.  I&rsquo;ve done it in this post, because I&rsquo;m as lazy as anyone.  Maybe you&rsquo;re the exception, and you actually are smart enough to use Fibers or Streamline wisely and still know what&rsquo;s going on when you read the code a year later.  If the benefit is greater than the cost, then go for it.  It&rsquo;s your house, you decide whether to wear pants or not.</p>\n\n<p>When we are discussing things like this, it&rsquo;s important to realize that we&rsquo;re artists discussing matters of taste.  If everyone agreed, then it would mean it wasn&rsquo;t interesting.  Maybe we should be less interested in convincing people of stuff, and more interested in just writing programs that do interesting things.</p>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2011-11-10 18:15:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 12604303054,
    "is_blocks_post_format": false,
    "note_count": 9,
    "post_url": "http://blog.izs.me/post/12604303054/experts-idiots-and-taste",
    "reblog": {
        "comment": "<p>My nerd rage on the topic of Fibers, co-routines, and compiled-to-js languages in node.js comes from seeing a non-problem solved in a way that makes it worse.</p>\n\n<p>There are two really dangerous rationalizations in software design:</p>\n\n<ol><li>\u201cWe need to make it easier for newcomers.\u201d</li>\n<li>\u201cOnly experts will use this, anyway.\u201d</li>\n</ol><h3>Tower of Babel of Cards</h3>\n\n<p>They\u2019re dangerous because each seems to imply that the other can be disregarded.  The worst approach is to vacillate between them: \u201cWe need to make (async IO, object cleanup, database queries, whatever) easier for new users, so we\u2019ll add this magic that experts will use to make intuitive APIs.\u201d</p>\n\n<p>It\u2019s a vicious spiral.  You can justify adding complexity, because \u201cthis is for experts only\u201d, and also exposing the functionality in an obscured way in the name of making it \u201cintuitive\u201d for newcomers.  The result is inevitably a towering house of cards.  On a somewhat visceral level, I get this gut reaction to a \u201chanding down from the mountain\u201d mentality that is only harmful in the long run for everyone.</p>\n\n<p>A better goal is to make an API such that when an expert uses it expertly, a newcomer can still understand it thoroughly.  It requires an API (and more importantly, a culture) that limits experts, and educates newcomers.  I don\u2019t know the best way to approach problems to get there, but I\u2019ve found pretty good results from thinking, \u201cI\u2019m probably going to mess this up the next time I touch it, so I\u2019d better make it really obvious.\u201d  I usually fail at it, and end up cursing myself later when I rewrite the damn thing yet again.</p>\n\n<p>Passing around a function that gets called later is <em>not that hard</em>.  We\u2019ve been doing that in JavaScript forever.  Yes, newcomers to the language, especially if they come from a language without closures and first-class functions, have a little bit of a learning curve to get used to this phenomenon.  In my opinion, you do them a disservice by trying to shield them from that.</p>\n\n<p>(Passing around function pointers in C is actually a little bit better in some ways, because you <em>can\u2019t</em> define your functions inline, and all the captured data must be passed around explicitly.  This is a bit like using named functions instead of nested closures, which is a common low-complexity approach to the alleged callback problem.)</p>\n\n<p>I\u2019ve been writing JavaScript for a while now, and other languages for a few years before I got into JavaScript.  I\u2019m not the most expert at it, but I certainly don\u2019t consider myself a newcomer.  In that time, I\u2019ve learned something:</p>\n\n<h3>We\u2019re All Idiots</h3>\n\n<p>All of us, whether experts or newcomers.  Well-meaning idiots, perhaps, but idiots.  We all write bugs, all the time.  That is the normal state of software.  There is no abstraction so perfect that a human won\u2019t fuck it up at the first opportunity.  But we can try to be better, simpler, to make it easier for our future idiotic selves to figure out what we were thinking in our cleverly idiotic brains, and chop the problems into smaller pieces so that our future selves can have some clues to find the maddeningly idiotic bugs we stuffed in there.</p>\n\n<p>If your code uses step or async or slide or Q, I can read it, and I see a function getting called and passed some arguments.  I can look at how you got that function from a require() statement, pull up that module, and look at its definition.  These are lightweight abstractions that are highly penetrable.  I\u2019ve suggested in the past that everyone should write their own flow control lib, because it\u2019s the best way to really understand how they work, and it\u2019s not that hard.  Once you grasp the basic concepts, reading someone else\u2019s flow control utility is pretty easy.</p>\n\n<p>If your code uses a compiled fibers library, or something that transforms the code, then it\u2019s <em>much</em> harder for me to figure out what the heck is going on.  The introspection is gone.  The languages change.  Stuff happens that isn\u2019t present in the code I\u2019m looking at.  <strong>This is fundamentally different from a library that just passes functions around.</strong></p>\n\n<p>That means: I won\u2019t use your library if there\u2019s any alternative (including writing the exact same functionality myself).  It\u2019s nothing personal.  I just would rather spend my time solving necessary problems rather than manufactured ones.  I simply don\u2019t believe that you\u2019ve put the same level of thinking into your coro util that TC-39 and the v8 team has put into JavaScript, or that Bert and Ryan and Ben and Igor have put into libuv.</p>\n\n<p>Not everyone is the same, and that\u2019s great!!  If you find that Fibers solve a problem <em>for you</em>, and they make the code that you write easier <em>for you</em> to manage and design, then that\u2019s awesome.  Use them.  Understand them.  Drop the illusory dichotomy of \u201cexperts\u201d and \u201cnewcomers\u201d, and realize that they are both idiots, and both you.</p>\n\n<p>Every choice that isn\u2019t completely boring will alienate someone.  Pleasing everyone is a recipe for blandness.  That\u2019s why we keep the node-core standard lib super small, and encourage variation and repetition and iteration in userland modules.</p>\n\n<h3>Absolutes</h3>\n\n<p>If your goal is to please <em>me</em> (and other stodgy \u201cjavascript is fine, callbacks aren\u2019t hard\u201d types) with a compiled coroutine library that adds magic to the language, you should realize how horribly unlikely that is.  I do actually think that this approach is fundamentally flawed.  I\u2019ve played with Marcel\u2019s fibers lib a bit, and it\u2019s about the nicest I\u2019ve seen, but it still adds an unacceptable <em>(for me!)</em> amount of magic to programs.</p>\n\n<p>Programmers tend to think in absolutes, perhaps because computers are such absolute things, or maybe just because absolutes are easier and we\u2019re all idiots.  I\u2019ve done it in this post, because I\u2019m as lazy as anyone.  Maybe you\u2019re the exception, and you actually are smart enough to use Fibers or Streamline wisely and still know what\u2019s going on when you read the code a year later.  If the benefit is greater than the cost, then go for it.  It\u2019s your house, you decide whether to wear pants or not.</p>\n\n<p>When we are discussing things like this, it\u2019s important to realize that we\u2019re artists discussing matters of taste.  If everyone agreed, then it would mean it wasn\u2019t interesting.  Maybe we should be less interested in convincing people of stuff, and more interested in just writing programs that do interesting things.</p>",
        "tree_html": ""
    },
    "reblog_key": "ayq2W5yj",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWyBlHcRE",
    "slug": "experts-idiots-and-taste",
    "state": "published",
    "summary": "Experts, Idiots, and Taste",
    "tags": [],
    "timestamp": 1320948900,
    "title": "Experts, Idiots, and Taste",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>My nerd rage on the topic of Fibers, co-routines, and compiled-to-js languages in node.js comes from seeing a non-problem solved in a way that makes it worse.</p>\n\n<p>There are two really dangerous rationalizations in software design:</p>\n\n<ol><li>&ldquo;We need to make it easier for newcomers.&rdquo;</li>\n<li>&ldquo;Only experts will use this, anyway.&rdquo;</li>\n</ol><h3>Tower of Babel of Cards</h3>\n\n<p>They&rsquo;re dangerous because each seems to imply that the other can be disregarded.  The worst approach is to vacillate between them: &ldquo;We need to make (async IO, object cleanup, database queries, whatever) easier for new users, so we&rsquo;ll add this magic that experts will use to make intuitive APIs.&rdquo;</p>\n\n<p>It&rsquo;s a vicious spiral.  You can justify adding complexity, because &ldquo;this is for experts only&rdquo;, and also exposing the functionality in an obscured way in the name of making it &ldquo;intuitive&rdquo; for newcomers.  The result is inevitably a towering house of cards.  On a somewhat visceral level, I get this gut reaction to a &ldquo;handing down from the mountain&rdquo; mentality that is only harmful in the long run for everyone.</p>\n\n<p>A better goal is to make an API such that when an expert uses it expertly, a newcomer can still understand it thoroughly.  It requires an API (and more importantly, a culture) that limits experts, and educates newcomers.  I don&rsquo;t know the best way to approach problems to get there, but I&rsquo;ve found pretty good results from thinking, &ldquo;I&rsquo;m probably going to mess this up the next time I touch it, so I&rsquo;d better make it really obvious.&rdquo;  I usually fail at it, and end up cursing myself later when I rewrite the damn thing yet again.</p>\n\n<p>Passing around a function that gets called later is <em>not that hard</em>.  We&rsquo;ve been doing that in JavaScript forever.  Yes, newcomers to the language, especially if they come from a language without closures and first-class functions, have a little bit of a learning curve to get used to this phenomenon.  In my opinion, you do them a disservice by trying to shield them from that.</p>\n\n<p>(Passing around function pointers in C is actually a little bit better in some ways, because you <em>can&rsquo;t</em> define your functions inline, and all the captured data must be passed around explicitly.  This is a bit like using named functions instead of nested closures, which is a common low-complexity approach to the alleged callback problem.)</p>\n\n<p>I&rsquo;ve been writing JavaScript for a while now, and other languages for a few years before I got into JavaScript.  I&rsquo;m not the most expert at it, but I certainly don&rsquo;t consider myself a newcomer.  In that time, I&rsquo;ve learned something:</p>\n\n<h3>We&rsquo;re All Idiots</h3>\n\n<p>All of us, whether experts or newcomers.  Well-meaning idiots, perhaps, but idiots.  We all write bugs, all the time.  That is the normal state of software.  There is no abstraction so perfect that a human won&rsquo;t fuck it up at the first opportunity.  But we can try to be better, simpler, to make it easier for our future idiotic selves to figure out what we were thinking in our cleverly idiotic brains, and chop the problems into smaller pieces so that our future selves can have some clues to find the maddeningly idiotic bugs we stuffed in there.</p>\n\n<p>If your code uses step or async or slide or Q, I can read it, and I see a function getting called and passed some arguments.  I can look at how you got that function from a require() statement, pull up that module, and look at its definition.  These are lightweight abstractions that are highly penetrable.  I&rsquo;ve suggested in the past that everyone should write their own flow control lib, because it&rsquo;s the best way to really understand how they work, and it&rsquo;s not that hard.  Once you grasp the basic concepts, reading someone else&rsquo;s flow control utility is pretty easy.</p>\n\n<p>If your code uses a compiled fibers library, or something that transforms the code, then it&rsquo;s <em>much</em> harder for me to figure out what the heck is going on.  The introspection is gone.  The languages change.  Stuff happens that isn&rsquo;t present in the code I&rsquo;m looking at.  <strong>This is fundamentally different from a library that just passes functions around.</strong></p>\n\n<p>That means: I won&rsquo;t use your library if there&rsquo;s any alternative (including writing the exact same functionality myself).  It&rsquo;s nothing personal.  I just would rather spend my time solving necessary problems rather than manufactured ones.  I simply don&rsquo;t believe that you&rsquo;ve put the same level of thinking into your coro util that TC-39 and the v8 team has put into JavaScript, or that Bert and Ryan and Ben and Igor have put into libuv.</p>\n\n<p>Not everyone is the same, and that&rsquo;s great!!  If you find that Fibers solve a problem <em>for you</em>, and they make the code that you write easier <em>for you</em> to manage and design, then that&rsquo;s awesome.  Use them.  Understand them.  Drop the illusory dichotomy of &ldquo;experts&rdquo; and &ldquo;newcomers&rdquo;, and realize that they are both idiots, and both you.</p>\n\n<p>Every choice that isn&rsquo;t completely boring will alienate someone.  Pleasing everyone is a recipe for blandness.  That&rsquo;s why we keep the node-core standard lib super small, and encourage variation and repetition and iteration in userland modules.</p>\n\n<h3>Absolutes</h3>\n\n<p>If your goal is to please <em>me</em> (and other stodgy &ldquo;javascript is fine, callbacks aren&rsquo;t hard&rdquo; types) with a compiled coroutine library that adds magic to the language, you should realize how horribly unlikely that is.  I do actually think that this approach is fundamentally flawed.  I&rsquo;ve played with Marcel&rsquo;s fibers lib a bit, and it&rsquo;s about the nicest I&rsquo;ve seen, but it still adds an unacceptable <em>(for me!)</em> amount of magic to programs.</p>\n\n<p>Programmers tend to think in absolutes, perhaps because computers are such absolute things, or maybe just because absolutes are easier and we&rsquo;re all idiots.  I&rsquo;ve done it in this post, because I&rsquo;m as lazy as anyone.  Maybe you&rsquo;re the exception, and you actually are smart enough to use Fibers or Streamline wisely and still know what&rsquo;s going on when you read the code a year later.  If the benefit is greater than the cost, then go for it.  It&rsquo;s your house, you decide whether to wear pants or not.</p>\n\n<p>When we are discussing things like this, it&rsquo;s important to realize that we&rsquo;re artists discussing matters of taste.  If everyone agreed, then it would mean it wasn&rsquo;t interesting.  Maybe we should be less interested in convincing people of stuff, and more interested in just writing programs that do interesting things.</p>",
            "content_raw": "<p>My nerd rage on the topic of Fibers, co-routines, and compiled-to-js languages in node.js comes from seeing a non-problem solved in a way that makes it worse.</p>\n\n<p>There are two really dangerous rationalizations in software design:</p>\n\n<ol><li>\u201cWe need to make it easier for newcomers.\u201d</li>\n<li>\u201cOnly experts will use this, anyway.\u201d</li>\n</ol><h3>Tower of Babel of Cards</h3>\n\n<p>They\u2019re dangerous because each seems to imply that the other can be disregarded.  The worst approach is to vacillate between them: \u201cWe need to make (async IO, object cleanup, database queries, whatever) easier for new users, so we\u2019ll add this magic that experts will use to make intuitive APIs.\u201d</p>\n\n<p>It\u2019s a vicious spiral.  You can justify adding complexity, because \u201cthis is for experts only\u201d, and also exposing the functionality in an obscured way in the name of making it \u201cintuitive\u201d for newcomers.  The result is inevitably a towering house of cards.  On a somewhat visceral level, I get this gut reaction to a \u201chanding down from the mountain\u201d mentality that is only harmful in the long run for everyone.</p>\n\n<p>A better goal is to make an API such that when an expert uses it expertly, a newcomer can still understand it thoroughly.  It requires an API (and more importantly, a culture) that limits experts, and educates newcomers.  I don\u2019t know the best way to approach problems to get there, but I\u2019ve found pretty good results from thinking, \u201cI\u2019m probably going to mess this up the next time I touch it, so I\u2019d better make it really obvious.\u201d  I usually fail at it, and end up cursing myself later when I rewrite the damn thing yet again.</p>\n\n<p>Passing around a function that gets called later is <em>not that hard</em>.  We\u2019ve been doing that in JavaScript forever.  Yes, newcomers to the language, especially if they come from a language without closures and first-class functions, have a little bit of a learning curve to get used to this phenomenon.  In my opinion, you do them a disservice by trying to shield them from that.</p>\n\n<p>(Passing around function pointers in C is actually a little bit better in some ways, because you <em>can\u2019t</em> define your functions inline, and all the captured data must be passed around explicitly.  This is a bit like using named functions instead of nested closures, which is a common low-complexity approach to the alleged callback problem.)</p>\n\n<p>I\u2019ve been writing JavaScript for a while now, and other languages for a few years before I got into JavaScript.  I\u2019m not the most expert at it, but I certainly don\u2019t consider myself a newcomer.  In that time, I\u2019ve learned something:</p>\n\n<h3>We\u2019re All Idiots</h3>\n\n<p>All of us, whether experts or newcomers.  Well-meaning idiots, perhaps, but idiots.  We all write bugs, all the time.  That is the normal state of software.  There is no abstraction so perfect that a human won\u2019t fuck it up at the first opportunity.  But we can try to be better, simpler, to make it easier for our future idiotic selves to figure out what we were thinking in our cleverly idiotic brains, and chop the problems into smaller pieces so that our future selves can have some clues to find the maddeningly idiotic bugs we stuffed in there.</p>\n\n<p>If your code uses step or async or slide or Q, I can read it, and I see a function getting called and passed some arguments.  I can look at how you got that function from a require() statement, pull up that module, and look at its definition.  These are lightweight abstractions that are highly penetrable.  I\u2019ve suggested in the past that everyone should write their own flow control lib, because it\u2019s the best way to really understand how they work, and it\u2019s not that hard.  Once you grasp the basic concepts, reading someone else\u2019s flow control utility is pretty easy.</p>\n\n<p>If your code uses a compiled fibers library, or something that transforms the code, then it\u2019s <em>much</em> harder for me to figure out what the heck is going on.  The introspection is gone.  The languages change.  Stuff happens that isn\u2019t present in the code I\u2019m looking at.  <strong>This is fundamentally different from a library that just passes functions around.</strong></p>\n\n<p>That means: I won\u2019t use your library if there\u2019s any alternative (including writing the exact same functionality myself).  It\u2019s nothing personal.  I just would rather spend my time solving necessary problems rather than manufactured ones.  I simply don\u2019t believe that you\u2019ve put the same level of thinking into your coro util that TC-39 and the v8 team has put into JavaScript, or that Bert and Ryan and Ben and Igor have put into libuv.</p>\n\n<p>Not everyone is the same, and that\u2019s great!!  If you find that Fibers solve a problem <em>for you</em>, and they make the code that you write easier <em>for you</em> to manage and design, then that\u2019s awesome.  Use them.  Understand them.  Drop the illusory dichotomy of \u201cexperts\u201d and \u201cnewcomers\u201d, and realize that they are both idiots, and both you.</p>\n\n<p>Every choice that isn\u2019t completely boring will alienate someone.  Pleasing everyone is a recipe for blandness.  That\u2019s why we keep the node-core standard lib super small, and encourage variation and repetition and iteration in userland modules.</p>\n\n<h3>Absolutes</h3>\n\n<p>If your goal is to please <em>me</em> (and other stodgy \u201cjavascript is fine, callbacks aren\u2019t hard\u201d types) with a compiled coroutine library that adds magic to the language, you should realize how horribly unlikely that is.  I do actually think that this approach is fundamentally flawed.  I\u2019ve played with Marcel\u2019s fibers lib a bit, and it\u2019s about the nicest I\u2019ve seen, but it still adds an unacceptable <em>(for me!)</em> amount of magic to programs.</p>\n\n<p>Programmers tend to think in absolutes, perhaps because computers are such absolute things, or maybe just because absolutes are easier and we\u2019re all idiots.  I\u2019ve done it in this post, because I\u2019m as lazy as anyone.  Maybe you\u2019re the exception, and you actually are smart enough to use Fibers or Streamline wisely and still know what\u2019s going on when you read the code a year later.  If the benefit is greater than the cost, then go for it.  It\u2019s your house, you decide whether to wear pants or not.</p>\n\n<p>When we are discussing things like this, it\u2019s important to realize that we\u2019re artists discussing matters of taste.  If everyone agreed, then it would mean it wasn\u2019t interesting.  Maybe we should be less interested in convincing people of stuff, and more interested in just writing programs that do interesting things.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "12604303054"
            }
        }
    ],
    "type": "text"
}