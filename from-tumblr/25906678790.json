{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544051896,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "body": "<p><i>Note: This was written quite some time ago.  The current ES6 Module specification has changed a lot since then, and many of my complaints have been addressed.  Treat this essay as a piece of history.  <a href=\"#module-essay\">click here to acknowledge this caveat and read the essay.</a></i></p>\n\n<hr><div id=\"module-essay\" class=\"hidden-content\">\n<p>A few things have rubbed me the wrong way about the current Modules and\nModule Loader specification.  I regret that I have not been very clear\nabout what exactly my objections are, and worse still, I have not been\nvery clear about what I think a better direction would be.</p>\n<p><strong>Yes, this will be sent to ES-Discuss as a proper discussion\nproposal.</strong> This blog post is phase three of getting my ideas in order.\n(The first being &ldquo;get annoyed that current proposals don&rsquo;t fix the\nproblem&rdquo;, and the second being &ldquo;rant about it with friends and\ncolleagues on twitter and over tacos.&rdquo;)</p>\n<p>First of all, I want to put to rest any ideas that I&rsquo;m a die-hard\nJavaScript language conservative ideologue who will oppose any change\nwhatsoever.  I am well aware that what we have is lacking.  I would love\nto see changes that make it easier to write JavaScript module systems,\nand debug programs that use them.</p>\n<p>I believe that there is a place for new syntax, especially in cases\nwhere it allows for optimizations in the implementation, ease of\nreading, or run-time behavior that must occur before the program is\nexecuted (that is, static analysis stuff.)  Parsing a plain-old\nJavaScript AST is certainly possible, but it&rsquo;s a bit unfortunate.</p>\n<p><a name=\"module-problems\"></a>We&rsquo;ve spent a few years now doing modules in JavaScript.  The claim that\n&ldquo;JavaScript needs modules&rdquo; is thus somewhat misguided: JavaScript needs\n<strong>better</strong> modules.  Leaving aside Node.js for the moment, modular\nsystems in JavaScript generally:</p>\n<ol><li>Impose boilerplate restrictions on the programmer.  This is ugly and\nerror-prone, and there is no easy way to catch many of these errors\nearly.</li>\n<li>Are not inter-operable with code that uses a different module system\n(or none at all).</li>\n<li>Either require that all modules be present in the page at the start,\nor delay the execution of the program unacceptably.  (No one does\nsync XHR.  I&rsquo;m talking about r.js/AMD and the YUI3 seed file here.)</li>\n<li>Leaks internal implementation details in unfortunate ways, so that\nusers are sometimes surprised when behavior violates intuitions.</li>\n<li>Do not isolate global leakage, making a missing <code>var</code> a felony, when\nit shouldn&rsquo;t even be a misdemeanor.  (At best, they wrap in a\nfunction.)</li>\n<li>To varying degrees, line and column numbers are obscured.  (Sometimes\njust the first line&rsquo;s column; sometimes the stack traces are\ncompletely meaningless.)</li>\n</ol><p><strong>All</strong> of these problems are issues with Node.js as well!  We paper\nover #3 by using a package manager and requiring that the modules in\nyour program are available on the disk at the start, but it&rsquo;s still in\nmy opinion unacceptable.  We have the advantage of &ldquo;startup time&rdquo; and\n&ldquo;run time&rdquo; separation, but really, <code>&lt;script&gt;</code> tags are a web browser&rsquo;s\n&ldquo;startup time&rdquo;, and the rest of the time is its &ldquo;run time&rdquo;.  Build\nprocesses allow one to trade run-time delay (and complexity) for\nup-front download size (and a simpler synchronous <code>require()</code>), but\ngenerally only by making the other problems worse.</p>\n<p>TC-39 has one chance to specify a Module system that can address each of\nthese issues, or allow host platforms to address them effectively.\nProblems introduced here will be with us forever.  A half-way fix will\nbe prohibitively expensive to fix once it&rsquo;s in use, so we&rsquo;ll be stuck\nwith mistakes for some time (as we in Node.js are stuck with the\nmistakes in our system.)</p>\n<h2 id=\"the-good-in-the-current-spec\">The Good in the Current Spec</h2>\n<p>Though I think it has deep problems, there are very good parts in the\ncurrent spec:</p>\n<ol><li>It clearly is <em>attempting</em> to reach a module system that addresses\nthe needs of Node.js (and whatever on-device JavaScript platforms\nsucceed it), as well as those of browser-JavaScript authors and\nplatforms like RequireJS and Browserify.</li>\n<li>The issues around globals and scope are pretty solid.  I don&rsquo;t have\nmuch to complain about there.  Any changes to global behavior come\nalong with a pile of edge cases, but they&rsquo;re pretty thorougly\nevaluated and addressed.</li>\n<li>The goals of both the Module and Loader proposals had me pretty much\ncheering.  It seems like TC-39 is actually interested in solving a\nproblem, and that gives me hope.</li>\n</ol><p>More than anything, reading the spec makes it clear that the <em>problem</em>\nis fairly well understood.  However, the presented <em>solution</em> seems to\nbe headed in the wrong direction.</p>\n<h2 id=\"problems-with-the-current-spec\">Problems with the Current Spec</h2>\n<p>I&rsquo;m not going to go through the issues that I have with the current\nspec one by one.  It&rsquo;s tedious and not the conversation we should be\nhaving.  I&rsquo;ll detail my alternative proposal below.</p>\n<p>However, there are a few points I&rsquo;d like to highlight, because they are\nissues that probably ought to be informed by the experience that I and\nother module system authors and users can provide.</p>\n<ol><li><p><strong>It seems to be based on the assumption that nesting module systems is\na thing that people want.</strong>  Historically, in Node, we&rsquo;ve made several\nAPI decisions based on the <em>explicitly stated requests</em> to make the\nmodule system more extensible and flexible.  In practice, none of the\nsupposed innovation panned out, and every one of those decisions was\na huge mistake that increased flexibility with no tangible benefit.</p>\n<p> People don&rsquo;t want to write module systems.  People want to <strong>stop</strong>\n writing module systems.  Once there&rsquo;s a module system in place, it\n should be The module system, period.</p>\n<p> It bears repeating: <strong>no one wants to write a module system</strong>.  A\n few of us take it on out of regrettable necessity.  Anyone who\n actually <strong>enjoys</strong> writing module systems is too insane to be\n trusted.  The only rational position is to do the simplest necessary\n thing, and as quickly as possible get to the business of building\n real programs with it.  Optimize for that.</p>\n</li>\n<li><p><strong>It puts too many things in JavaScript (as either API or syntax)\nwhich belong in the host (browser/node.js).</strong>  As I said, people\ndon&rsquo;t actually want to write module systems in their JavaScript\nprograms.  They want to stop having to think about it.  Node&rsquo;s module\nsystem has been successful (as has require.js and browserify)\nprecisely because it requires a minimum amount of <em>thought</em> on the\npart of the user about the module system.  (It&rsquo;s still way too much.)</p>\n<p> Adding features that add complexity with the goal of making it\n easier to have lots of module systems in JavaScript is a mistake.\n Typically we can enable extension more effectively by <strong>reducing</strong>\n the scope of the specification, rather than by increasing it.</p>\n</li>\n<li><p><strong>It borrows syntax from Python that many Python users do not even\nrecommend using.</strong>  The <code>import * from mod</code> syntax is dated and\nhighly contentious in the Python community (as is <code>import com.foo.*</code>\nin Java), because it is a recipe for name collisions.  Learning from\nreal implementations is winful; but we should be avoiding their\nmistakes, not copying them.</p>\n<p> Furthermore, <code>let</code> already gives us destructuring assignment.  If\n a module exports a bunch of items, and we want several of them, then\n do <code>var {x,y,z} = import 'foo'</code> or some such.  This <code>import &lt;x&gt; from\n &lt;module&gt; as &lt;blerg&gt;</code> is 100% unnecessary, adds nothing, and solves\n no problems.  It does not pay its utility bill.</p>\n</li>\n<li><p><strong>It favors the &ldquo;object bag of exported members&rdquo; approach, rather\nthan the &ldquo;single user-defined export&rdquo; approach.</strong>  Node.js uses an\n<code>exports</code> object because the CommonJS approach seemed like a good\nidea at the time, and it works around the fact that we have no good\nway to handle transitive dependencies except via unfinished objects.</p>\n<p> However, it is widely acknowledged in the node community that using\n the <code>module.exports = xyz</code> style generally results in better\n programs.  Changes at the language level can likely address the\n transitive loading issue more powerfully, and so should encourage\n the known best practices.</p>\n</li>\n</ol><h2 id=\"a-simpler-proposal\">A Simpler Proposal</h2>\n<p>Clearly, the problems with the current state of JavaScript modules\ncannot be solved with zero changes to the language.  Some cannot be\nchanged without adding syntax.  However, every change carries with it a\ncost.  Therefor, it seems like the ideal approach is to try to find the\nminimum possible change that will address the issues &ndash; and, we ought to\nbe ruthless on which bits of functionality don&rsquo;t make the cut to be\nworth the risk.  If we can get away with a much smaller fix by refusing\nto address part of the problem which is inessential, then that is the\nright course of action.</p>\n<p>I don&rsquo;t know if this is minimal enough, but I&rsquo;d like to propose the\nfollowing, which I think picks some of the most essential aspects of the\nLoader and Module proposals.  It&rsquo;s very rough, and there are a lot of\nunanswered questions.  But in general, this is what I would like to see\nfrom a Loader specification.</p>\n<p><strong>This is very rough, and needs a lot of polish and edge-case\nexploration.</strong>  I&rsquo;m not pitching it to get it accepted, I&rsquo;m sharing it\nto hopefully help pull the conversation in another direction, and help\nmake it clear what a better proposal might look like.</p>\n<p>(I&rsquo;ve numbered them simply so that I can refer to bits later, not so\nmuch because they&rsquo;re a list of like things in order.  I&rsquo;m a spec n00b.)</p>\n<ol><li><p>A <code>Loader</code> built-in object, with a few methods that must be\nspecified before modules can be used.  (And will typically be\nspecified by the host object.)</p>\n</li>\n<li><p>Within a module, the <code>import &lt;pathString&gt;</code> syntax that can be easily\ndetected statically in program text before evaluation, and returns a\nmodule&rsquo;s exported object.  <code>var foo = import 'path/to/foo.js'</code>.\nImport returns a single value, always.  The path must be a string\nliteral.  The import keyword is an operator, not a function, and thus\ncannot be assigned etc.</p>\n</li>\n<li><p><code>Loader.define(&lt;path&gt;, &lt;program text&gt;)</code> defines a module at the\nspecified <code>&lt;path&gt;</code>, with the <code>&lt;program text&gt;</code> contents.  That\n<code>&lt;program text&gt;</code> is statically analyzed for any <code>import</code> statements.</p>\n</li>\n<li><p>Whenever an <code>import &lt;path&gt;</code> is encountered in <code>&lt;program text&gt;</code> then\nthe <code>Loader.resolve(requestPath, callerPath, callback)</code> is called.\nThis method should return a fully qualified path.  If this method\nreturns boolean <code>true</code>, then it will not be considered resolved until\nthe callback is called.  (The argument to the callback is the string\npath.) If it does not return true, and does not return a string path,\nthen this is an error, and throws.</p>\n</li>\n<li><p>Once a module is resolved to a full path string, then\n<code>Loader.load(fullPath, callback)</code> is called.  <code>callback</code> should not\nbe called until <code>Loader.define(fullPath, contents)</code> is called.\nThis should be called at most once for any given <code>fullPath</code>.  (Is the\ncallback even necessary?  Why not just wait for <code>Loader.define</code> and\nthrow any errors encountered?)</p>\n</li>\n<li><p>The <code>Loader.main(fullPath)</code> method executes the module referenced by\n<code>fullPath</code> (which must have already been defined), as well as\nevaluating each of the modules that it imports.</p>\n</li>\n<li><p>Within a module, the <code>export &lt;expression&gt;</code> statement marks the result\nof <code>&lt;expression&gt;</code> as the exported value from the module.  <strong>There can\nbe at most one export statement in a module</strong>, and the exported\nexpression is the module&rsquo;s export.  To export more than one thing,\nexport an object with more than one thing on it.</p>\n<p> Modules export a single value.  Exporting a second time throws.</p>\n<p> Maybe this is not a valid cause for syntax addition.  I&rsquo;m not sure.\n There are hairy problems around cyclic dependencies, so it&rsquo;s worth\n at least having the option to address with static magic that has not\n yet been fully imagined.</p>\n</li>\n<li><p>The global object within a module context is equivalent to\n<code>Object.create(&lt;global&gt;)</code> from the main global context.  (The\nimportant thing is that leaks aren&rsquo;t leaky outside the module, but\nfor example, <code>x typeof Error</code> still works, because it uses the same\nError function.)</p>\n</li>\n<li><p>If a module does not contain an <code>export</code> statement, then its global\nobject is its export.  This is to provide support for legacy modules\nthat create a global object (such as <code>jQuery</code>) rather than using an\nexport statement.  (Too magical?  Probably.  Also, what about having\nexports inheriting from global is weird.  Is there a simpler way to\nmake existing libs place nicely with this approach?)</p>\n</li>\n</ol><p>The default values of <code>Loader.load</code>, <code>Loader.define</code>, and\n<code>Loader.resolve</code> would typically be set by the host environment.\nHowever, for reasons of simplicity, they <strong>must</strong> be set in normal\nprogram text (ie, not in a module), and modules should not have the\nability to alter them.</p>\n<p>In web browsers, modules could be defined straight away by using a new\nattribute on the script tag: <code>&lt;script module\nsrc='http://src.com/foo.js'&gt;&lt;/script&gt;</code> would be equivalent to doing\n<code>Loader.define('http://src.com/foo.js', '&lt;contents of foo.js&gt;)</code>.</p>\n<p>Bundler programs could trivially translate files into modules using\nLoader.define (rather than wrapping in a IIFE), or JavaScript files\ncould be loaded as-is, without requiring that existing libraries begin\nusing any <code>module { ... }</code> syntax.</p>\n<h2 id=\"in-web-browsers\">In Web Browsers</h2>\n<p>Web Browsers could implement the Loader object thusly:</p>\n<ul><li><code>Loader.resolve(request, from)</code> Uses standard URL-resolution rules.</li>\n<li><code>Loader.define</code> could be sweetened by a <code>&lt;script module&gt;</code> tag.</li>\n<li><code>Loader.main</code> could be set via a <code>&lt;script module main&gt;</code> tag.</li>\n<li><code>Loader.load</code> could fetch the URL, and evaluate the contents, as if it\nhad been added to the document with a <code>&lt;script module src=...&gt;</code> tag.</li>\n</ul><p>For additional extensibility, these methods could be overridden by, for\nexample, browserify or RequireJS.</p>\n<p>For security, the Loader object could be frozen with <code>Object.freeze</code> to\nprevent additional changes.</p>\n<p>I&rsquo;m in no way attached to the specifics of the tag spelling.  My point\nis that we in the JS community should specify the loader semantics, and\nthen let host objects take advantage of them in application-specific\nways.</p>\n<h2 id=\"in-require-js\">In Require.JS</h2>\n<p>RequireJS and other AMD platforms would be pretty much made mostly\nobsolete by this specification, since the principle of AMD would just be\n&ldquo;how it works&rdquo; in web browsers by default.  But, without the unfortunate\nboilerplate, and the resource loading mechanism could kick off much\nsooner, since <code>import</code> statements can be detected long before the script\nis actually run.</p>\n<h2 id=\"in-browserify\">In Browserify</h2>\n<p>Most browserify modules would Just Work if they replaced <code>require(..)</code>\nwith <code>import ..</code>.  However, it would probably be necessary to extend the\n<code>Loader</code> methods to provide shims for Node.js built-ins (ie, path, fs,\nurl, assert, net, http, etc.) as well as pre-define <code>node_modules</code>\ndependencies into the browserify bundle.</p>\n<p>However, Browserify&rsquo;s static analysis build step could be made much more\neffective by using a designated <code>import</code> operator rather than relying on\nknowledge of a <code>require</code> function.</p>\n<h2 id=\"in-node-js\">In Node.js</h2>\n<ul><li><code>Loader.resolve(request, from)</code> would do the current <code>node_modules</code>\nand <code>NODE_PATH</code> dance.</li>\n<li><code>Loader.define</code> would replace the existing module wrapper stuff.</li>\n<li><code>Loader.main</code> would be called on the module specified as a command\nline argument.</li>\n<li><code>Loader.load</code> would be very straightforward FS operations.</li>\n</ul><p>This would also set the stage for making node-core itself more modular,\nand we could even explore new approaches like detecting module\ndependencies from code, rather than requiring the use of a\n<code>package.json</code> file, which is very exciting.</p>\n<h2 id=\"what-s-missing-from-this-proposal\">What&rsquo;s Missing from this Proposal</h2>\n<p>There is no <code>module</code> syntax in this &ldquo;module&rdquo; proposal.  That is because\nit is unnecessary, and its omission is intentional.</p>\n<p>A lot of work has also been done on the Harmony Module Loader proposal\nto flesh out some details of the Loader object.  Most of this is good\nstuff.  However, by removing the Module syntax portion of the proposal,\na lot of those things can be streamlined.</p>\n<p>It&rsquo;s also worth mentioning that this approach make sourcemaps\nunnecessary for useful stack traces, even in bundled or concatenated\ncode, as the <code>Loader.define()</code> syntax would function as a sourcemap.</p>\n<p>While the experience in the wild has shown us that the &ldquo;export one\nthing&rdquo; approach is definition sound, I&rsquo;m not sure exactly how to handle\nthe transitive dependency issue in a way that doesn&rsquo;t involve unfinished\nobjects, or cause breakage in cases like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\n\n// y.js\nsetTimeout(function() {\n  export { fooled: 'you' }\n}, 100)\n</code></pre><p>Even more insidious is something like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\nexport { real: 'x' }\n\n// y.js\nvar x = import './x.js'\nassert.deepEqual(x, {real: 'x'}) // nope!!\n</code></pre><p>Because <code>x</code> sets its export <em>after</em> being loaded by <code>y</code>, the assignment\ndoes nothing. Currently, in Node.js (and most other systems as well)\nthis is not handled, or not handled very well at least.</p>\n<p>Is there some way that it could somehow pass an object to the <code>x</code> module\nthat would get swapped out behind the scenes when <code>y.js</code> changes its\nexport?  Is that too magical?  I&rsquo;m not sure.</p>\n<h2 id=\"next-\">Next&hellip;</h2>\n<p>My hope is that this post will help spark a more interesting\nconversation than the current tendency towards &ldquo;YAY/BOO&rdquo; that is so\ncommon in the internet.  This isn&rsquo;t politics.  We&rsquo;re not voting for\nparties.  The goal is to figure out the best API, which is a complex\nthing.  The solution space is wide, and it is naive to reduce it to a\nboolean prematurely.</p>\n<p>I would like to try out some implementations of this in Node.js as soon\nas possible.  Also, I&rsquo;d love to hear feedback about which parts of this\nyou think are unnecessary or impossible.</p>\n<p>Let&rsquo;s not forget that we all want these problems solved.  No reasonable\nperson thinks that JavaScript programs are optimally modular today.\nMost people who enjoy Node&rsquo;s module system only like it because they&rsquo;ve\nnever taken a close look at it.  As one of its maintainers and chief\narchitects, I feel qualified to say that it&rsquo;s pretty terrible.  (Though,\nin my opinion, it is the best I&rsquo;ve used, and the only that is optimized\nfor maximum utility and an absolute intolerance for boilerplate.  It&rsquo;s\njust that the language is lacking, but that&rsquo;s what this is all about.)</p>\n<p>Not every change is an improvement, but every improvement is a change.\nMy friends in the &ldquo;no new syntax&rdquo; crowd would do well to remember that.</p>\n<p>That being said, since JavaScript cannot be easily changed, and can only\nbe changed in one direction, we must be very careful to make sure that\nevery change <strong>is</strong> an improvement.  It&rsquo;s more important to proceed\ncarefully than to proceed quickly.</p>\n<p>Future generations will thank us for our care, and curse us for our haste.</p>\n</div>",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "date": "2012-06-26 04:25:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "id": 25906678790,
    "is_blocks_post_format": false,
    "note_count": 20,
    "post_url": "http://blog.izs.me/post/25906678790/on-es-6-modules",
    "reblog": {
        "comment": "<p><p><i>Note: This was written quite some time ago.  The current ES6 Module specification has changed a lot since then, and many of my complaints have been addressed.  Treat this essay as a piece of history.  <a href=\"#module-essay\">click here to acknowledge this caveat and read the essay.</a></i></p>\n\n<hr><div id=\"module-essay\" class=\"hidden-content\">\n<p>A few things have rubbed me the wrong way about the current Modules and\nModule Loader specification.  I regret that I have not been very clear\nabout what exactly my objections are, and worse still, I have not been\nvery clear about what I think a better direction would be.</p>\n<p><strong>Yes, this will be sent to ES-Discuss as a proper discussion\nproposal.</strong> This blog post is phase three of getting my ideas in order.\n(The first being \u201cget annoyed that current proposals don\u2019t fix the\nproblem\u201d, and the second being \u201crant about it with friends and\ncolleagues on twitter and over tacos.\u201d)</p>\n<p>First of all, I want to put to rest any ideas that I\u2019m a die-hard\nJavaScript language conservative ideologue who will oppose any change\nwhatsoever.  I am well aware that what we have is lacking.  I would love\nto see changes that make it easier to write JavaScript module systems,\nand debug programs that use them.</p>\n<p>I believe that there is a place for new syntax, especially in cases\nwhere it allows for optimizations in the implementation, ease of\nreading, or run-time behavior that must occur before the program is\nexecuted (that is, static analysis stuff.)  Parsing a plain-old\nJavaScript AST is certainly possible, but it\u2019s a bit unfortunate.</p>\n<p><a name=\"module-problems\"></a>We\u2019ve spent a few years now doing modules in JavaScript.  The claim that\n\u201cJavaScript needs modules\u201d is thus somewhat misguided: JavaScript needs\n<strong>better</strong> modules.  Leaving aside Node.js for the moment, modular\nsystems in JavaScript generally:</p>\n<ol><li>Impose boilerplate restrictions on the programmer.  This is ugly and\nerror-prone, and there is no easy way to catch many of these errors\nearly.</li>\n<li>Are not inter-operable with code that uses a different module system\n(or none at all).</li>\n<li>Either require that all modules be present in the page at the start,\nor delay the execution of the program unacceptably.  (No one does\nsync XHR.  I\u2019m talking about r.js/AMD and the YUI3 seed file here.)</li>\n<li>Leaks internal implementation details in unfortunate ways, so that\nusers are sometimes surprised when behavior violates intuitions.</li>\n<li>Do not isolate global leakage, making a missing <code>var</code> a felony, when\nit shouldn\u2019t even be a misdemeanor.  (At best, they wrap in a\nfunction.)</li>\n<li>To varying degrees, line and column numbers are obscured.  (Sometimes\njust the first line\u2019s column; sometimes the stack traces are\ncompletely meaningless.)</li>\n</ol><p><strong>All</strong> of these problems are issues with Node.js as well!  We paper\nover #3 by using a package manager and requiring that the modules in\nyour program are available on the disk at the start, but it\u2019s still in\nmy opinion unacceptable.  We have the advantage of \u201cstartup time\u201d and\n\u201crun time\u201d separation, but really, <code>&lt;script&gt;</code> tags are a web browser\u2019s\n\u201cstartup time\u201d, and the rest of the time is its \u201crun time\u201d.  Build\nprocesses allow one to trade run-time delay (and complexity) for\nup-front download size (and a simpler synchronous <code>require()</code>), but\ngenerally only by making the other problems worse.</p>\n<p>TC-39 has one chance to specify a Module system that can address each of\nthese issues, or allow host platforms to address them effectively.\nProblems introduced here will be with us forever.  A half-way fix will\nbe prohibitively expensive to fix once it\u2019s in use, so we\u2019ll be stuck\nwith mistakes for some time (as we in Node.js are stuck with the\nmistakes in our system.)</p>\n<h2 id=\"the-good-in-the-current-spec\">The Good in the Current Spec</h2>\n<p>Though I think it has deep problems, there are very good parts in the\ncurrent spec:</p>\n<ol><li>It clearly is <em>attempting</em> to reach a module system that addresses\nthe needs of Node.js (and whatever on-device JavaScript platforms\nsucceed it), as well as those of browser-JavaScript authors and\nplatforms like RequireJS and Browserify.</li>\n<li>The issues around globals and scope are pretty solid.  I don\u2019t have\nmuch to complain about there.  Any changes to global behavior come\nalong with a pile of edge cases, but they\u2019re pretty thorougly\nevaluated and addressed.</li>\n<li>The goals of both the Module and Loader proposals had me pretty much\ncheering.  It seems like TC-39 is actually interested in solving a\nproblem, and that gives me hope.</li>\n</ol><p>More than anything, reading the spec makes it clear that the <em>problem</em>\nis fairly well understood.  However, the presented <em>solution</em> seems to\nbe headed in the wrong direction.</p>\n<h2 id=\"problems-with-the-current-spec\">Problems with the Current Spec</h2>\n<p>I\u2019m not going to go through the issues that I have with the current\nspec one by one.  It\u2019s tedious and not the conversation we should be\nhaving.  I\u2019ll detail my alternative proposal below.</p>\n<p>However, there are a few points I\u2019d like to highlight, because they are\nissues that probably ought to be informed by the experience that I and\nother module system authors and users can provide.</p>\n<ol><li><p><strong>It seems to be based on the assumption that nesting module systems is\na thing that people want.</strong>  Historically, in Node, we\u2019ve made several\nAPI decisions based on the <em>explicitly stated requests</em> to make the\nmodule system more extensible and flexible.  In practice, none of the\nsupposed innovation panned out, and every one of those decisions was\na huge mistake that increased flexibility with no tangible benefit.</p>\n<p> People don\u2019t want to write module systems.  People want to <strong>stop</strong>\n writing module systems.  Once there\u2019s a module system in place, it\n should be The module system, period.</p>\n<p> It bears repeating: <strong>no one wants to write a module system</strong>.  A\n few of us take it on out of regrettable necessity.  Anyone who\n actually <strong>enjoys</strong> writing module systems is too insane to be\n trusted.  The only rational position is to do the simplest necessary\n thing, and as quickly as possible get to the business of building\n real programs with it.  Optimize for that.</p>\n</li>\n<li><p><strong>It puts too many things in JavaScript (as either API or syntax)\nwhich belong in the host (browser/node.js).</strong>  As I said, people\ndon\u2019t actually want to write module systems in their JavaScript\nprograms.  They want to stop having to think about it.  Node\u2019s module\nsystem has been successful (as has require.js and browserify)\nprecisely because it requires a minimum amount of <em>thought</em> on the\npart of the user about the module system.  (It\u2019s still way too much.)</p>\n<p> Adding features that add complexity with the goal of making it\n easier to have lots of module systems in JavaScript is a mistake.\n Typically we can enable extension more effectively by <strong>reducing</strong>\n the scope of the specification, rather than by increasing it.</p>\n</li>\n<li><p><strong>It borrows syntax from Python that many Python users do not even\nrecommend using.</strong>  The <code>import * from mod</code> syntax is dated and\nhighly contentious in the Python community (as is <code>import com.foo.*</code>\nin Java), because it is a recipe for name collisions.  Learning from\nreal implementations is winful; but we should be avoiding their\nmistakes, not copying them.</p>\n<p> Furthermore, <code>let</code> already gives us destructuring assignment.  If\n a module exports a bunch of items, and we want several of them, then\n do <code>var {x,y,z} = import 'foo'</code> or some such.  This <code>import &lt;x&gt; from\n &lt;module&gt; as &lt;blerg&gt;</code> is 100% unnecessary, adds nothing, and solves\n no problems.  It does not pay its utility bill.</p>\n</li>\n<li><p><strong>It favors the \u201cobject bag of exported members\u201d approach, rather\nthan the \u201csingle user-defined export\u201d approach.</strong>  Node.js uses an\n<code>exports</code> object because the CommonJS approach seemed like a good\nidea at the time, and it works around the fact that we have no good\nway to handle transitive dependencies except via unfinished objects.</p>\n<p> However, it is widely acknowledged in the node community that using\n the <code>module.exports = xyz</code> style generally results in better\n programs.  Changes at the language level can likely address the\n transitive loading issue more powerfully, and so should encourage\n the known best practices.</p>\n</li>\n</ol><h2 id=\"a-simpler-proposal\">A Simpler Proposal</h2>\n<p>Clearly, the problems with the current state of JavaScript modules\ncannot be solved with zero changes to the language.  Some cannot be\nchanged without adding syntax.  However, every change carries with it a\ncost.  Therefor, it seems like the ideal approach is to try to find the\nminimum possible change that will address the issues \u2013 and, we ought to\nbe ruthless on which bits of functionality don\u2019t make the cut to be\nworth the risk.  If we can get away with a much smaller fix by refusing\nto address part of the problem which is inessential, then that is the\nright course of action.</p>\n<p>I don\u2019t know if this is minimal enough, but I\u2019d like to propose the\nfollowing, which I think picks some of the most essential aspects of the\nLoader and Module proposals.  It\u2019s very rough, and there are a lot of\nunanswered questions.  But in general, this is what I would like to see\nfrom a Loader specification.</p>\n<p><strong>This is very rough, and needs a lot of polish and edge-case\nexploration.</strong>  I\u2019m not pitching it to get it accepted, I\u2019m sharing it\nto hopefully help pull the conversation in another direction, and help\nmake it clear what a better proposal might look like.</p>\n<p>(I\u2019ve numbered them simply so that I can refer to bits later, not so\nmuch because they\u2019re a list of like things in order.  I\u2019m a spec n00b.)</p>\n<ol><li><p>A <code>Loader</code> built-in object, with a few methods that must be\nspecified before modules can be used.  (And will typically be\nspecified by the host object.)</p>\n</li>\n<li><p>Within a module, the <code>import &lt;pathString&gt;</code> syntax that can be easily\ndetected statically in program text before evaluation, and returns a\nmodule\u2019s exported object.  <code>var foo = import 'path/to/foo.js'</code>.\nImport returns a single value, always.  The path must be a string\nliteral.  The import keyword is an operator, not a function, and thus\ncannot be assigned etc.</p>\n</li>\n<li><p><code>Loader.define(&lt;path&gt;, &lt;program text&gt;)</code> defines a module at the\nspecified <code>&lt;path&gt;</code>, with the <code>&lt;program text&gt;</code> contents.  That\n<code>&lt;program text&gt;</code> is statically analyzed for any <code>import</code> statements.</p>\n</li>\n<li><p>Whenever an <code>import &lt;path&gt;</code> is encountered in <code>&lt;program text&gt;</code> then\nthe <code>Loader.resolve(requestPath, callerPath, callback)</code> is called.\nThis method should return a fully qualified path.  If this method\nreturns boolean <code>true</code>, then it will not be considered resolved until\nthe callback is called.  (The argument to the callback is the string\npath.) If it does not return true, and does not return a string path,\nthen this is an error, and throws.</p>\n</li>\n<li><p>Once a module is resolved to a full path string, then\n<code>Loader.load(fullPath, callback)</code> is called.  <code>callback</code> should not\nbe called until <code>Loader.define(fullPath, contents)</code> is called.\nThis should be called at most once for any given <code>fullPath</code>.  (Is the\ncallback even necessary?  Why not just wait for <code>Loader.define</code> and\nthrow any errors encountered?)</p>\n</li>\n<li><p>The <code>Loader.main(fullPath)</code> method executes the module referenced by\n<code>fullPath</code> (which must have already been defined), as well as\nevaluating each of the modules that it imports.</p>\n</li>\n<li><p>Within a module, the <code>export &lt;expression&gt;</code> statement marks the result\nof <code>&lt;expression&gt;</code> as the exported value from the module.  <strong>There can\nbe at most one export statement in a module</strong>, and the exported\nexpression is the module\u2019s export.  To export more than one thing,\nexport an object with more than one thing on it.</p>\n<p> Modules export a single value.  Exporting a second time throws.</p>\n<p> Maybe this is not a valid cause for syntax addition.  I\u2019m not sure.\n There are hairy problems around cyclic dependencies, so it\u2019s worth\n at least having the option to address with static magic that has not\n yet been fully imagined.</p>\n</li>\n<li><p>The global object within a module context is equivalent to\n<code>Object.create(&lt;global&gt;)</code> from the main global context.  (The\nimportant thing is that leaks aren\u2019t leaky outside the module, but\nfor example, <code>x typeof Error</code> still works, because it uses the same\nError function.)</p>\n</li>\n<li><p>If a module does not contain an <code>export</code> statement, then its global\nobject is its export.  This is to provide support for legacy modules\nthat create a global object (such as <code>jQuery</code>) rather than using an\nexport statement.  (Too magical?  Probably.  Also, what about having\nexports inheriting from global is weird.  Is there a simpler way to\nmake existing libs place nicely with this approach?)</p>\n</li>\n</ol><p>The default values of <code>Loader.load</code>, <code>Loader.define</code>, and\n<code>Loader.resolve</code> would typically be set by the host environment.\nHowever, for reasons of simplicity, they <strong>must</strong> be set in normal\nprogram text (ie, not in a module), and modules should not have the\nability to alter them.</p>\n<p>In web browsers, modules could be defined straight away by using a new\nattribute on the script tag: <code>&lt;script module\nsrc='http://src.com/foo.js'&gt;&lt;/script&gt;</code> would be equivalent to doing\n<code>Loader.define('http://src.com/foo.js', '&lt;contents of foo.js&gt;)</code>.</p>\n<p>Bundler programs could trivially translate files into modules using\nLoader.define (rather than wrapping in a IIFE), or JavaScript files\ncould be loaded as-is, without requiring that existing libraries begin\nusing any <code>module { ... }</code> syntax.</p>\n<h2 id=\"in-web-browsers\">In Web Browsers</h2>\n<p>Web Browsers could implement the Loader object thusly:</p>\n<ul><li><code>Loader.resolve(request, from)</code> Uses standard URL-resolution rules.</li>\n<li><code>Loader.define</code> could be sweetened by a <code>&lt;script module&gt;</code> tag.</li>\n<li><code>Loader.main</code> could be set via a <code>&lt;script module main&gt;</code> tag.</li>\n<li><code>Loader.load</code> could fetch the URL, and evaluate the contents, as if it\nhad been added to the document with a <code>&lt;script module src=...&gt;</code> tag.</li>\n</ul><p>For additional extensibility, these methods could be overridden by, for\nexample, browserify or RequireJS.</p>\n<p>For security, the Loader object could be frozen with <code>Object.freeze</code> to\nprevent additional changes.</p>\n<p>I\u2019m in no way attached to the specifics of the tag spelling.  My point\nis that we in the JS community should specify the loader semantics, and\nthen let host objects take advantage of them in application-specific\nways.</p>\n<h2 id=\"in-require-js\">In Require.JS</h2>\n<p>RequireJS and other AMD platforms would be pretty much made mostly\nobsolete by this specification, since the principle of AMD would just be\n\u201chow it works\u201d in web browsers by default.  But, without the unfortunate\nboilerplate, and the resource loading mechanism could kick off much\nsooner, since <code>import</code> statements can be detected long before the script\nis actually run.</p>\n<h2 id=\"in-browserify\">In Browserify</h2>\n<p>Most browserify modules would Just Work if they replaced <code>require(..)</code>\nwith <code>import ..</code>.  However, it would probably be necessary to extend the\n<code>Loader</code> methods to provide shims for Node.js built-ins (ie, path, fs,\nurl, assert, net, http, etc.) as well as pre-define <code>node_modules</code>\ndependencies into the browserify bundle.</p>\n<p>However, Browserify\u2019s static analysis build step could be made much more\neffective by using a designated <code>import</code> operator rather than relying on\nknowledge of a <code>require</code> function.</p>\n<h2 id=\"in-node-js\">In Node.js</h2>\n<ul><li><code>Loader.resolve(request, from)</code> would do the current <code>node_modules</code>\nand <code>NODE_PATH</code> dance.</li>\n<li><code>Loader.define</code> would replace the existing module wrapper stuff.</li>\n<li><code>Loader.main</code> would be called on the module specified as a command\nline argument.</li>\n<li><code>Loader.load</code> would be very straightforward FS operations.</li>\n</ul><p>This would also set the stage for making node-core itself more modular,\nand we could even explore new approaches like detecting module\ndependencies from code, rather than requiring the use of a\n<code>package.json</code> file, which is very exciting.</p>\n<h2 id=\"what-s-missing-from-this-proposal\">What\u2019s Missing from this Proposal</h2>\n<p>There is no <code>module</code> syntax in this \u201cmodule\u201d proposal.  That is because\nit is unnecessary, and its omission is intentional.</p>\n<p>A lot of work has also been done on the Harmony Module Loader proposal\nto flesh out some details of the Loader object.  Most of this is good\nstuff.  However, by removing the Module syntax portion of the proposal,\na lot of those things can be streamlined.</p>\n<p>It\u2019s also worth mentioning that this approach make sourcemaps\nunnecessary for useful stack traces, even in bundled or concatenated\ncode, as the <code>Loader.define()</code> syntax would function as a sourcemap.</p>\n<p>While the experience in the wild has shown us that the \u201cexport one\nthing\u201d approach is definition sound, I\u2019m not sure exactly how to handle\nthe transitive dependency issue in a way that doesn\u2019t involve unfinished\nobjects, or cause breakage in cases like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\n\n// y.js\nsetTimeout(function() {\n  export { fooled: 'you' }\n}, 100)\n</code></pre><p>Even more insidious is something like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\nexport { real: 'x' }\n\n// y.js\nvar x = import './x.js'\nassert.deepEqual(x, {real: 'x'}) // nope!!\n</code></pre><p>Because <code>x</code> sets its export <em>after</em> being loaded by <code>y</code>, the assignment\ndoes nothing. Currently, in Node.js (and most other systems as well)\nthis is not handled, or not handled very well at least.</p>\n<p>Is there some way that it could somehow pass an object to the <code>x</code> module\nthat would get swapped out behind the scenes when <code>y.js</code> changes its\nexport?  Is that too magical?  I\u2019m not sure.</p>\n<h2 id=\"next-\">Next\u2026</h2>\n<p>My hope is that this post will help spark a more interesting\nconversation than the current tendency towards \u201cYAY/BOO\u201d that is so\ncommon in the internet.  This isn\u2019t politics.  We\u2019re not voting for\nparties.  The goal is to figure out the best API, which is a complex\nthing.  The solution space is wide, and it is naive to reduce it to a\nboolean prematurely.</p>\n<p>I would like to try out some implementations of this in Node.js as soon\nas possible.  Also, I\u2019d love to hear feedback about which parts of this\nyou think are unnecessary or impossible.</p>\n<p>Let\u2019s not forget that we all want these problems solved.  No reasonable\nperson thinks that JavaScript programs are optimally modular today.\nMost people who enjoy Node\u2019s module system only like it because they\u2019ve\nnever taken a close look at it.  As one of its maintainers and chief\narchitects, I feel qualified to say that it\u2019s pretty terrible.  (Though,\nin my opinion, it is the best I\u2019ve used, and the only that is optimized\nfor maximum utility and an absolute intolerance for boilerplate.  It\u2019s\njust that the language is lacking, but that\u2019s what this is all about.)</p>\n<p>Not every change is an improvement, but every improvement is a change.\nMy friends in the \u201cno new syntax\u201d crowd would do well to remember that.</p>\n<p>That being said, since JavaScript cannot be easily changed, and can only\nbe changed in one direction, we must be very careful to make sure that\nevery change <strong>is</strong> an improvement.  It\u2019s more important to proceed\ncarefully than to proceed quickly.</p>\n<p>Future generations will thank us for our care, and curse us for our haste.</p>\n</div></p>",
        "tree_html": ""
    },
    "reblog_key": "cbn2o1t8",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWyO8A8m6",
    "slug": "on-es-6-modules",
    "state": "published",
    "summary": "On ES 6 Modules",
    "tags": [],
    "timestamp": 1340684700,
    "title": "On ES 6 Modules",
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p><p><i>Note: This was written quite some time ago.  The current ES6 Module specification has changed a lot since then, and many of my complaints have been addressed.  Treat this essay as a piece of history.  <a href=\"#module-essay\">click here to acknowledge this caveat and read the essay.</a></i></p>\n\n<hr />\n<p>A few things have rubbed me the wrong way about the current Modules and\nModule Loader specification.  I regret that I have not been very clear\nabout what exactly my objections are, and worse still, I have not been\nvery clear about what I think a better direction would be.</p>\n<p><strong>Yes, this will be sent to ES-Discuss as a proper discussion\nproposal.</strong> This blog post is phase three of getting my ideas in order.\n(The first being &ldquo;get annoyed that current proposals don&rsquo;t fix the\nproblem&rdquo;, and the second being &ldquo;rant about it with friends and\ncolleagues on twitter and over tacos.&rdquo;)</p>\n<p>First of all, I want to put to rest any ideas that I&rsquo;m a die-hard\nJavaScript language conservative ideologue who will oppose any change\nwhatsoever.  I am well aware that what we have is lacking.  I would love\nto see changes that make it easier to write JavaScript module systems,\nand debug programs that use them.</p>\n<p>I believe that there is a place for new syntax, especially in cases\nwhere it allows for optimizations in the implementation, ease of\nreading, or run-time behavior that must occur before the program is\nexecuted (that is, static analysis stuff.)  Parsing a plain-old\nJavaScript AST is certainly possible, but it&rsquo;s a bit unfortunate.</p>\n<p><a></a>We&rsquo;ve spent a few years now doing modules in JavaScript.  The claim that\n&ldquo;JavaScript needs modules&rdquo; is thus somewhat misguided: JavaScript needs\n<strong>better</strong> modules.  Leaving aside Node.js for the moment, modular\nsystems in JavaScript generally:</p>\n<ol><li>Impose boilerplate restrictions on the programmer.  This is ugly and\nerror-prone, and there is no easy way to catch many of these errors\nearly.</li>\n<li>Are not inter-operable with code that uses a different module system\n(or none at all).</li>\n<li>Either require that all modules be present in the page at the start,\nor delay the execution of the program unacceptably.  (No one does\nsync XHR.  I&rsquo;m talking about r.js/AMD and the YUI3 seed file here.)</li>\n<li>Leaks internal implementation details in unfortunate ways, so that\nusers are sometimes surprised when behavior violates intuitions.</li>\n<li>Do not isolate global leakage, making a missing <code>var</code> a felony, when\nit shouldn&rsquo;t even be a misdemeanor.  (At best, they wrap in a\nfunction.)</li>\n<li>To varying degrees, line and column numbers are obscured.  (Sometimes\njust the first line&rsquo;s column; sometimes the stack traces are\ncompletely meaningless.)</li>\n</ol><p><strong>All</strong> of these problems are issues with Node.js as well!  We paper\nover #3 by using a package manager and requiring that the modules in\nyour program are available on the disk at the start, but it&rsquo;s still in\nmy opinion unacceptable.  We have the advantage of &ldquo;startup time&rdquo; and\n&ldquo;run time&rdquo; separation, but really, <code>&lt;script&gt;</code> tags are a web browser&rsquo;s\n&ldquo;startup time&rdquo;, and the rest of the time is its &ldquo;run time&rdquo;.  Build\nprocesses allow one to trade run-time delay (and complexity) for\nup-front download size (and a simpler synchronous <code>require()</code>), but\ngenerally only by making the other problems worse.</p>\n<p>TC-39 has one chance to specify a Module system that can address each of\nthese issues, or allow host platforms to address them effectively.\nProblems introduced here will be with us forever.  A half-way fix will\nbe prohibitively expensive to fix once it&rsquo;s in use, so we&rsquo;ll be stuck\nwith mistakes for some time (as we in Node.js are stuck with the\nmistakes in our system.)</p>\n<h2>The Good in the Current Spec</h2>\n<p>Though I think it has deep problems, there are very good parts in the\ncurrent spec:</p>\n<ol><li>It clearly is <em>attempting</em> to reach a module system that addresses\nthe needs of Node.js (and whatever on-device JavaScript platforms\nsucceed it), as well as those of browser-JavaScript authors and\nplatforms like RequireJS and Browserify.</li>\n<li>The issues around globals and scope are pretty solid.  I don&rsquo;t have\nmuch to complain about there.  Any changes to global behavior come\nalong with a pile of edge cases, but they&rsquo;re pretty thorougly\nevaluated and addressed.</li>\n<li>The goals of both the Module and Loader proposals had me pretty much\ncheering.  It seems like TC-39 is actually interested in solving a\nproblem, and that gives me hope.</li>\n</ol><p>More than anything, reading the spec makes it clear that the <em>problem</em>\nis fairly well understood.  However, the presented <em>solution</em> seems to\nbe headed in the wrong direction.</p>\n<h2>Problems with the Current Spec</h2>\n<p>I&rsquo;m not going to go through the issues that I have with the current\nspec one by one.  It&rsquo;s tedious and not the conversation we should be\nhaving.  I&rsquo;ll detail my alternative proposal below.</p>\n<p>However, there are a few points I&rsquo;d like to highlight, because they are\nissues that probably ought to be informed by the experience that I and\nother module system authors and users can provide.</p>\n<ol><li><p><strong>It seems to be based on the assumption that nesting module systems is\na thing that people want.</strong>  Historically, in Node, we&rsquo;ve made several\nAPI decisions based on the <em>explicitly stated requests</em> to make the\nmodule system more extensible and flexible.  In practice, none of the\nsupposed innovation panned out, and every one of those decisions was\na huge mistake that increased flexibility with no tangible benefit.</p>\n<p> People don&rsquo;t want to write module systems.  People want to <strong>stop</strong>\n writing module systems.  Once there&rsquo;s a module system in place, it\n should be The module system, period.</p>\n<p> It bears repeating: <strong>no one wants to write a module system</strong>.  A\n few of us take it on out of regrettable necessity.  Anyone who\n actually <strong>enjoys</strong> writing module systems is too insane to be\n trusted.  The only rational position is to do the simplest necessary\n thing, and as quickly as possible get to the business of building\n real programs with it.  Optimize for that.</p>\n</li>\n<li><p><strong>It puts too many things in JavaScript (as either API or syntax)\nwhich belong in the host (browser/node.js).</strong>  As I said, people\ndon&rsquo;t actually want to write module systems in their JavaScript\nprograms.  They want to stop having to think about it.  Node&rsquo;s module\nsystem has been successful (as has require.js and browserify)\nprecisely because it requires a minimum amount of <em>thought</em> on the\npart of the user about the module system.  (It&rsquo;s still way too much.)</p>\n<p> Adding features that add complexity with the goal of making it\n easier to have lots of module systems in JavaScript is a mistake.\n Typically we can enable extension more effectively by <strong>reducing</strong>\n the scope of the specification, rather than by increasing it.</p>\n</li>\n<li><p><strong>It borrows syntax from Python that many Python users do not even\nrecommend using.</strong>  The <code>import * from mod</code> syntax is dated and\nhighly contentious in the Python community (as is <code>import com.foo.*</code>\nin Java), because it is a recipe for name collisions.  Learning from\nreal implementations is winful; but we should be avoiding their\nmistakes, not copying them.</p>\n<p> Furthermore, <code>let</code> already gives us destructuring assignment.  If\n a module exports a bunch of items, and we want several of them, then\n do <code>var {x,y,z} = import 'foo'</code> or some such.  This <code>import &lt;x&gt; from\n &lt;module&gt; as &lt;blerg&gt;</code> is 100% unnecessary, adds nothing, and solves\n no problems.  It does not pay its utility bill.</p>\n</li>\n<li><p><strong>It favors the &ldquo;object bag of exported members&rdquo; approach, rather\nthan the &ldquo;single user-defined export&rdquo; approach.</strong>  Node.js uses an\n<code>exports</code> object because the CommonJS approach seemed like a good\nidea at the time, and it works around the fact that we have no good\nway to handle transitive dependencies except via unfinished objects.</p>\n<p> However, it is widely acknowledged in the node community that using\n the <code>module.exports = xyz</code> style generally results in better\n programs.  Changes at the language level can likely address the\n transitive loading issue more powerfully, and so should encourage\n the known best practices.</p>\n</li>\n</ol><h2>A Simpler Proposal</h2>\n<p>Clearly, the problems with the current state of JavaScript modules\ncannot be solved with zero changes to the language.  Some cannot be\nchanged without adding syntax.  However, every change carries with it a\ncost.  Therefor, it seems like the ideal approach is to try to find the\nminimum possible change that will address the issues &ndash; and, we ought to\nbe ruthless on which bits of functionality don&rsquo;t make the cut to be\nworth the risk.  If we can get away with a much smaller fix by refusing\nto address part of the problem which is inessential, then that is the\nright course of action.</p>\n<p>I don&rsquo;t know if this is minimal enough, but I&rsquo;d like to propose the\nfollowing, which I think picks some of the most essential aspects of the\nLoader and Module proposals.  It&rsquo;s very rough, and there are a lot of\nunanswered questions.  But in general, this is what I would like to see\nfrom a Loader specification.</p>\n<p><strong>This is very rough, and needs a lot of polish and edge-case\nexploration.</strong>  I&rsquo;m not pitching it to get it accepted, I&rsquo;m sharing it\nto hopefully help pull the conversation in another direction, and help\nmake it clear what a better proposal might look like.</p>\n<p>(I&rsquo;ve numbered them simply so that I can refer to bits later, not so\nmuch because they&rsquo;re a list of like things in order.  I&rsquo;m a spec n00b.)</p>\n<ol><li><p>A <code>Loader</code> built-in object, with a few methods that must be\nspecified before modules can be used.  (And will typically be\nspecified by the host object.)</p>\n</li>\n<li><p>Within a module, the <code>import &lt;pathString&gt;</code> syntax that can be easily\ndetected statically in program text before evaluation, and returns a\nmodule&rsquo;s exported object.  <code>var foo = import 'path/to/foo.js'</code>.\nImport returns a single value, always.  The path must be a string\nliteral.  The import keyword is an operator, not a function, and thus\ncannot be assigned etc.</p>\n</li>\n<li><p><code>Loader.define(&lt;path&gt;, &lt;program text&gt;)</code> defines a module at the\nspecified <code>&lt;path&gt;</code>, with the <code>&lt;program text&gt;</code> contents.  That\n<code>&lt;program text&gt;</code> is statically analyzed for any <code>import</code> statements.</p>\n</li>\n<li><p>Whenever an <code>import &lt;path&gt;</code> is encountered in <code>&lt;program text&gt;</code> then\nthe <code>Loader.resolve(requestPath, callerPath, callback)</code> is called.\nThis method should return a fully qualified path.  If this method\nreturns boolean <code>true</code>, then it will not be considered resolved until\nthe callback is called.  (The argument to the callback is the string\npath.) If it does not return true, and does not return a string path,\nthen this is an error, and throws.</p>\n</li>\n<li><p>Once a module is resolved to a full path string, then\n<code>Loader.load(fullPath, callback)</code> is called.  <code>callback</code> should not\nbe called until <code>Loader.define(fullPath, contents)</code> is called.\nThis should be called at most once for any given <code>fullPath</code>.  (Is the\ncallback even necessary?  Why not just wait for <code>Loader.define</code> and\nthrow any errors encountered?)</p>\n</li>\n<li><p>The <code>Loader.main(fullPath)</code> method executes the module referenced by\n<code>fullPath</code> (which must have already been defined), as well as\nevaluating each of the modules that it imports.</p>\n</li>\n<li><p>Within a module, the <code>export &lt;expression&gt;</code> statement marks the result\nof <code>&lt;expression&gt;</code> as the exported value from the module.  <strong>There can\nbe at most one export statement in a module</strong>, and the exported\nexpression is the module&rsquo;s export.  To export more than one thing,\nexport an object with more than one thing on it.</p>\n<p> Modules export a single value.  Exporting a second time throws.</p>\n<p> Maybe this is not a valid cause for syntax addition.  I&rsquo;m not sure.\n There are hairy problems around cyclic dependencies, so it&rsquo;s worth\n at least having the option to address with static magic that has not\n yet been fully imagined.</p>\n</li>\n<li><p>The global object within a module context is equivalent to\n<code>Object.create(&lt;global&gt;)</code> from the main global context.  (The\nimportant thing is that leaks aren&rsquo;t leaky outside the module, but\nfor example, <code>x typeof Error</code> still works, because it uses the same\nError function.)</p>\n</li>\n<li><p>If a module does not contain an <code>export</code> statement, then its global\nobject is its export.  This is to provide support for legacy modules\nthat create a global object (such as <code>jQuery</code>) rather than using an\nexport statement.  (Too magical?  Probably.  Also, what about having\nexports inheriting from global is weird.  Is there a simpler way to\nmake existing libs place nicely with this approach?)</p>\n</li>\n</ol><p>The default values of <code>Loader.load</code>, <code>Loader.define</code>, and\n<code>Loader.resolve</code> would typically be set by the host environment.\nHowever, for reasons of simplicity, they <strong>must</strong> be set in normal\nprogram text (ie, not in a module), and modules should not have the\nability to alter them.</p>\n<p>In web browsers, modules could be defined straight away by using a new\nattribute on the script tag: <code>&lt;script module\nsrc='http://src.com/foo.js'&gt;&lt;/script&gt;</code> would be equivalent to doing\n<code>Loader.define('http://src.com/foo.js', '&lt;contents of foo.js&gt;)</code>.</p>\n<p>Bundler programs could trivially translate files into modules using\nLoader.define (rather than wrapping in a IIFE), or JavaScript files\ncould be loaded as-is, without requiring that existing libraries begin\nusing any <code>module { ... }</code> syntax.</p>\n<h2>In Web Browsers</h2>\n<p>Web Browsers could implement the Loader object thusly:</p>\n<ul><li><code>Loader.resolve(request, from)</code> Uses standard URL-resolution rules.</li>\n<li><code>Loader.define</code> could be sweetened by a <code>&lt;script module&gt;</code> tag.</li>\n<li><code>Loader.main</code> could be set via a <code>&lt;script module main&gt;</code> tag.</li>\n<li><code>Loader.load</code> could fetch the URL, and evaluate the contents, as if it\nhad been added to the document with a <code>&lt;script module src=...&gt;</code> tag.</li>\n</ul><p>For additional extensibility, these methods could be overridden by, for\nexample, browserify or RequireJS.</p>\n<p>For security, the Loader object could be frozen with <code>Object.freeze</code> to\nprevent additional changes.</p>\n<p>I&rsquo;m in no way attached to the specifics of the tag spelling.  My point\nis that we in the JS community should specify the loader semantics, and\nthen let host objects take advantage of them in application-specific\nways.</p>\n<h2>In Require.JS</h2>\n<p>RequireJS and other AMD platforms would be pretty much made mostly\nobsolete by this specification, since the principle of AMD would just be\n&ldquo;how it works&rdquo; in web browsers by default.  But, without the unfortunate\nboilerplate, and the resource loading mechanism could kick off much\nsooner, since <code>import</code> statements can be detected long before the script\nis actually run.</p>\n<h2>In Browserify</h2>\n<p>Most browserify modules would Just Work if they replaced <code>require(..)</code>\nwith <code>import ..</code>.  However, it would probably be necessary to extend the\n<code>Loader</code> methods to provide shims for Node.js built-ins (ie, path, fs,\nurl, assert, net, http, etc.) as well as pre-define <code>node_modules</code>\ndependencies into the browserify bundle.</p>\n<p>However, Browserify&rsquo;s static analysis build step could be made much more\neffective by using a designated <code>import</code> operator rather than relying on\nknowledge of a <code>require</code> function.</p>\n<h2>In Node.js</h2>\n<ul><li><code>Loader.resolve(request, from)</code> would do the current <code>node_modules</code>\nand <code>NODE_PATH</code> dance.</li>\n<li><code>Loader.define</code> would replace the existing module wrapper stuff.</li>\n<li><code>Loader.main</code> would be called on the module specified as a command\nline argument.</li>\n<li><code>Loader.load</code> would be very straightforward FS operations.</li>\n</ul><p>This would also set the stage for making node-core itself more modular,\nand we could even explore new approaches like detecting module\ndependencies from code, rather than requiring the use of a\n<code>package.json</code> file, which is very exciting.</p>\n<h2>What&rsquo;s Missing from this Proposal</h2>\n<p>There is no <code>module</code> syntax in this &ldquo;module&rdquo; proposal.  That is because\nit is unnecessary, and its omission is intentional.</p>\n<p>A lot of work has also been done on the Harmony Module Loader proposal\nto flesh out some details of the Loader object.  Most of this is good\nstuff.  However, by removing the Module syntax portion of the proposal,\na lot of those things can be streamlined.</p>\n<p>It&rsquo;s also worth mentioning that this approach make sourcemaps\nunnecessary for useful stack traces, even in bundled or concatenated\ncode, as the <code>Loader.define()</code> syntax would function as a sourcemap.</p>\n<p>While the experience in the wild has shown us that the &ldquo;export one\nthing&rdquo; approach is definition sound, I&rsquo;m not sure exactly how to handle\nthe transitive dependency issue in a way that doesn&rsquo;t involve unfinished\nobjects, or cause breakage in cases like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\n\n// y.js\nsetTimeout(function() {\n  export { fooled: 'you' }\n}, 100)\n</code></pre><p>Even more insidious is something like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\nexport { real: 'x' }\n\n// y.js\nvar x = import './x.js'\nassert.deepEqual(x, {real: 'x'}) // nope!!\n</code></pre><p>Because <code>x</code> sets its export <em>after</em> being loaded by <code>y</code>, the assignment\ndoes nothing. Currently, in Node.js (and most other systems as well)\nthis is not handled, or not handled very well at least.</p>\n<p>Is there some way that it could somehow pass an object to the <code>x</code> module\nthat would get swapped out behind the scenes when <code>y.js</code> changes its\nexport?  Is that too magical?  I&rsquo;m not sure.</p>\n<h2>Next&hellip;</h2>\n<p>My hope is that this post will help spark a more interesting\nconversation than the current tendency towards &ldquo;YAY/BOO&rdquo; that is so\ncommon in the internet.  This isn&rsquo;t politics.  We&rsquo;re not voting for\nparties.  The goal is to figure out the best API, which is a complex\nthing.  The solution space is wide, and it is naive to reduce it to a\nboolean prematurely.</p>\n<p>I would like to try out some implementations of this in Node.js as soon\nas possible.  Also, I&rsquo;d love to hear feedback about which parts of this\nyou think are unnecessary or impossible.</p>\n<p>Let&rsquo;s not forget that we all want these problems solved.  No reasonable\nperson thinks that JavaScript programs are optimally modular today.\nMost people who enjoy Node&rsquo;s module system only like it because they&rsquo;ve\nnever taken a close look at it.  As one of its maintainers and chief\narchitects, I feel qualified to say that it&rsquo;s pretty terrible.  (Though,\nin my opinion, it is the best I&rsquo;ve used, and the only that is optimized\nfor maximum utility and an absolute intolerance for boilerplate.  It&rsquo;s\njust that the language is lacking, but that&rsquo;s what this is all about.)</p>\n<p>Not every change is an improvement, but every improvement is a change.\nMy friends in the &ldquo;no new syntax&rdquo; crowd would do well to remember that.</p>\n<p>That being said, since JavaScript cannot be easily changed, and can only\nbe changed in one direction, we must be very careful to make sure that\nevery change <strong>is</strong> an improvement.  It&rsquo;s more important to proceed\ncarefully than to proceed quickly.</p>\n<p>Future generations will thank us for our care, and curse us for our haste.</p>\n</p>",
            "content_raw": "<p><p><i>Note: This was written quite some time ago.  The current ES6 Module specification has changed a lot since then, and many of my complaints have been addressed.  Treat this essay as a piece of history.  <a href=\"#module-essay\">click here to acknowledge this caveat and read the essay.</a></i></p>\n\n<hr><div id=\"module-essay\" class=\"hidden-content\">\n<p>A few things have rubbed me the wrong way about the current Modules and\nModule Loader specification.  I regret that I have not been very clear\nabout what exactly my objections are, and worse still, I have not been\nvery clear about what I think a better direction would be.</p>\n<p><strong>Yes, this will be sent to ES-Discuss as a proper discussion\nproposal.</strong> This blog post is phase three of getting my ideas in order.\n(The first being \u201cget annoyed that current proposals don\u2019t fix the\nproblem\u201d, and the second being \u201crant about it with friends and\ncolleagues on twitter and over tacos.\u201d)</p>\n<p>First of all, I want to put to rest any ideas that I\u2019m a die-hard\nJavaScript language conservative ideologue who will oppose any change\nwhatsoever.  I am well aware that what we have is lacking.  I would love\nto see changes that make it easier to write JavaScript module systems,\nand debug programs that use them.</p>\n<p>I believe that there is a place for new syntax, especially in cases\nwhere it allows for optimizations in the implementation, ease of\nreading, or run-time behavior that must occur before the program is\nexecuted (that is, static analysis stuff.)  Parsing a plain-old\nJavaScript AST is certainly possible, but it\u2019s a bit unfortunate.</p>\n<p><a name=\"module-problems\"></a>We\u2019ve spent a few years now doing modules in JavaScript.  The claim that\n\u201cJavaScript needs modules\u201d is thus somewhat misguided: JavaScript needs\n<strong>better</strong> modules.  Leaving aside Node.js for the moment, modular\nsystems in JavaScript generally:</p>\n<ol><li>Impose boilerplate restrictions on the programmer.  This is ugly and\nerror-prone, and there is no easy way to catch many of these errors\nearly.</li>\n<li>Are not inter-operable with code that uses a different module system\n(or none at all).</li>\n<li>Either require that all modules be present in the page at the start,\nor delay the execution of the program unacceptably.  (No one does\nsync XHR.  I\u2019m talking about r.js/AMD and the YUI3 seed file here.)</li>\n<li>Leaks internal implementation details in unfortunate ways, so that\nusers are sometimes surprised when behavior violates intuitions.</li>\n<li>Do not isolate global leakage, making a missing <code>var</code> a felony, when\nit shouldn\u2019t even be a misdemeanor.  (At best, they wrap in a\nfunction.)</li>\n<li>To varying degrees, line and column numbers are obscured.  (Sometimes\njust the first line\u2019s column; sometimes the stack traces are\ncompletely meaningless.)</li>\n</ol><p><strong>All</strong> of these problems are issues with Node.js as well!  We paper\nover #3 by using a package manager and requiring that the modules in\nyour program are available on the disk at the start, but it\u2019s still in\nmy opinion unacceptable.  We have the advantage of \u201cstartup time\u201d and\n\u201crun time\u201d separation, but really, <code>&lt;script&gt;</code> tags are a web browser\u2019s\n\u201cstartup time\u201d, and the rest of the time is its \u201crun time\u201d.  Build\nprocesses allow one to trade run-time delay (and complexity) for\nup-front download size (and a simpler synchronous <code>require()</code>), but\ngenerally only by making the other problems worse.</p>\n<p>TC-39 has one chance to specify a Module system that can address each of\nthese issues, or allow host platforms to address them effectively.\nProblems introduced here will be with us forever.  A half-way fix will\nbe prohibitively expensive to fix once it\u2019s in use, so we\u2019ll be stuck\nwith mistakes for some time (as we in Node.js are stuck with the\nmistakes in our system.)</p>\n<h2 id=\"the-good-in-the-current-spec\">The Good in the Current Spec</h2>\n<p>Though I think it has deep problems, there are very good parts in the\ncurrent spec:</p>\n<ol><li>It clearly is <em>attempting</em> to reach a module system that addresses\nthe needs of Node.js (and whatever on-device JavaScript platforms\nsucceed it), as well as those of browser-JavaScript authors and\nplatforms like RequireJS and Browserify.</li>\n<li>The issues around globals and scope are pretty solid.  I don\u2019t have\nmuch to complain about there.  Any changes to global behavior come\nalong with a pile of edge cases, but they\u2019re pretty thorougly\nevaluated and addressed.</li>\n<li>The goals of both the Module and Loader proposals had me pretty much\ncheering.  It seems like TC-39 is actually interested in solving a\nproblem, and that gives me hope.</li>\n</ol><p>More than anything, reading the spec makes it clear that the <em>problem</em>\nis fairly well understood.  However, the presented <em>solution</em> seems to\nbe headed in the wrong direction.</p>\n<h2 id=\"problems-with-the-current-spec\">Problems with the Current Spec</h2>\n<p>I\u2019m not going to go through the issues that I have with the current\nspec one by one.  It\u2019s tedious and not the conversation we should be\nhaving.  I\u2019ll detail my alternative proposal below.</p>\n<p>However, there are a few points I\u2019d like to highlight, because they are\nissues that probably ought to be informed by the experience that I and\nother module system authors and users can provide.</p>\n<ol><li><p><strong>It seems to be based on the assumption that nesting module systems is\na thing that people want.</strong>  Historically, in Node, we\u2019ve made several\nAPI decisions based on the <em>explicitly stated requests</em> to make the\nmodule system more extensible and flexible.  In practice, none of the\nsupposed innovation panned out, and every one of those decisions was\na huge mistake that increased flexibility with no tangible benefit.</p>\n<p> People don\u2019t want to write module systems.  People want to <strong>stop</strong>\n writing module systems.  Once there\u2019s a module system in place, it\n should be The module system, period.</p>\n<p> It bears repeating: <strong>no one wants to write a module system</strong>.  A\n few of us take it on out of regrettable necessity.  Anyone who\n actually <strong>enjoys</strong> writing module systems is too insane to be\n trusted.  The only rational position is to do the simplest necessary\n thing, and as quickly as possible get to the business of building\n real programs with it.  Optimize for that.</p>\n</li>\n<li><p><strong>It puts too many things in JavaScript (as either API or syntax)\nwhich belong in the host (browser/node.js).</strong>  As I said, people\ndon\u2019t actually want to write module systems in their JavaScript\nprograms.  They want to stop having to think about it.  Node\u2019s module\nsystem has been successful (as has require.js and browserify)\nprecisely because it requires a minimum amount of <em>thought</em> on the\npart of the user about the module system.  (It\u2019s still way too much.)</p>\n<p> Adding features that add complexity with the goal of making it\n easier to have lots of module systems in JavaScript is a mistake.\n Typically we can enable extension more effectively by <strong>reducing</strong>\n the scope of the specification, rather than by increasing it.</p>\n</li>\n<li><p><strong>It borrows syntax from Python that many Python users do not even\nrecommend using.</strong>  The <code>import * from mod</code> syntax is dated and\nhighly contentious in the Python community (as is <code>import com.foo.*</code>\nin Java), because it is a recipe for name collisions.  Learning from\nreal implementations is winful; but we should be avoiding their\nmistakes, not copying them.</p>\n<p> Furthermore, <code>let</code> already gives us destructuring assignment.  If\n a module exports a bunch of items, and we want several of them, then\n do <code>var {x,y,z} = import 'foo'</code> or some such.  This <code>import &lt;x&gt; from\n &lt;module&gt; as &lt;blerg&gt;</code> is 100% unnecessary, adds nothing, and solves\n no problems.  It does not pay its utility bill.</p>\n</li>\n<li><p><strong>It favors the \u201cobject bag of exported members\u201d approach, rather\nthan the \u201csingle user-defined export\u201d approach.</strong>  Node.js uses an\n<code>exports</code> object because the CommonJS approach seemed like a good\nidea at the time, and it works around the fact that we have no good\nway to handle transitive dependencies except via unfinished objects.</p>\n<p> However, it is widely acknowledged in the node community that using\n the <code>module.exports = xyz</code> style generally results in better\n programs.  Changes at the language level can likely address the\n transitive loading issue more powerfully, and so should encourage\n the known best practices.</p>\n</li>\n</ol><h2 id=\"a-simpler-proposal\">A Simpler Proposal</h2>\n<p>Clearly, the problems with the current state of JavaScript modules\ncannot be solved with zero changes to the language.  Some cannot be\nchanged without adding syntax.  However, every change carries with it a\ncost.  Therefor, it seems like the ideal approach is to try to find the\nminimum possible change that will address the issues \u2013 and, we ought to\nbe ruthless on which bits of functionality don\u2019t make the cut to be\nworth the risk.  If we can get away with a much smaller fix by refusing\nto address part of the problem which is inessential, then that is the\nright course of action.</p>\n<p>I don\u2019t know if this is minimal enough, but I\u2019d like to propose the\nfollowing, which I think picks some of the most essential aspects of the\nLoader and Module proposals.  It\u2019s very rough, and there are a lot of\nunanswered questions.  But in general, this is what I would like to see\nfrom a Loader specification.</p>\n<p><strong>This is very rough, and needs a lot of polish and edge-case\nexploration.</strong>  I\u2019m not pitching it to get it accepted, I\u2019m sharing it\nto hopefully help pull the conversation in another direction, and help\nmake it clear what a better proposal might look like.</p>\n<p>(I\u2019ve numbered them simply so that I can refer to bits later, not so\nmuch because they\u2019re a list of like things in order.  I\u2019m a spec n00b.)</p>\n<ol><li><p>A <code>Loader</code> built-in object, with a few methods that must be\nspecified before modules can be used.  (And will typically be\nspecified by the host object.)</p>\n</li>\n<li><p>Within a module, the <code>import &lt;pathString&gt;</code> syntax that can be easily\ndetected statically in program text before evaluation, and returns a\nmodule\u2019s exported object.  <code>var foo = import 'path/to/foo.js'</code>.\nImport returns a single value, always.  The path must be a string\nliteral.  The import keyword is an operator, not a function, and thus\ncannot be assigned etc.</p>\n</li>\n<li><p><code>Loader.define(&lt;path&gt;, &lt;program text&gt;)</code> defines a module at the\nspecified <code>&lt;path&gt;</code>, with the <code>&lt;program text&gt;</code> contents.  That\n<code>&lt;program text&gt;</code> is statically analyzed for any <code>import</code> statements.</p>\n</li>\n<li><p>Whenever an <code>import &lt;path&gt;</code> is encountered in <code>&lt;program text&gt;</code> then\nthe <code>Loader.resolve(requestPath, callerPath, callback)</code> is called.\nThis method should return a fully qualified path.  If this method\nreturns boolean <code>true</code>, then it will not be considered resolved until\nthe callback is called.  (The argument to the callback is the string\npath.) If it does not return true, and does not return a string path,\nthen this is an error, and throws.</p>\n</li>\n<li><p>Once a module is resolved to a full path string, then\n<code>Loader.load(fullPath, callback)</code> is called.  <code>callback</code> should not\nbe called until <code>Loader.define(fullPath, contents)</code> is called.\nThis should be called at most once for any given <code>fullPath</code>.  (Is the\ncallback even necessary?  Why not just wait for <code>Loader.define</code> and\nthrow any errors encountered?)</p>\n</li>\n<li><p>The <code>Loader.main(fullPath)</code> method executes the module referenced by\n<code>fullPath</code> (which must have already been defined), as well as\nevaluating each of the modules that it imports.</p>\n</li>\n<li><p>Within a module, the <code>export &lt;expression&gt;</code> statement marks the result\nof <code>&lt;expression&gt;</code> as the exported value from the module.  <strong>There can\nbe at most one export statement in a module</strong>, and the exported\nexpression is the module\u2019s export.  To export more than one thing,\nexport an object with more than one thing on it.</p>\n<p> Modules export a single value.  Exporting a second time throws.</p>\n<p> Maybe this is not a valid cause for syntax addition.  I\u2019m not sure.\n There are hairy problems around cyclic dependencies, so it\u2019s worth\n at least having the option to address with static magic that has not\n yet been fully imagined.</p>\n</li>\n<li><p>The global object within a module context is equivalent to\n<code>Object.create(&lt;global&gt;)</code> from the main global context.  (The\nimportant thing is that leaks aren\u2019t leaky outside the module, but\nfor example, <code>x typeof Error</code> still works, because it uses the same\nError function.)</p>\n</li>\n<li><p>If a module does not contain an <code>export</code> statement, then its global\nobject is its export.  This is to provide support for legacy modules\nthat create a global object (such as <code>jQuery</code>) rather than using an\nexport statement.  (Too magical?  Probably.  Also, what about having\nexports inheriting from global is weird.  Is there a simpler way to\nmake existing libs place nicely with this approach?)</p>\n</li>\n</ol><p>The default values of <code>Loader.load</code>, <code>Loader.define</code>, and\n<code>Loader.resolve</code> would typically be set by the host environment.\nHowever, for reasons of simplicity, they <strong>must</strong> be set in normal\nprogram text (ie, not in a module), and modules should not have the\nability to alter them.</p>\n<p>In web browsers, modules could be defined straight away by using a new\nattribute on the script tag: <code>&lt;script module\nsrc='http://src.com/foo.js'&gt;&lt;/script&gt;</code> would be equivalent to doing\n<code>Loader.define('http://src.com/foo.js', '&lt;contents of foo.js&gt;)</code>.</p>\n<p>Bundler programs could trivially translate files into modules using\nLoader.define (rather than wrapping in a IIFE), or JavaScript files\ncould be loaded as-is, without requiring that existing libraries begin\nusing any <code>module { ... }</code> syntax.</p>\n<h2 id=\"in-web-browsers\">In Web Browsers</h2>\n<p>Web Browsers could implement the Loader object thusly:</p>\n<ul><li><code>Loader.resolve(request, from)</code> Uses standard URL-resolution rules.</li>\n<li><code>Loader.define</code> could be sweetened by a <code>&lt;script module&gt;</code> tag.</li>\n<li><code>Loader.main</code> could be set via a <code>&lt;script module main&gt;</code> tag.</li>\n<li><code>Loader.load</code> could fetch the URL, and evaluate the contents, as if it\nhad been added to the document with a <code>&lt;script module src=...&gt;</code> tag.</li>\n</ul><p>For additional extensibility, these methods could be overridden by, for\nexample, browserify or RequireJS.</p>\n<p>For security, the Loader object could be frozen with <code>Object.freeze</code> to\nprevent additional changes.</p>\n<p>I\u2019m in no way attached to the specifics of the tag spelling.  My point\nis that we in the JS community should specify the loader semantics, and\nthen let host objects take advantage of them in application-specific\nways.</p>\n<h2 id=\"in-require-js\">In Require.JS</h2>\n<p>RequireJS and other AMD platforms would be pretty much made mostly\nobsolete by this specification, since the principle of AMD would just be\n\u201chow it works\u201d in web browsers by default.  But, without the unfortunate\nboilerplate, and the resource loading mechanism could kick off much\nsooner, since <code>import</code> statements can be detected long before the script\nis actually run.</p>\n<h2 id=\"in-browserify\">In Browserify</h2>\n<p>Most browserify modules would Just Work if they replaced <code>require(..)</code>\nwith <code>import ..</code>.  However, it would probably be necessary to extend the\n<code>Loader</code> methods to provide shims for Node.js built-ins (ie, path, fs,\nurl, assert, net, http, etc.) as well as pre-define <code>node_modules</code>\ndependencies into the browserify bundle.</p>\n<p>However, Browserify\u2019s static analysis build step could be made much more\neffective by using a designated <code>import</code> operator rather than relying on\nknowledge of a <code>require</code> function.</p>\n<h2 id=\"in-node-js\">In Node.js</h2>\n<ul><li><code>Loader.resolve(request, from)</code> would do the current <code>node_modules</code>\nand <code>NODE_PATH</code> dance.</li>\n<li><code>Loader.define</code> would replace the existing module wrapper stuff.</li>\n<li><code>Loader.main</code> would be called on the module specified as a command\nline argument.</li>\n<li><code>Loader.load</code> would be very straightforward FS operations.</li>\n</ul><p>This would also set the stage for making node-core itself more modular,\nand we could even explore new approaches like detecting module\ndependencies from code, rather than requiring the use of a\n<code>package.json</code> file, which is very exciting.</p>\n<h2 id=\"what-s-missing-from-this-proposal\">What\u2019s Missing from this Proposal</h2>\n<p>There is no <code>module</code> syntax in this \u201cmodule\u201d proposal.  That is because\nit is unnecessary, and its omission is intentional.</p>\n<p>A lot of work has also been done on the Harmony Module Loader proposal\nto flesh out some details of the Loader object.  Most of this is good\nstuff.  However, by removing the Module syntax portion of the proposal,\na lot of those things can be streamlined.</p>\n<p>It\u2019s also worth mentioning that this approach make sourcemaps\nunnecessary for useful stack traces, even in bundled or concatenated\ncode, as the <code>Loader.define()</code> syntax would function as a sourcemap.</p>\n<p>While the experience in the wild has shown us that the \u201cexport one\nthing\u201d approach is definition sound, I\u2019m not sure exactly how to handle\nthe transitive dependency issue in a way that doesn\u2019t involve unfinished\nobjects, or cause breakage in cases like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\n\n// y.js\nsetTimeout(function() {\n  export { fooled: 'you' }\n}, 100)\n</code></pre><p>Even more insidious is something like this:</p>\n<pre><code>// x.js\nvar y = import './y.js'\nexport { real: 'x' }\n\n// y.js\nvar x = import './x.js'\nassert.deepEqual(x, {real: 'x'}) // nope!!\n</code></pre><p>Because <code>x</code> sets its export <em>after</em> being loaded by <code>y</code>, the assignment\ndoes nothing. Currently, in Node.js (and most other systems as well)\nthis is not handled, or not handled very well at least.</p>\n<p>Is there some way that it could somehow pass an object to the <code>x</code> module\nthat would get swapped out behind the scenes when <code>y.js</code> changes its\nexport?  Is that too magical?  I\u2019m not sure.</p>\n<h2 id=\"next-\">Next\u2026</h2>\n<p>My hope is that this post will help spark a more interesting\nconversation than the current tendency towards \u201cYAY/BOO\u201d that is so\ncommon in the internet.  This isn\u2019t politics.  We\u2019re not voting for\nparties.  The goal is to figure out the best API, which is a complex\nthing.  The solution space is wide, and it is naive to reduce it to a\nboolean prematurely.</p>\n<p>I would like to try out some implementations of this in Node.js as soon\nas possible.  Also, I\u2019d love to hear feedback about which parts of this\nyou think are unnecessary or impossible.</p>\n<p>Let\u2019s not forget that we all want these problems solved.  No reasonable\nperson thinks that JavaScript programs are optimally modular today.\nMost people who enjoy Node\u2019s module system only like it because they\u2019ve\nnever taken a close look at it.  As one of its maintainers and chief\narchitects, I feel qualified to say that it\u2019s pretty terrible.  (Though,\nin my opinion, it is the best I\u2019ve used, and the only that is optimized\nfor maximum utility and an absolute intolerance for boilerplate.  It\u2019s\njust that the language is lacking, but that\u2019s what this is all about.)</p>\n<p>Not every change is an improvement, but every improvement is a change.\nMy friends in the \u201cno new syntax\u201d crowd would do well to remember that.</p>\n<p>That being said, since JavaScript cannot be easily changed, and can only\nbe changed in one direction, we must be very careful to make sure that\nevery change <strong>is</strong> an improvement.  It\u2019s more important to proceed\ncarefully than to proceed quickly.</p>\n<p>Future generations will thank us for our care, and curse us for our haste.</p>\n</div></p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "25906678790"
            }
        }
    ],
    "type": "text"
}