{
    "blog": {
        "description": "Writing and Stuff from Isaac Z. Schlueter",
        "name": "izs",
        "title": "blog.izs.me",
        "updated": 1544051896,
        "url": "http://blog.izs.me/",
        "uuid": "t:qZa3tMNNGjX7PQ45aXJ-jw"
    },
    "blog_name": "izs",
    "can_like": false,
    "can_reblog": false,
    "can_reply": false,
    "can_send_in_message": true,
    "caption": "<p>Watch this video.  I really like a lot of what he has to say.  Two main comments:</p>\n\n<ol><li><strong>165</strong> Exceptions in the standard library, is <em>enough</em>!?  <strong>Are you fucking kidding me?</strong>  JavaScript has 7, and if you ask me, that&rsquo;s way too many.  <code>URIError</code> is completely unnecessary, and <code>EvalError</code> is always better off being expressed as something else.  The only Error types you ever need to use in your code are <code>Error</code> or <code>TypeError</code>.  That being said, &ldquo;Don&rsquo;t create a new exception type&rdquo; is 100% spot-on.  Even having typed catches in the language encourages this kind of awful profusion.</li>\n<li>The reliance on &ldquo;the standard library&rdquo; is, imo, a bad thing.  The idea that we should not reinvent wheels is great.  s/standard library/npm registry/g and you&rsquo;ve got me.</li>\n</ol><p>Many aspects of the Node.js module system, and the npm package registry, are built with exactly these principles in mind.</p>\n\n<ol><li><code>module.exports</code> allows you to export a single thing from a module.  If I had the opportunity to do it again, I&rsquo;d only support that, rather than an <code>exports</code> object. If you really want to export multiple things, you&rsquo;d still be able to, but it should be an extra mental leap to do so.</li>\n<li>The single-level namespace in the npm registry makes it a bit less likely to end up with garbage like <code>com.initech.utils.UtilityFactory.UtilityFactoryExceptions.UtilityFactoryNotFoundException</code>.  &ldquo;Namespaces are for preventing collisions, not for creating taxonomies.&rdquo;  I cheered when he said this.</li>\n<li>Once upon a time, I foolishly implemented the proposed &ldquo;modules&rdquo; feature in package.json.  Ryan gave me a lot of shit about that and refused to support it in node, no matter how easy it was to do.  I realized (a bit too late) that he was absolutely right, and pissed off some folks by removing it.  Today, you get one <code>main</code> module defined in package.json.  That&rsquo;s it.  A package is a module.  Yes, a package is also a folder, and modules are files, so you <em>can</em> dive into it and get at its guts.  But it&rsquo;ll feel <em>off</em>, because it&rsquo;s weird, and non-standard.  You&rsquo;ll get funny looks.  <strong>This is on purpose,</strong> because it nudges you towards a flatter namespace by default.</li>\n</ol><p>The social engineering in node and npm is always more carrot than stick, and we always try to nudge people in a good direction by saying &ldquo;no&rdquo; to a feature rather than saying &ldquo;yes&rdquo; to one.  This hasn&rsquo;t been done perfectly in the past, but I am fairly proud of the results.</p>\n\n<p>It&rsquo;s a shock to someone who&rsquo;s used to writing giant monolithic programs, and has to re-think how they draw their boundaries.  That&rsquo;s good.  In fairly short order, things like local installs and limited exports start to &ldquo;click&rdquo; in a programmers mind most of the time.  I&rsquo;ve seen a lot of people start out frustrated and angry, and then a month later tell me how odd it is to use other platforms that don&rsquo;t have the a similar approach.</p>\n\n<p>When you solve a problem that others accept as the status quo, you often end up finding new problems.  You don&rsquo;t have to worry about coming up with unique descriptive names for your programs when you can nest them 7 layers deep underneath a company name.  You don&rsquo;t need to come up with approaches for managing a deep dependency graph if conflicts are insoluble.</p>\n\n<h2>Addendum</h2>\n\n<p>It&rsquo;s not that I&rsquo;m against using classes.  I&rsquo;ve written several programs that use classes extensively.  It&rsquo;s the proper abstraction for a long-lived object that needs to keep state and be interacted with.  The hoop-jumping required to do this sort of thing in pure functional languages, with accumulator sets and so on, is kind of silly sometimes.</p>\n\n<p>That being said, the <em>point</em> of using classes is to make things <em>easier</em>.  If your class is a fire-and-forget thing with a single method, then it&rsquo;s really just a function, and would be easier expressed in that manner.</p>\n\n<p>There&rsquo;s no hard and fast rule here.  You have to actually think about what would make your program easier to use, easier to debug, and easier to understand.</p>",
    "date": "2012-03-18 17:40:00 GMT",
    "display_avatar": true,
    "format": "markdown",
    "html5_capable": true,
    "id": 19521376222,
    "is_blocks_post_format": false,
    "note_count": 5,
    "permalink_url": "https://www.youtube.com/watch?v=o9pEzgHorH0",
    "player": [
        {
            "embed_code": "<iframe width=\"250\" height=\"187\"  id=\"youtube_iframe\" src=\"https://www.youtube.com/embed/o9pEzgHorH0?feature=oembed&amp;enablejsapi=1&amp;origin=https://safe.txmblr.com&amp;wmode=opaque\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
            "width": 250
        },
        {
            "embed_code": "<iframe width=\"400\" height=\"300\"  id=\"youtube_iframe\" src=\"https://www.youtube.com/embed/o9pEzgHorH0?feature=oembed&amp;enablejsapi=1&amp;origin=https://safe.txmblr.com&amp;wmode=opaque\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
            "width": 400
        },
        {
            "embed_code": "<iframe width=\"500\" height=\"375\"  id=\"youtube_iframe\" src=\"https://www.youtube.com/embed/o9pEzgHorH0?feature=oembed&amp;enablejsapi=1&amp;origin=https://safe.txmblr.com&amp;wmode=opaque\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
            "width": 500
        }
    ],
    "post_url": "http://blog.izs.me/post/19521376222/dont-use-classes",
    "reblog": {
        "comment": "<p>Watch this video.  I really like a lot of what he has to say.  Two main comments:</p>\n\n<ol><li><strong>165</strong> Exceptions in the standard library, is <em>enough</em>!?  <strong>Are you fucking kidding me?</strong>  JavaScript has 7, and if you ask me, that\u2019s way too many.  <code>URIError</code> is completely unnecessary, and <code>EvalError</code> is always better off being expressed as something else.  The only Error types you ever need to use in your code are <code>Error</code> or <code>TypeError</code>.  That being said, \u201cDon\u2019t create a new exception type\u201d is 100% spot-on.  Even having typed catches in the language encourages this kind of awful profusion.</li>\n<li>The reliance on \u201cthe standard library\u201d is, imo, a bad thing.  The idea that we should not reinvent wheels is great.  s/standard library/npm registry/g and you\u2019ve got me.</li>\n</ol><p>Many aspects of the Node.js module system, and the npm package registry, are built with exactly these principles in mind.</p>\n\n<ol><li><code>module.exports</code> allows you to export a single thing from a module.  If I had the opportunity to do it again, I\u2019d only support that, rather than an <code>exports</code> object. If you really want to export multiple things, you\u2019d still be able to, but it should be an extra mental leap to do so.</li>\n<li>The single-level namespace in the npm registry makes it a bit less likely to end up with garbage like <code>com.initech.utils.UtilityFactory.UtilityFactoryExceptions.UtilityFactoryNotFoundException</code>.  \u201cNamespaces are for preventing collisions, not for creating taxonomies.\u201d  I cheered when he said this.</li>\n<li>Once upon a time, I foolishly implemented the proposed \u201cmodules\u201d feature in package.json.  Ryan gave me a lot of shit about that and refused to support it in node, no matter how easy it was to do.  I realized (a bit too late) that he was absolutely right, and pissed off some folks by removing it.  Today, you get one <code>main</code> module defined in package.json.  That\u2019s it.  A package is a module.  Yes, a package is also a folder, and modules are files, so you <em>can</em> dive into it and get at its guts.  But it\u2019ll feel <em>off</em>, because it\u2019s weird, and non-standard.  You\u2019ll get funny looks.  <strong>This is on purpose,</strong> because it nudges you towards a flatter namespace by default.</li>\n</ol><p>The social engineering in node and npm is always more carrot than stick, and we always try to nudge people in a good direction by saying \u201cno\u201d to a feature rather than saying \u201cyes\u201d to one.  This hasn\u2019t been done perfectly in the past, but I am fairly proud of the results.</p>\n\n<p>It\u2019s a shock to someone who\u2019s used to writing giant monolithic programs, and has to re-think how they draw their boundaries.  That\u2019s good.  In fairly short order, things like local installs and limited exports start to \u201cclick\u201d in a programmers mind most of the time.  I\u2019ve seen a lot of people start out frustrated and angry, and then a month later tell me how odd it is to use other platforms that don\u2019t have the a similar approach.</p>\n\n<p>When you solve a problem that others accept as the status quo, you often end up finding new problems.  You don\u2019t have to worry about coming up with unique descriptive names for your programs when you can nest them 7 layers deep underneath a company name.  You don\u2019t need to come up with approaches for managing a deep dependency graph if conflicts are insoluble.</p>\n\n<h2>Addendum</h2>\n\n<p>It\u2019s not that I\u2019m against using classes.  I\u2019ve written several programs that use classes extensively.  It\u2019s the proper abstraction for a long-lived object that needs to keep state and be interacted with.  The hoop-jumping required to do this sort of thing in pure functional languages, with accumulator sets and so on, is kind of silly sometimes.</p>\n\n<p>That being said, the <em>point</em> of using classes is to make things <em>easier</em>.  If your class is a fire-and-forget thing with a single method, then it\u2019s really just a function, and would be easier expressed in that manner.</p>\n\n<p>There\u2019s no hard and fast rule here.  You have to actually think about what would make your program easier to use, easier to debug, and easier to understand.</p>",
        "tree_html": ""
    },
    "reblog_key": "dsjDzak9",
    "recommended_color": null,
    "recommended_source": null,
    "short_url": "https://tmblr.co/Z7nwWyIBa8-U",
    "slug": "dont-use-classes",
    "state": "published",
    "summary": "Watch this video.  I really like a lot of what he has to say.  Two main comments:\r\n\r\n1. **165** Exceptions in the standard...",
    "tags": [],
    "thumbnail_height": 360,
    "thumbnail_url": "https://i.ytimg.com/vi/o9pEzgHorH0/hqdefault.jpg",
    "thumbnail_width": 480,
    "timestamp": 1332092400,
    "trail": [
        {
            "blog": {
                "active": true,
                "can_be_followed": true,
                "name": "izs",
                "share_following": false,
                "share_likes": false,
                "theme": {
                    "avatar_shape": "square",
                    "background_color": "#444444",
                    "body_font": "Helvetica Neue",
                    "header_bounds": "978,2448,2355,0",
                    "header_focus_height": 1152,
                    "header_focus_width": 2048,
                    "header_full_height": 3264,
                    "header_full_width": 2448,
                    "header_image": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o.jpg",
                    "header_image_focused": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/mA1nbvglg/tumblr_static_tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_focused_v3.jpg",
                    "header_image_scaled": "https://static.tumblr.com/d248e27715343669f06a3852fd2cda53/utow0jf/nwUnbvgl6/tumblr_static_d2yiqqjdv1w8gsw0s0g4goc0o_2048_v2.jpg",
                    "header_stretch": true,
                    "link_color": "#FB4C16",
                    "show_avatar": true,
                    "show_description": true,
                    "show_header_image": true,
                    "show_title": true,
                    "title_color": "#fb4c16",
                    "title_font": "Gibson",
                    "title_font_weight": "regular"
                }
            },
            "content": "<p>Watch this video.  I really like a lot of what he has to say.  Two main comments:</p>\n\n<ol><li><strong>165</strong> Exceptions in the standard library, is <em>enough</em>!?  <strong>Are you fucking kidding me?</strong>  JavaScript has 7, and if you ask me, that&rsquo;s way too many.  <code>URIError</code> is completely unnecessary, and <code>EvalError</code> is always better off being expressed as something else.  The only Error types you ever need to use in your code are <code>Error</code> or <code>TypeError</code>.  That being said, &ldquo;Don&rsquo;t create a new exception type&rdquo; is 100% spot-on.  Even having typed catches in the language encourages this kind of awful profusion.</li>\n<li>The reliance on &ldquo;the standard library&rdquo; is, imo, a bad thing.  The idea that we should not reinvent wheels is great.  s/standard library/npm registry/g and you&rsquo;ve got me.</li>\n</ol><p>Many aspects of the Node.js module system, and the npm package registry, are built with exactly these principles in mind.</p>\n\n<ol><li><code>module.exports</code> allows you to export a single thing from a module.  If I had the opportunity to do it again, I&rsquo;d only support that, rather than an <code>exports</code> object. If you really want to export multiple things, you&rsquo;d still be able to, but it should be an extra mental leap to do so.</li>\n<li>The single-level namespace in the npm registry makes it a bit less likely to end up with garbage like <code>com.initech.utils.UtilityFactory.UtilityFactoryExceptions.UtilityFactoryNotFoundException</code>.  &ldquo;Namespaces are for preventing collisions, not for creating taxonomies.&rdquo;  I cheered when he said this.</li>\n<li>Once upon a time, I foolishly implemented the proposed &ldquo;modules&rdquo; feature in package.json.  Ryan gave me a lot of shit about that and refused to support it in node, no matter how easy it was to do.  I realized (a bit too late) that he was absolutely right, and pissed off some folks by removing it.  Today, you get one <code>main</code> module defined in package.json.  That&rsquo;s it.  A package is a module.  Yes, a package is also a folder, and modules are files, so you <em>can</em> dive into it and get at its guts.  But it&rsquo;ll feel <em>off</em>, because it&rsquo;s weird, and non-standard.  You&rsquo;ll get funny looks.  <strong>This is on purpose,</strong> because it nudges you towards a flatter namespace by default.</li>\n</ol><p>The social engineering in node and npm is always more carrot than stick, and we always try to nudge people in a good direction by saying &ldquo;no&rdquo; to a feature rather than saying &ldquo;yes&rdquo; to one.  This hasn&rsquo;t been done perfectly in the past, but I am fairly proud of the results.</p>\n\n<p>It&rsquo;s a shock to someone who&rsquo;s used to writing giant monolithic programs, and has to re-think how they draw their boundaries.  That&rsquo;s good.  In fairly short order, things like local installs and limited exports start to &ldquo;click&rdquo; in a programmers mind most of the time.  I&rsquo;ve seen a lot of people start out frustrated and angry, and then a month later tell me how odd it is to use other platforms that don&rsquo;t have the a similar approach.</p>\n\n<p>When you solve a problem that others accept as the status quo, you often end up finding new problems.  You don&rsquo;t have to worry about coming up with unique descriptive names for your programs when you can nest them 7 layers deep underneath a company name.  You don&rsquo;t need to come up with approaches for managing a deep dependency graph if conflicts are insoluble.</p>\n\n<h2>Addendum</h2>\n\n<p>It&rsquo;s not that I&rsquo;m against using classes.  I&rsquo;ve written several programs that use classes extensively.  It&rsquo;s the proper abstraction for a long-lived object that needs to keep state and be interacted with.  The hoop-jumping required to do this sort of thing in pure functional languages, with accumulator sets and so on, is kind of silly sometimes.</p>\n\n<p>That being said, the <em>point</em> of using classes is to make things <em>easier</em>.  If your class is a fire-and-forget thing with a single method, then it&rsquo;s really just a function, and would be easier expressed in that manner.</p>\n\n<p>There&rsquo;s no hard and fast rule here.  You have to actually think about what would make your program easier to use, easier to debug, and easier to understand.</p>",
            "content_raw": "<p>Watch this video.  I really like a lot of what he has to say.  Two main comments:</p>\n\n<ol><li><strong>165</strong> Exceptions in the standard library, is <em>enough</em>!?  <strong>Are you fucking kidding me?</strong>  JavaScript has 7, and if you ask me, that\u2019s way too many.  <code>URIError</code> is completely unnecessary, and <code>EvalError</code> is always better off being expressed as something else.  The only Error types you ever need to use in your code are <code>Error</code> or <code>TypeError</code>.  That being said, \u201cDon\u2019t create a new exception type\u201d is 100% spot-on.  Even having typed catches in the language encourages this kind of awful profusion.</li>\n<li>The reliance on \u201cthe standard library\u201d is, imo, a bad thing.  The idea that we should not reinvent wheels is great.  s/standard library/npm registry/g and you\u2019ve got me.</li>\n</ol><p>Many aspects of the Node.js module system, and the npm package registry, are built with exactly these principles in mind.</p>\n\n<ol><li><code>module.exports</code> allows you to export a single thing from a module.  If I had the opportunity to do it again, I\u2019d only support that, rather than an <code>exports</code> object. If you really want to export multiple things, you\u2019d still be able to, but it should be an extra mental leap to do so.</li>\n<li>The single-level namespace in the npm registry makes it a bit less likely to end up with garbage like <code>com.initech.utils.UtilityFactory.UtilityFactoryExceptions.UtilityFactoryNotFoundException</code>.  \u201cNamespaces are for preventing collisions, not for creating taxonomies.\u201d  I cheered when he said this.</li>\n<li>Once upon a time, I foolishly implemented the proposed \u201cmodules\u201d feature in package.json.  Ryan gave me a lot of shit about that and refused to support it in node, no matter how easy it was to do.  I realized (a bit too late) that he was absolutely right, and pissed off some folks by removing it.  Today, you get one <code>main</code> module defined in package.json.  That\u2019s it.  A package is a module.  Yes, a package is also a folder, and modules are files, so you <em>can</em> dive into it and get at its guts.  But it\u2019ll feel <em>off</em>, because it\u2019s weird, and non-standard.  You\u2019ll get funny looks.  <strong>This is on purpose,</strong> because it nudges you towards a flatter namespace by default.</li>\n</ol><p>The social engineering in node and npm is always more carrot than stick, and we always try to nudge people in a good direction by saying \u201cno\u201d to a feature rather than saying \u201cyes\u201d to one.  This hasn\u2019t been done perfectly in the past, but I am fairly proud of the results.</p>\n\n<p>It\u2019s a shock to someone who\u2019s used to writing giant monolithic programs, and has to re-think how they draw their boundaries.  That\u2019s good.  In fairly short order, things like local installs and limited exports start to \u201cclick\u201d in a programmers mind most of the time.  I\u2019ve seen a lot of people start out frustrated and angry, and then a month later tell me how odd it is to use other platforms that don\u2019t have the a similar approach.</p>\n\n<p>When you solve a problem that others accept as the status quo, you often end up finding new problems.  You don\u2019t have to worry about coming up with unique descriptive names for your programs when you can nest them 7 layers deep underneath a company name.  You don\u2019t need to come up with approaches for managing a deep dependency graph if conflicts are insoluble.</p>\n\n<h2>Addendum</h2>\n\n<p>It\u2019s not that I\u2019m against using classes.  I\u2019ve written several programs that use classes extensively.  It\u2019s the proper abstraction for a long-lived object that needs to keep state and be interacted with.  The hoop-jumping required to do this sort of thing in pure functional languages, with accumulator sets and so on, is kind of silly sometimes.</p>\n\n<p>That being said, the <em>point</em> of using classes is to make things <em>easier</em>.  If your class is a fire-and-forget thing with a single method, then it\u2019s really just a function, and would be easier expressed in that manner.</p>\n\n<p>There\u2019s no hard and fast rule here.  You have to actually think about what would make your program easier to use, easier to debug, and easier to understand.</p>",
            "is_current_item": true,
            "is_root_item": true,
            "post": {
                "id": "19521376222"
            }
        }
    ],
    "type": "video",
    "video": {
        "youtube": {
            "height": 344,
            "video_id": "o9pEzgHorH0",
            "width": 459
        }
    },
    "video_type": "youtube"
}